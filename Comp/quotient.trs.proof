WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
            quot(0(),y) -> 0()
            quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
        - Signature:
            {minus/2,quot/2} / {0/0,s/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus,quot} and constructors {0,s}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          minus#(x,0()) -> c_1()
          minus#(s(x),s(y)) -> c_2(minus#(x,y))
          quot#(0(),y) -> c_3()
          quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            minus#(x,0()) -> c_1()
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
            quot#(0(),y) -> c_3()
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
            quot(0(),y) -> 0()
            quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1,3}
        by application of
          Pre({1,3}) = {2,4}.
        Here rules are labelled as follows:
          1: minus#(x,0()) -> c_1()
          2: minus#(s(x),s(y)) -> c_2(minus#(x,y))
          3: quot#(0(),y) -> c_3()
          4: quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        - Weak DPs:
            minus#(x,0()) -> c_1()
            quot#(0(),y) -> c_3()
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
            quot(0(),y) -> 0()
            quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:minus#(s(x),s(y)) -> c_2(minus#(x,y))
             -->_1 minus#(x,0()) -> c_1():3
             -->_1 minus#(s(x),s(y)) -> c_2(minus#(x,y)):1
          
          2:S:quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
             -->_1 quot#(0(),y) -> c_3():4
             -->_2 minus#(x,0()) -> c_1():3
             -->_1 quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y)):2
             -->_2 minus#(s(x),s(y)) -> c_2(minus#(x,y)):1
          
          3:W:minus#(x,0()) -> c_1()
             
          
          4:W:quot#(0(),y) -> c_3()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          4: quot#(0(),y) -> c_3()
          3: minus#(x,0()) -> c_1()
* Step 4: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
            quot(0(),y) -> 0()
            quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          minus(x,0()) -> x
          minus(s(x),s(y)) -> minus(x,y)
          minus#(s(x),s(y)) -> c_2(minus#(x,y))
          quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
* Step 5: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        and a lower component
          minus#(s(x),s(y)) -> c_2(minus#(x,y))
        Further, following extension rules are added to the lower component.
          quot#(s(x),s(y)) -> minus#(x,y)
          quot#(s(x),s(y)) -> quot#(minus(x,y),s(y))
** Step 5.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y))
             -->_1 quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)),minus#(x,y)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)))
** Step 5.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(quot#) = {1},
            uargs(c_4) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(0) = [1]                  
             p(minus) = [1] x1 + [3]         
              p(quot) = [1] x1 + [2] x2 + [1]
                 p(s) = [1] x1 + [4]         
            p(minus#) = [1] x1 + [8]         
             p(quot#) = [1] x1 + [1]         
               p(c_1) = [1]                  
               p(c_2) = [1] x1 + [0]         
               p(c_3) = [1]                  
               p(c_4) = [1] x1 + [0]         
          
          Following rules are strictly oriented:
          quot#(s(x),s(y)) = [1] x + [5]                
                           > [1] x + [4]                
                           = c_4(quot#(minus(x,y),s(y)))
          
          
          Following rules are (at-least) weakly oriented:
              minus(x,0()) =  [1] x + [3]
                           >= [1] x + [0]
                           =  x          
          
          minus(s(x),s(y)) =  [1] x + [7]
                           >= [1] x + [3]
                           =  minus(x,y) 
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 5.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            quot#(s(x),s(y)) -> c_4(quot#(minus(x,y),s(y)))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 5.b:1: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
        - Weak DPs:
            quot#(s(x),s(y)) -> minus#(x,y)
            quot#(s(x),s(y)) -> quot#(minus(x,y),s(y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(quot#) = {1},
            uargs(c_2) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(0) = [0]                  
             p(minus) = [1] x1 + [0]         
              p(quot) = [0]                  
                 p(s) = [1] x1 + [1]         
            p(minus#) = [8] x2 + [12]        
             p(quot#) = [1] x1 + [8] x2 + [8]
               p(c_1) = [0]                  
               p(c_2) = [1] x1 + [0]         
               p(c_3) = [0]                  
               p(c_4) = [1] x1 + [2] x2 + [1]
          
          Following rules are strictly oriented:
          minus#(s(x),s(y)) = [8] y + [20]    
                            > [8] y + [12]    
                            = c_2(minus#(x,y))
          
          
          Following rules are (at-least) weakly oriented:
          quot#(s(x),s(y)) =  [1] x + [8] y + [17]  
                           >= [8] y + [12]          
                           =  minus#(x,y)           
          
          quot#(s(x),s(y)) =  [1] x + [8] y + [17]  
                           >= [1] x + [8] y + [16]  
                           =  quot#(minus(x,y),s(y))
          
              minus(x,0()) =  [1] x + [0]           
                           >= [1] x + [0]           
                           =  x                     
          
          minus(s(x),s(y)) =  [1] x + [1]           
                           >= [1] x + [0]           
                           =  minus(x,y)            
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 5.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            minus#(s(x),s(y)) -> c_2(minus#(x,y))
            quot#(s(x),s(y)) -> minus#(x,y)
            quot#(s(x),s(y)) -> quot#(minus(x,y),s(y))
        - Weak TRS:
            minus(x,0()) -> x
            minus(s(x),s(y)) -> minus(x,y)
        - Signature:
            {minus/2,quot/2,minus#/2,quot#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/0,c_4/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {minus#,quot#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

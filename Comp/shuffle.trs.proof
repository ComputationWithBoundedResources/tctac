WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
            shuffle(dd(x,xs)) -> dd(x,shuffle(rev(xs)))
            shuffle(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1} / {dd/2,nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@,rev,shuffle} and constructors {dd,nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          @#(nil(),ys) -> c_2()
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          rev#(nil()) -> c_4()
          shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
          shuffle#(nil()) -> c_6()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            @#(nil(),ys) -> c_2()
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
            rev#(nil()) -> c_4()
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
            shuffle#(nil()) -> c_6()
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
            shuffle(dd(x,xs)) -> dd(x,shuffle(rev(xs)))
            shuffle(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4,6}
        by application of
          Pre({2,4,6}) = {1,3,5}.
        Here rules are labelled as follows:
          1: @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          2: @#(nil(),ys) -> c_2()
          3: rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          4: rev#(nil()) -> c_4()
          5: shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
          6: shuffle#(nil()) -> c_6()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
        - Weak DPs:
            @#(nil(),ys) -> c_2()
            rev#(nil()) -> c_4()
            shuffle#(nil()) -> c_6()
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
            shuffle(dd(x,xs)) -> dd(x,shuffle(rev(xs)))
            shuffle(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:@#(dd(x,xs),ys) -> c_1(@#(xs,ys))
             -->_1 @#(nil(),ys) -> c_2():4
             -->_1 @#(dd(x,xs),ys) -> c_1(@#(xs,ys)):1
          
          2:S:rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
             -->_2 rev#(nil()) -> c_4():5
             -->_1 @#(nil(),ys) -> c_2():4
             -->_2 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):2
             -->_1 @#(dd(x,xs),ys) -> c_1(@#(xs,ys)):1
          
          3:S:shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
             -->_1 shuffle#(nil()) -> c_6():6
             -->_2 rev#(nil()) -> c_4():5
             -->_1 shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs)):3
             -->_2 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):2
          
          4:W:@#(nil(),ys) -> c_2()
             
          
          5:W:rev#(nil()) -> c_4()
             
          
          6:W:shuffle#(nil()) -> c_6()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          6: shuffle#(nil()) -> c_6()
          5: rev#(nil()) -> c_4()
          4: @#(nil(),ys) -> c_2()
* Step 4: UsableRules WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
            shuffle(dd(x,xs)) -> dd(x,shuffle(rev(xs)))
            shuffle(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          @(dd(x,xs),ys) -> dd(x,@(xs,ys))
          @(nil(),ys) -> ys
          rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
          rev(nil()) -> nil()
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
* Step 5: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
        and a lower component
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        Further, following extension rules are added to the lower component.
          shuffle#(dd(x,xs)) -> rev#(xs)
          shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
** Step 5.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs))
             -->_1 shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)),rev#(xs)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)))
** Step 5.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/1,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(@) = {1},
            uargs(dd) = {2},
            uargs(shuffle#) = {1},
            uargs(c_5) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                   p(@) = [1] x1 + [1] x2 + [0]
                  p(dd) = [1] x2 + [1]         
                 p(nil) = [0]                  
                 p(rev) = [1] x1 + [0]         
             p(shuffle) = [2] x1 + [1]         
                  p(@#) = [2]                  
                p(rev#) = [1] x1 + [0]         
            p(shuffle#) = [1] x1 + [0]         
                 p(c_1) = [4]                  
                 p(c_2) = [0]                  
                 p(c_3) = [1] x1 + [1]         
                 p(c_4) = [1]                  
                 p(c_5) = [1] x1 + [0]         
                 p(c_6) = [0]                  
          
          Following rules are strictly oriented:
          shuffle#(dd(x,xs)) = [1] xs + [1]          
                             > [1] xs + [0]          
                             = c_5(shuffle#(rev(xs)))
          
          
          Following rules are (at-least) weakly oriented:
          @(dd(x,xs),ys) =  [1] xs + [1] ys + [1] 
                         >= [1] xs + [1] ys + [1] 
                         =  dd(x,@(xs,ys))        
          
             @(nil(),ys) =  [1] ys + [0]          
                         >= [1] ys + [0]          
                         =  ys                    
          
           rev(dd(x,xs)) =  [1] xs + [1]          
                         >= [1] xs + [1]          
                         =  @(rev(xs),dd(x,nil()))
          
              rev(nil()) =  [0]                   
                         >= [0]                   
                         =  nil()                 
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 5.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            shuffle#(dd(x,xs)) -> c_5(shuffle#(rev(xs)))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/1,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 5.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        - Weak DPs:
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          shuffle#(dd(x,xs)) -> rev#(xs)
          shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        and a lower component
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
        Further, following extension rules are added to the lower component.
          rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
          rev#(dd(x,xs)) -> rev#(xs)
          shuffle#(dd(x,xs)) -> rev#(xs)
          shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
*** Step 5.b:1.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        - Weak DPs:
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
             -->_2 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):1
          
          2:W:shuffle#(dd(x,xs)) -> rev#(xs)
             -->_1 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):1
          
          3:W:shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
             -->_1 shuffle#(dd(x,xs)) -> shuffle#(rev(xs)):3
             -->_1 shuffle#(dd(x,xs)) -> rev#(xs):2
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          rev#(dd(x,xs)) -> c_3(rev#(xs))
*** Step 5.b:1.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#(dd(x,xs)) -> c_3(rev#(xs))
        - Weak DPs:
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(@) = {1},
            uargs(dd) = {2},
            uargs(shuffle#) = {1},
            uargs(c_3) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                   p(@) = [1] x1 + [1] x2 + [0]
                  p(dd) = [1] x2 + [9]         
                 p(nil) = [0]                  
                 p(rev) = [1] x1 + [1]         
             p(shuffle) = [1] x1 + [0]         
                  p(@#) = [0]                  
                p(rev#) = [1] x1 + [0]         
            p(shuffle#) = [1] x1 + [9]         
                 p(c_1) = [1] x1 + [0]         
                 p(c_2) = [0]                  
                 p(c_3) = [1] x1 + [0]         
                 p(c_4) = [0]                  
                 p(c_5) = [2] x1 + [1] x2 + [0]
                 p(c_6) = [8]                  
          
          Following rules are strictly oriented:
          rev#(dd(x,xs)) = [1] xs + [9] 
                         > [1] xs + [0] 
                         = c_3(rev#(xs))
          
          
          Following rules are (at-least) weakly oriented:
          shuffle#(dd(x,xs)) =  [1] xs + [18]         
                             >= [1] xs + [0]          
                             =  rev#(xs)              
          
          shuffle#(dd(x,xs)) =  [1] xs + [18]         
                             >= [1] xs + [10]         
                             =  shuffle#(rev(xs))     
          
              @(dd(x,xs),ys) =  [1] xs + [1] ys + [9] 
                             >= [1] xs + [1] ys + [9] 
                             =  dd(x,@(xs,ys))        
          
                 @(nil(),ys) =  [1] ys + [0]          
                             >= [1] ys + [0]          
                             =  ys                    
          
               rev(dd(x,xs)) =  [1] xs + [10]         
                             >= [1] xs + [10]         
                             =  @(rev(xs),dd(x,nil()))
          
                  rev(nil()) =  [1]                   
                             >= [0]                   
                             =  nil()                 
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 5.b:1.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            rev#(dd(x,xs)) -> c_3(rev#(xs))
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 5.b:1.b:1: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
        - Weak DPs:
            rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
            rev#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(@) = {1},
            uargs(dd) = {2},
            uargs(@#) = {1},
            uargs(shuffle#) = {1},
            uargs(c_1) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                   p(@) = [1] x1 + [1] x2 + [0]
                  p(dd) = [1] x2 + [1]         
                 p(nil) = [0]                  
                 p(rev) = [1] x1 + [0]         
             p(shuffle) = [2] x1 + [1]         
                  p(@#) = [1] x1 + [0]         
                p(rev#) = [1] x1 + [0]         
            p(shuffle#) = [1] x1 + [7]         
                 p(c_1) = [1] x1 + [0]         
                 p(c_2) = [0]                  
                 p(c_3) = [2] x1 + [1] x2 + [0]
                 p(c_4) = [4]                  
                 p(c_5) = [2] x1 + [1] x2 + [1]
                 p(c_6) = [1]                  
          
          Following rules are strictly oriented:
          @#(dd(x,xs),ys) = [1] xs + [1]  
                          > [1] xs + [0]  
                          = c_1(@#(xs,ys))
          
          
          Following rules are (at-least) weakly oriented:
              rev#(dd(x,xs)) =  [1] xs + [1]           
                             >= [1] xs + [0]           
                             =  @#(rev(xs),dd(x,nil()))
          
              rev#(dd(x,xs)) =  [1] xs + [1]           
                             >= [1] xs + [0]           
                             =  rev#(xs)               
          
          shuffle#(dd(x,xs)) =  [1] xs + [8]           
                             >= [1] xs + [0]           
                             =  rev#(xs)               
          
          shuffle#(dd(x,xs)) =  [1] xs + [8]           
                             >= [1] xs + [7]           
                             =  shuffle#(rev(xs))      
          
              @(dd(x,xs),ys) =  [1] xs + [1] ys + [1]  
                             >= [1] xs + [1] ys + [1]  
                             =  dd(x,@(xs,ys))         
          
                 @(nil(),ys) =  [1] ys + [0]           
                             >= [1] ys + [0]           
                             =  ys                     
          
               rev(dd(x,xs)) =  [1] xs + [1]           
                             >= [1] xs + [1]           
                             =  @(rev(xs),dd(x,nil())) 
          
                  rev(nil()) =  [0]                    
                             >= [0]                    
                             =  nil()                  
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 5.b:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
            rev#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> rev#(xs)
            shuffle#(dd(x,xs)) -> shuffle#(rev(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),ys) -> ys
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,shuffle/1,@#/2,rev#/1,shuffle#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/2,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#,shuffle#} and constructors {dd,nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^3))

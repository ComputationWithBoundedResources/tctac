MAYBE
* Step 1: DependencyPairs MAYBE
    + Considered Problem:
        - Strict TRS:
            intlookup(e,p) -> intlookup(lookup(e,p),p)
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
            run(e,p) -> intlookup(e,p)
        - Signature:
            {intlookup/2,lookup/2,run/2} / {Cons/2,Nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup,lookup,run} and constructors {Cons,Nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
          lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
          lookup#(Nil(),Cons(x,xs)) -> c_3()
          run#(e,p) -> c_4(intlookup#(e,p))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
            lookup#(Nil(),Cons(x,xs)) -> c_3()
            run#(e,p) -> c_4(intlookup#(e,p))
        - Weak TRS:
            intlookup(e,p) -> intlookup(lookup(e,p),p)
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
            run(e,p) -> intlookup(e,p)
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {3}
        by application of
          Pre({3}) = {1,2}.
        Here rules are labelled as follows:
          1: intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
          2: lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
          3: lookup#(Nil(),Cons(x,xs)) -> c_3()
          4: run#(e,p) -> c_4(intlookup#(e,p))
* Step 3: RemoveWeakSuffixes MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
            run#(e,p) -> c_4(intlookup#(e,p))
        - Weak DPs:
            lookup#(Nil(),Cons(x,xs)) -> c_3()
        - Weak TRS:
            intlookup(e,p) -> intlookup(lookup(e,p),p)
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
            run(e,p) -> intlookup(e,p)
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
             -->_2 lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs)):2
             -->_2 lookup#(Nil(),Cons(x,xs)) -> c_3():4
             -->_1 intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p)):1
          
          2:S:lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
             -->_1 lookup#(Nil(),Cons(x,xs)) -> c_3():4
             -->_1 lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs)):2
          
          3:S:run#(e,p) -> c_4(intlookup#(e,p))
             -->_1 intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p)):1
          
          4:W:lookup#(Nil(),Cons(x,xs)) -> c_3()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          4: lookup#(Nil(),Cons(x,xs)) -> c_3()
* Step 4: RemoveHeads MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
            run#(e,p) -> c_4(intlookup#(e,p))
        - Weak TRS:
            intlookup(e,p) -> intlookup(lookup(e,p),p)
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
            run(e,p) -> intlookup(e,p)
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
           -->_2 lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs)):2
           -->_1 intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p)):1
        
        2:S:lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
           -->_1 lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs)):2
        
        3:S:run#(e,p) -> c_4(intlookup#(e,p))
           -->_1 intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p)):1
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(3,run#(e,p) -> c_4(intlookup#(e,p)))]
* Step 5: UsableRules MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
        - Weak TRS:
            intlookup(e,p) -> intlookup(lookup(e,p),p)
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
            run(e,p) -> intlookup(e,p)
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
          lookup(Nil(),Cons(x,xs)) -> x
          intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
          lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
* Step 6: DecomposeDG MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
        - Weak TRS:
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
        and a lower component
          lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
        Further, following extension rules are added to the lower component.
          intlookup#(e,p) -> intlookup#(lookup(e,p),p)
          intlookup#(e,p) -> lookup#(e,p)
** Step 6.a:1: SimplifyRHS MAYBE
    + Considered Problem:
        - Strict DPs:
            intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
        - Weak TRS:
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p))
             -->_1 intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p),lookup#(e,p)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p))
** Step 6.a:2: Failure MAYBE
  + Considered Problem:
      - Strict DPs:
          intlookup#(e,p) -> c_1(intlookup#(lookup(e,p),p))
      - Weak TRS:
          lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
          lookup(Nil(),Cons(x,xs)) -> x
      - Signature:
          {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/1,c_2/1,c_3/0,c_4/1}
      - Obligation:
          innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
  + Applied Processor:
      EmptyProcessor
  + Details:
      The problem is still open.
** Step 6.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
        - Weak DPs:
            intlookup#(e,p) -> intlookup#(lookup(e,p),p)
            intlookup#(e,p) -> lookup#(e,p)
        - Weak TRS:
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_2) = {1}
        
        Following symbols are considered usable:
          {intlookup#,lookup#,run#}
        TcT has computed the following interpretation:
                p(Cons) = [1] x1 + [1] x2 + [2]
                 p(Nil) = [1]                  
           p(intlookup) = [0]                  
              p(lookup) = [0]                  
                 p(run) = [0]                  
          p(intlookup#) = [8] x2 + [8]         
             p(lookup#) = [8] x2 + [7]         
                p(run#) = [0]                  
                 p(c_1) = [1]                  
                 p(c_2) = [1] x1 + [5]         
                 p(c_3) = [0]                  
                 p(c_4) = [0]                  
        
        Following rules are strictly oriented:
        lookup#(Cons(x',xs'),Cons(x,xs)) = [8] x + [8] xs + [23]
                                         > [8] xs + [12]        
                                         = c_2(lookup#(xs',xs)) 
        
        
        Following rules are (at-least) weakly oriented:
        intlookup#(e,p) =  [8] p + [8]              
                        >= [8] p + [8]              
                        =  intlookup#(lookup(e,p),p)
        
        intlookup#(e,p) =  [8] p + [8]              
                        >= [8] p + [7]              
                        =  lookup#(e,p)             
        
** Step 6.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            intlookup#(e,p) -> intlookup#(lookup(e,p),p)
            intlookup#(e,p) -> lookup#(e,p)
            lookup#(Cons(x',xs'),Cons(x,xs)) -> c_2(lookup#(xs',xs))
        - Weak TRS:
            lookup(Cons(x',xs'),Cons(x,xs)) -> lookup(xs',xs)
            lookup(Nil(),Cons(x,xs)) -> x
        - Signature:
            {intlookup/2,lookup/2,run/2,intlookup#/2,lookup#/2,run#/2} / {Cons/2,Nil/0,c_1/2,c_2/1,c_3/0,c_4/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {intlookup#,lookup#,run#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

MAYBE

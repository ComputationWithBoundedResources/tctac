WORST_CASE(?,O(n^4))
* Step 1: DependencyPairs WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            c(x) -> mult(x,mult(x,x))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2} / {0/0,s/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add,c,mult} and constructors {0,s}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          add#(0(),y) -> c_1()
          add#(s(x),y) -> c_2(add#(x,y))
          c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          mult#(0(),y) -> c_4()
          mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: UsableRules WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            add#(0(),y) -> c_1()
            add#(s(x),y) -> c_2(add#(x,y))
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(0(),y) -> c_4()
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            c(x) -> mult(x,mult(x,x))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          add(0(),y) -> y
          add(s(x),y) -> s(add(x,y))
          mult(0(),y) -> 0()
          mult(s(x),y) -> add(mult(x,y),y)
          add#(0(),y) -> c_1()
          add#(s(x),y) -> c_2(add#(x,y))
          c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          mult#(0(),y) -> c_4()
          mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
* Step 3: PredecessorEstimation WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            add#(0(),y) -> c_1()
            add#(s(x),y) -> c_2(add#(x,y))
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(0(),y) -> c_4()
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1,4}
        by application of
          Pre({1,4}) = {2,3,5}.
        Here rules are labelled as follows:
          1: add#(0(),y) -> c_1()
          2: add#(s(x),y) -> c_2(add#(x,y))
          3: c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          4: mult#(0(),y) -> c_4()
          5: mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
* Step 4: RemoveWeakSuffixes WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak DPs:
            add#(0(),y) -> c_1()
            mult#(0(),y) -> c_4()
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(0(),y) -> c_1():4
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):1
          
          2:S:c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):3
             -->_1 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):3
             -->_2 mult#(0(),y) -> c_4():5
             -->_1 mult#(0(),y) -> c_4():5
          
          3:S:mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
             -->_2 mult#(0(),y) -> c_4():5
             -->_1 add#(0(),y) -> c_1():4
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):3
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):1
          
          4:W:add#(0(),y) -> c_1()
             
          
          5:W:mult#(0(),y) -> c_4()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          5: mult#(0(),y) -> c_4()
          4: add#(0(),y) -> c_1()
* Step 5: Decompose WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        Decompose {onSelection = all cycle independent sub-graph, withBound = RelativeAdd}
    + Details:
        We analyse the complexity of following sub-problems (R) and (S).
        Problem (S) is obtained from the input problem by shifting strict rules from (R) into the weak component.
        
        Problem (R)
          - Strict DPs:
              add#(s(x),y) -> c_2(add#(x,y))
          - Weak DPs:
              c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
              mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
          - Weak TRS:
              add(0(),y) -> y
              add(s(x),y) -> s(add(x,y))
              mult(0(),y) -> 0()
              mult(s(x),y) -> add(mult(x,y),y)
          - Signature:
              {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
          - Obligation:
              innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
        
        Problem (S)
          - Strict DPs:
              c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
              mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
          - Weak DPs:
              add#(s(x),y) -> c_2(add#(x,y))
          - Weak TRS:
              add(0(),y) -> y
              add(s(x),y) -> s(add(x,y))
              mult(0(),y) -> 0()
              mult(s(x),y) -> add(mult(x,y),y)
          - Signature:
              {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
          - Obligation:
              innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
** Step 5.a:1: DecomposeDG WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Just someStrategy, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        and a lower component
          add#(s(x),y) -> c_2(add#(x,y))
        Further, following extension rules are added to the lower component.
          c#(x) -> mult#(x,x)
          c#(x) -> mult#(x,mult(x,x))
          mult#(s(x),y) -> add#(mult(x,y),y)
          mult#(s(x),y) -> mult#(x,y)
*** Step 5.a:1.a:1: PredecessorEstimationCP WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          1: mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
          
        Consider the set of all dependency pairs
          1: mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
          2: c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
        Processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}induces the complexity certificateTIME (?,O(n^1))
        SPACE(?,?)on application of the dependency pairs
          {1}
        These cover all (indirect) predecessors of dependency pairs
          {1,2}
        their number of applications is equally bounded.
        The dependency pairs are shifted into the weak component.
**** Step 5.a:1.a:1.a:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_3) = {1,2},
          uargs(c_5) = {1,2}
        
        Following symbols are considered usable:
          {add#,c#,mult#}
        TcT has computed the following interpretation:
              p(0) = [1]                  
            p(add) = [1] x2 + [4]         
              p(c) = [0]                  
           p(mult) = [4]                  
              p(s) = [1] x1 + [8]         
           p(add#) = [2]                  
             p(c#) = [12] x1 + [0]        
          p(mult#) = [2] x1 + [0]         
            p(c_1) = [2]                  
            p(c_2) = [1]                  
            p(c_3) = [2] x1 + [4] x2 + [0]
            p(c_4) = [0]                  
            p(c_5) = [2] x1 + [1] x2 + [8]
        
        Following rules are strictly oriented:
        mult#(s(x),y) = [2] x + [16]                     
                      > [2] x + [12]                     
                      = c_5(add#(mult(x,y),y),mult#(x,y))
        
        
        Following rules are (at-least) weakly oriented:
        c#(x) =  [12] x + [0]                      
              >= [12] x + [0]                      
              =  c_3(mult#(x,mult(x,x)),mult#(x,x))
        
**** Step 5.a:1.a:1.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

**** Step 5.a:1.a:1.b:1: RemoveWeakSuffixes WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:W:c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
             -->_1 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
          2:W:mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          1: c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          2: mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
**** Step 5.a:1.a:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 5.a:1.b:1: NaturalPI WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Weak DPs:
            c#(x) -> mult#(x,x)
            c#(x) -> mult#(x,mult(x,x))
            mult#(s(x),y) -> add#(mult(x,y),y)
            mult#(s(x),y) -> mult#(x,y)
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        NaturalPI {shape = Mixed 3, restrict = Restrict, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a polynomial interpretation of kind constructor-based(mixed(3)):
        The following argument positions are considered usable:
          uargs(c_2) = {1}
        
        Following symbols are considered usable:
          {add,mult,add#,c#,mult#}
        TcT has computed the following interpretation:
              p(0) = 0          
            p(add) = x1 + x2    
              p(c) = 0          
           p(mult) = x1*x2      
              p(s) = 1 + x1     
           p(add#) = x1         
             p(c#) = x1^2 + x1^3
          p(mult#) = x1*x2      
            p(c_1) = 0          
            p(c_2) = x1         
            p(c_3) = 0          
            p(c_4) = 0          
            p(c_5) = 0          
        
        Following rules are strictly oriented:
        add#(s(x),y) = 1 + x         
                     > x             
                     = c_2(add#(x,y))
        
        
        Following rules are (at-least) weakly oriented:
                c#(x) =  x^2 + x^3         
                      >= x^2               
                      =  mult#(x,x)        
        
                c#(x) =  x^2 + x^3         
                      >= x^3               
                      =  mult#(x,mult(x,x))
        
        mult#(s(x),y) =  x*y + y           
                      >= x*y               
                      =  add#(mult(x,y),y) 
        
        mult#(s(x),y) =  x*y + y           
                      >= x*y               
                      =  mult#(x,y)        
        
           add(0(),y) =  y                 
                      >= y                 
                      =  y                 
        
          add(s(x),y) =  1 + x + y         
                      >= 1 + x + y         
                      =  s(add(x,y))       
        
          mult(0(),y) =  0                 
                      >= 0                 
                      =  0()               
        
         mult(s(x),y) =  x*y + y           
                      >= x*y + y           
                      =  add(mult(x,y),y)  
        
*** Step 5.a:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            c#(x) -> mult#(x,x)
            c#(x) -> mult#(x,mult(x,x))
            mult#(s(x),y) -> add#(mult(x,y),y)
            mult#(s(x),y) -> mult#(x,y)
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 5.b:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
             -->_1 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
          2:S:mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):3
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
          3:W:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):3
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: add#(s(x),y) -> c_2(add#(x,y))
** Step 5.b:2: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
             -->_1 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
          2:S:mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y))
             -->_2 mult#(s(x),y) -> c_5(add#(mult(x,y),y),mult#(x,y)):2
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          mult#(s(x),y) -> c_5(mult#(x,y))
** Step 5.b:3: PredecessorEstimationCP WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          1: c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          2: mult#(s(x),y) -> c_5(mult#(x,y))
          
        The strictly oriented rules are moved into the weak component.
*** Step 5.b:3.a:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_3) = {1,2},
          uargs(c_5) = {1}
        
        Following symbols are considered usable:
          {add#,c#,mult#}
        TcT has computed the following interpretation:
              p(0) = [8]                  
            p(add) = [3] x1 + [0]         
              p(c) = [1]                  
           p(mult) = [8] x2 + [0]         
              p(s) = [1] x1 + [8]         
           p(add#) = [2]                  
             p(c#) = [10] x1 + [4]        
          p(mult#) = [1] x1 + [0]         
            p(c_1) = [2]                  
            p(c_2) = [2] x1 + [0]         
            p(c_3) = [8] x1 + [1] x2 + [1]
            p(c_4) = [0]                  
            p(c_5) = [1] x1 + [6]         
        
        Following rules are strictly oriented:
                c#(x) = [10] x + [4]                      
                      > [9] x + [1]                       
                      = c_3(mult#(x,mult(x,x)),mult#(x,x))
        
        mult#(s(x),y) = [1] x + [8]                       
                      > [1] x + [6]                       
                      = c_5(mult#(x,y))                   
        
        
        Following rules are (at-least) weakly oriented:
        
*** Step 5.b:3.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

*** Step 5.b:3.b:1: RemoveWeakSuffixes WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
            mult#(s(x),y) -> c_5(mult#(x,y))
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:W:c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
             -->_2 mult#(s(x),y) -> c_5(mult#(x,y)):2
             -->_1 mult#(s(x),y) -> c_5(mult#(x,y)):2
          
          2:W:mult#(s(x),y) -> c_5(mult#(x,y))
             -->_1 mult#(s(x),y) -> c_5(mult#(x,y)):2
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          1: c#(x) -> c_3(mult#(x,mult(x,x)),mult#(x,x))
          2: mult#(s(x),y) -> c_5(mult#(x,y))
*** Step 5.b:3.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak TRS:
            add(0(),y) -> y
            add(s(x),y) -> s(add(x,y))
            mult(0(),y) -> 0()
            mult(s(x),y) -> add(mult(x,y),y)
        - Signature:
            {add/2,c/1,mult/2,add#/2,c#/1,mult#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/2,c_4/0,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,c#,mult#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^4))

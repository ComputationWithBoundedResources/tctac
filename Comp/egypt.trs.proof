WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            div(x,y) -> h(x,y,y)
            egypt(div'(0(),y)) -> nil()
            egypt(div'(s(x),y)) -> app(div(y,s(x)),egypt(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div,egypt,h,i} and constructors {0,app,div',minus,mult
            ,nil,s}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          div#(x,y) -> c_1(h#(x,y,y))
          egypt#(div'(0(),y)) -> c_2()
          egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                     ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                     ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                     ,div#(y,s(x)))
          h#(s(0()),y,z) -> c_4()
          h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
          h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
          i#(div'(x,y),div'(u,v)) -> c_7()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(0(),y)) -> c_2()
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                       ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                       ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                       ,div#(y,s(x)))
            h#(s(0()),y,z) -> c_4()
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
            i#(div'(x,y),div'(u,v)) -> c_7()
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            egypt(div'(0(),y)) -> nil()
            egypt(div'(s(x),y)) -> app(div(y,s(x)),egypt(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/4,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4,7}
        by application of
          Pre({2,4,7}) = {1,3,5,6}.
        Here rules are labelled as follows:
          1: div#(x,y) -> c_1(h#(x,y,y))
          2: egypt#(div'(0(),y)) -> c_2()
          3: egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                        ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                        ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                        ,div#(y,s(x)))
          4: h#(s(0()),y,z) -> c_4()
          5: h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
          6: h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
          7: i#(div'(x,y),div'(u,v)) -> c_7()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                       ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                       ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                       ,div#(y,s(x)))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak DPs:
            egypt#(div'(0(),y)) -> c_2()
            h#(s(0()),y,z) -> c_4()
            i#(div'(x,y),div'(u,v)) -> c_7()
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            egypt(div'(0(),y)) -> nil()
            egypt(div'(s(x),y)) -> app(div(y,s(x)),egypt(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/4,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:div#(x,y) -> c_1(h#(x,y,y))
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
             -->_1 h#(s(0()),y,z) -> c_4():6
          
          2:S:egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                         ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                         ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                         ,div#(y,s(x)))
             -->_3 i#(div'(x,y),div'(u,v)) -> c_7():7
             -->_2 egypt#(div'(0(),y)) -> c_2():5
             -->_2 egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                              ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                              ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                              ,div#(y,s(x))):2
             -->_4 div#(x,y) -> c_1(h#(x,y,y)):1
             -->_1 div#(x,y) -> c_1(h#(x,y,y)):1
          
          3:S:h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(0()),y,z) -> c_4():6
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
          
          4:S:h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
             -->_1 h#(s(0()),y,z) -> c_4():6
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
          
          5:W:egypt#(div'(0(),y)) -> c_2()
             
          
          6:W:h#(s(0()),y,z) -> c_4()
             
          
          7:W:i#(div'(x,y),div'(u,v)) -> c_7()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          5: egypt#(div'(0(),y)) -> c_2()
          7: i#(div'(x,y),div'(u,v)) -> c_7()
          6: h#(s(0()),y,z) -> c_4()
* Step 4: SimplifyRHS WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                       ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                       ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                       ,div#(y,s(x)))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            egypt(div'(0(),y)) -> nil()
            egypt(div'(s(x),y)) -> app(div(y,s(x)),egypt(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/4,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:div#(x,y) -> c_1(h#(x,y,y))
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
          
          2:S:egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                         ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                         ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                         ,div#(y,s(x)))
             -->_2 egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                              ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                              ,i#(div'(s(x),y),div'(s(0()),div(y,s(x))))
                                              ,div#(y,s(x))):2
             -->_4 div#(x,y) -> c_1(h#(x,y,y)):1
             -->_1 div#(x,y) -> c_1(h#(x,y,y)):1
          
          3:S:h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
          
          4:S:h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
             -->_1 h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z)):4
             -->_1 h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z)):3
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
* Step 5: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            egypt(div'(0(),y)) -> nil()
            egypt(div'(s(x),y)) -> app(div(y,s(x)),egypt(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          div(x,y) -> h(x,y,y)
          h(s(0()),y,z) -> s(0())
          h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
          h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
          i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
          div#(x,y) -> c_1(h#(x,y,y))
          egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
          h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
          h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
* Step 6: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
        and a lower component
          div#(x,y) -> c_1(h#(x,y,y))
          h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
          h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        Further, following extension rules are added to the lower component.
          egypt#(div'(s(x),y)) -> div#(y,s(x))
          egypt#(div'(s(x),y)) -> egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            egypt#(div'(s(x),y)) -> c_3(div#(y,s(x)),egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))),div#(y,s(x)))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                         ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                         ,div#(y,s(x)))
             -->_2 egypt#(div'(s(x),y)) -> c_3(div#(y,s(x))
                                              ,egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
                                              ,div#(y,s(x))):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          egypt#(div'(s(x),y)) -> c_3(egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
** Step 6.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            egypt#(div'(s(x),y)) -> c_3(egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_3) = {1}
        
        Following symbols are considered usable:
          {i,div#,egypt#,h#,i#}
        TcT has computed the following interpretation:
               p(0) = [0]                   
             p(app) = [1] x2 + [0]          
             p(div) = [9]                   
            p(div') = [1] x1 + [1]          
           p(egypt) = [2] x1 + [0]          
               p(h) = [5] x2 + [11] x3 + [0]
               p(i) = [1]                   
           p(minus) = [0]                   
            p(mult) = [1]                   
             p(nil) = [2]                   
               p(s) = [2]                   
            p(div#) = [2] x1 + [4] x2 + [1] 
          p(egypt#) = [5] x1 + [3]          
              p(h#) = [8] x1 + [4] x2 + [1] 
              p(i#) = [1]                   
             p(c_1) = [0]                   
             p(c_2) = [0]                   
             p(c_3) = [2] x1 + [0]          
             p(c_4) = [0]                   
             p(c_5) = [0]                   
             p(c_6) = [2]                   
             p(c_7) = [0]                   
        
        Following rules are strictly oriented:
        egypt#(div'(s(x),y)) = [18]                                                 
                             > [16]                                                 
                             = c_3(egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
        
        
        Following rules are (at-least) weakly oriented:
        i(div'(x,y),div'(u,v)) =  [1]                                       
                               >= [1]                                       
                               =  div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        
** Step 6.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            egypt#(div'(s(x),y)) -> c_3(egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x))))))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak DPs:
            egypt#(div'(s(x),y)) -> div#(y,s(x))
            egypt#(div'(s(x),y)) -> egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_5) = {1},
          uargs(c_6) = {1}
        
        Following symbols are considered usable:
          {div#,egypt#,h#,i#}
        TcT has computed the following interpretation:
               p(0) = [2]                  
             p(app) = [1] x1 + [1] x2 + [0]
             p(div) = [0]                  
            p(div') = [1] x1 + [7]         
           p(egypt) = [0]                  
               p(h) = [2] x1 + [0]         
               p(i) = [0]                  
           p(minus) = [1] x1 + [1] x2 + [0]
            p(mult) = [1] x1 + [0]         
             p(nil) = [0]                  
               p(s) = [1] x1 + [0]         
            p(div#) = [4]                  
          p(egypt#) = [4]                  
              p(h#) = [0]                  
              p(i#) = [0]                  
             p(c_1) = [1] x1 + [0]         
             p(c_2) = [0]                  
             p(c_3) = [0]                  
             p(c_4) = [0]                  
             p(c_5) = [1] x1 + [0]         
             p(c_6) = [4] x1 + [0]         
             p(c_7) = [0]                  
        
        Following rules are strictly oriented:
        div#(x,y) = [4]           
                  > [0]           
                  = c_1(h#(x,y,y))
        
        
        Following rules are (at-least) weakly oriented:
         egypt#(div'(s(x),y)) =  [4]                                             
                              >= [4]                                             
                              =  div#(y,s(x))                                    
        
         egypt#(div'(s(x),y)) =  [4]                                             
                              >= [4]                                             
                              =  egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
        
         h#(s(s(x)),s(0()),z) =  [0]                                             
                              >= [0]                                             
                              =  c_5(h#(s(x),z,z))                               
        
        h#(s(s(x)),s(s(y)),z) =  [0]                                             
                              >= [0]                                             
                              =  c_6(h#(s(x),s(y),z))                            
        
** Step 6.b:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> div#(y,s(x))
            egypt#(div'(s(x),y)) -> egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(div') = {2},
            uargs(i) = {2},
            uargs(s) = {1},
            uargs(egypt#) = {1},
            uargs(c_1) = {1},
            uargs(c_5) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(0) = [6]                  
               p(app) = [2]                  
               p(div) = [1] x1 + [0]         
              p(div') = [1] x2 + [0]         
             p(egypt) = [0]                  
                 p(h) = [1] x1 + [0]         
                 p(i) = [1] x2 + [0]         
             p(minus) = [1] x2 + [2]         
              p(mult) = [0]                  
               p(nil) = [1]                  
                 p(s) = [1] x1 + [1]         
              p(div#) = [1] x1 + [0]         
            p(egypt#) = [1] x1 + [0]         
                p(h#) = [1] x1 + [0]         
                p(i#) = [1] x1 + [2] x2 + [0]
               p(c_1) = [1] x1 + [0]         
               p(c_2) = [0]                  
               p(c_3) = [0]                  
               p(c_4) = [0]                  
               p(c_5) = [1] x1 + [0]         
               p(c_6) = [1] x1 + [0]         
               p(c_7) = [0]                  
          
          Following rules are strictly oriented:
           h#(s(s(x)),s(0()),z) = [1] x + [2]         
                                > [1] x + [1]         
                                = c_5(h#(s(x),z,z))   
          
          h#(s(s(x)),s(s(y)),z) = [1] x + [2]         
                                > [1] x + [1]         
                                = c_6(h#(s(x),s(y),z))
          
          
          Following rules are (at-least) weakly oriented:
                       div#(x,y) =  [1] x + [0]                                     
                                 >= [1] x + [0]                                     
                                 =  c_1(h#(x,y,y))                                  
          
            egypt#(div'(s(x),y)) =  [1] y + [0]                                     
                                 >= [1] y + [0]                                     
                                 =  div#(y,s(x))                                    
          
            egypt#(div'(s(x),y)) =  [1] y + [0]                                     
                                 >= [1] y + [0]                                     
                                 =  egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
          
                        div(x,y) =  [1] x + [0]                                     
                                 >= [1] x + [0]                                     
                                 =  h(x,y,y)                                        
          
                   h(s(0()),y,z) =  [7]                                             
                                 >= [7]                                             
                                 =  s(0())                                          
          
             h(s(s(x)),s(0()),z) =  [1] x + [2]                                     
                                 >= [1] x + [2]                                     
                                 =  s(h(s(x),z,z))                                  
          
            h(s(s(x)),s(s(y)),z) =  [1] x + [2]                                     
                                 >= [1] x + [1]                                     
                                 =  h(s(x),s(y),z)                                  
          
          i(div'(x,y),div'(u,v)) =  [1] v + [0]                                     
                                 >= [0]                                             
                                 =  div'(minus(mult(x,v),mult(y,u)),mult(y,v))      
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 6.b:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            div#(x,y) -> c_1(h#(x,y,y))
            egypt#(div'(s(x),y)) -> div#(y,s(x))
            egypt#(div'(s(x),y)) -> egypt#(i(div'(s(x),y),div'(s(0()),div(y,s(x)))))
            h#(s(s(x)),s(0()),z) -> c_5(h#(s(x),z,z))
            h#(s(s(x)),s(s(y)),z) -> c_6(h#(s(x),s(y),z))
        - Weak TRS:
            div(x,y) -> h(x,y,y)
            h(s(0()),y,z) -> s(0())
            h(s(s(x)),s(0()),z) -> s(h(s(x),z,z))
            h(s(s(x)),s(s(y)),z) -> h(s(x),s(y),z)
            i(div'(x,y),div'(u,v)) -> div'(minus(mult(x,v),mult(y,u)),mult(y,v))
        - Signature:
            {div/2,egypt/1,h/3,i/2,div#/2,egypt#/1,h#/3,i#/2} / {0/0,app/2,div'/2,minus/2,mult/2,nil/0,s/1,c_1/1,c_2/0
            ,c_3/3,c_4/0,c_5/1,c_6/1,c_7/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {div#,egypt#,h#,i#} and constructors {0,app,div',minus
            ,mult,nil,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

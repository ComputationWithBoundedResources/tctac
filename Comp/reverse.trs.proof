WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1} / {dd/2,nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@,rev} and constructors {dd,nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          @#(nil(),xs) -> c_2()
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          rev#(nil()) -> c_4()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            @#(nil(),xs) -> c_2()
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
            rev#(nil()) -> c_4()
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4}
        by application of
          Pre({2,4}) = {1,3}.
        Here rules are labelled as follows:
          1: @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
          2: @#(nil(),xs) -> c_2()
          3: rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
          4: rev#(nil()) -> c_4()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        - Weak DPs:
            @#(nil(),xs) -> c_2()
            rev#(nil()) -> c_4()
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:@#(dd(x,xs),ys) -> c_1(@#(xs,ys))
             -->_1 @#(nil(),xs) -> c_2():3
             -->_1 @#(dd(x,xs),ys) -> c_1(@#(xs,ys)):1
          
          2:S:rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
             -->_2 rev#(nil()) -> c_4():4
             -->_1 @#(nil(),xs) -> c_2():3
             -->_2 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):2
             -->_1 @#(dd(x,xs),ys) -> c_1(@#(xs,ys)):1
          
          3:W:@#(nil(),xs) -> c_2()
             
          
          4:W:rev#(nil()) -> c_4()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          4: rev#(nil()) -> c_4()
          3: @#(nil(),xs) -> c_2()
* Step 4: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        and a lower component
          @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
        Further, following extension rules are added to the lower component.
          rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
          rev#(dd(x,xs)) -> rev#(xs)
** Step 4.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs))
             -->_2 rev#(dd(x,xs)) -> c_3(@#(rev(xs),dd(x,nil())),rev#(xs)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          rev#(dd(x,xs)) -> c_3(rev#(xs))
** Step 4.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#(dd(x,xs)) -> c_3(rev#(xs))
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/1,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          rev#(dd(x,xs)) -> c_3(rev#(xs))
** Step 4.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#(dd(x,xs)) -> c_3(rev#(xs))
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/1,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(c_3) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(@) = [0]                  
              p(dd) = [1] x1 + [1] x2 + [1]
             p(nil) = [0]                  
             p(rev) = [0]                  
              p(@#) = [0]                  
            p(rev#) = [1] x1 + [0]         
             p(c_1) = [0]                  
             p(c_2) = [0]                  
             p(c_3) = [1] x1 + [0]         
             p(c_4) = [0]                  
          
          Following rules are strictly oriented:
          rev#(dd(x,xs)) = [1] x + [1] xs + [1]
                         > [1] xs + [0]        
                         = c_3(rev#(xs))       
          
          
          Following rules are (at-least) weakly oriented:
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            rev#(dd(x,xs)) -> c_3(rev#(xs))
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/1,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 4.b:1: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
        - Weak DPs:
            rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
            rev#(dd(x,xs)) -> rev#(xs)
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(@) = {1},
            uargs(dd) = {2},
            uargs(@#) = {1},
            uargs(c_1) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(@) = [1] x1 + [8] x2 + [0]
              p(dd) = [1] x1 + [1] x2 + [2]
             p(nil) = [0]                  
             p(rev) = [8] x1 + [7]         
              p(@#) = [1] x1 + [1] x2 + [7]
            p(rev#) = [8] x1 + [0]         
             p(c_1) = [1] x1 + [1]         
             p(c_2) = [0]                  
             p(c_3) = [2] x2 + [0]         
             p(c_4) = [0]                  
          
          Following rules are strictly oriented:
          @#(dd(x,xs),ys) = [1] x + [1] xs + [1] ys + [9]
                          > [1] xs + [1] ys + [8]        
                          = c_1(@#(xs,ys))               
          
          
          Following rules are (at-least) weakly oriented:
          rev#(dd(x,xs)) =  [8] x + [8] xs + [16]        
                         >= [1] x + [8] xs + [16]        
                         =  @#(rev(xs),dd(x,nil()))      
          
          rev#(dd(x,xs)) =  [8] x + [8] xs + [16]        
                         >= [8] xs + [0]                 
                         =  rev#(xs)                     
          
          @(dd(x,xs),ys) =  [1] x + [1] xs + [8] ys + [2]
                         >= [1] x + [1] xs + [8] ys + [2]
                         =  dd(x,@(xs,ys))               
          
             @(nil(),xs) =  [8] xs + [0]                 
                         >= [1] xs + [0]                 
                         =  xs                           
          
           rev(dd(x,xs)) =  [8] x + [8] xs + [23]        
                         >= [8] x + [8] xs + [23]        
                         =  @(rev(xs),dd(x,nil()))       
          
              rev(nil()) =  [7]                          
                         >= [0]                          
                         =  nil()                        
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            @#(dd(x,xs),ys) -> c_1(@#(xs,ys))
            rev#(dd(x,xs)) -> @#(rev(xs),dd(x,nil()))
            rev#(dd(x,xs)) -> rev#(xs)
        - Weak TRS:
            @(dd(x,xs),ys) -> dd(x,@(xs,ys))
            @(nil(),xs) -> xs
            rev(dd(x,xs)) -> @(rev(xs),dd(x,nil()))
            rev(nil()) -> nil()
        - Signature:
            {@/2,rev/1,@#/2,rev#/1} / {dd/2,nil/0,c_1/1,c_2/0,c_3/2,c_4/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {@#,rev#} and constructors {dd,nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

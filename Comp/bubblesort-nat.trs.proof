WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2} / {0/0,dd/2,false/0,nil/0,pair/2
            ,s/1,true/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append,bubble,bubble',bubble'',bubblesort,bubblesort'
            ,lt} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
          append#(nil(),ys) -> c_2()
          bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
          bubble#(dd(x,nil())) -> c_4()
          bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
          bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
          bubble''#(x,pair(xs,x')) -> c_7()
          bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
          bubblesort#(nil()) -> c_9()
          bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
          lt#(0(),0()) -> c_11()
          lt#(0(),s(y)) -> c_12()
          lt#(s(x),0()) -> c_13()
          lt#(s(x),s(y)) -> c_14(lt#(x,y))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            append#(nil(),ys) -> c_2()
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble#(dd(x,nil())) -> c_4()
            bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
            bubble''#(x,pair(xs,x')) -> c_7()
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubblesort#(nil()) -> c_9()
            bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
            lt#(0(),0()) -> c_11()
            lt#(0(),s(y)) -> c_12()
            lt#(s(x),0()) -> c_13()
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/2,c_6/2,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4,7,9,11,12,13}
        by application of
          Pre({2,4,7,9,11,12,13}) = {1,3,5,6,8,10,14}.
        Here rules are labelled as follows:
          1: append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
          2: append#(nil(),ys) -> c_2()
          3: bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
          4: bubble#(dd(x,nil())) -> c_4()
          5: bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
          6: bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
          7: bubble''#(x,pair(xs,x')) -> c_7()
          8: bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
          9: bubblesort#(nil()) -> c_9()
          10: bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
          11: lt#(0(),0()) -> c_11()
          12: lt#(0(),s(y)) -> c_12()
          13: lt#(s(x),0()) -> c_13()
          14: lt#(s(x),s(y)) -> c_14(lt#(x,y))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak DPs:
            append#(nil(),ys) -> c_2()
            bubble#(dd(x,nil())) -> c_4()
            bubble''#(x,pair(xs,x')) -> c_7()
            bubblesort#(nil()) -> c_9()
            lt#(0(),0()) -> c_11()
            lt#(0(),s(y)) -> c_12()
            lt#(s(x),0()) -> c_13()
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/2,c_6/2,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
             -->_1 append#(nil(),ys) -> c_2():8
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          2:S:bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
             -->_2 lt#(s(x),s(y)) -> c_14(lt#(x,y)):7
             -->_1 bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs))):4
             -->_1 bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs))):3
             -->_2 lt#(s(x),0()) -> c_13():14
             -->_2 lt#(0(),s(y)) -> c_12():13
             -->_2 lt#(0(),0()) -> c_11():12
          
          3:S:bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
             -->_1 bubble''#(x,pair(xs,x')) -> c_7():10
             -->_2 bubble#(dd(x,nil())) -> c_4():9
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          4:S:bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
             -->_1 bubble''#(x,pair(xs,x')) -> c_7():10
             -->_2 bubble#(dd(x,nil())) -> c_4():9
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          5:S:bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
             -->_1 bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs)):6
             -->_2 bubble#(dd(x,nil())) -> c_4():9
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          6:S:bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
             -->_2 bubblesort#(nil()) -> c_9():11
             -->_1 append#(nil(),ys) -> c_2():8
             -->_2 bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs))):5
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          7:S:lt#(s(x),s(y)) -> c_14(lt#(x,y))
             -->_1 lt#(s(x),0()) -> c_13():14
             -->_1 lt#(0(),s(y)) -> c_12():13
             -->_1 lt#(0(),0()) -> c_11():12
             -->_1 lt#(s(x),s(y)) -> c_14(lt#(x,y)):7
          
          8:W:append#(nil(),ys) -> c_2()
             
          
          9:W:bubble#(dd(x,nil())) -> c_4()
             
          
          10:W:bubble''#(x,pair(xs,x')) -> c_7()
             
          
          11:W:bubblesort#(nil()) -> c_9()
             
          
          12:W:lt#(0(),0()) -> c_11()
             
          
          13:W:lt#(0(),s(y)) -> c_12()
             
          
          14:W:lt#(s(x),0()) -> c_13()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          11: bubblesort#(nil()) -> c_9()
          9: bubble#(dd(x,nil())) -> c_4()
          10: bubble''#(x,pair(xs,x')) -> c_7()
          12: lt#(0(),0()) -> c_11()
          13: lt#(0(),s(y)) -> c_12()
          14: lt#(s(x),0()) -> c_13()
          8: append#(nil(),ys) -> c_2()
* Step 4: SimplifyRHS WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/2,c_6/2,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          2:S:bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
             -->_2 lt#(s(x),s(y)) -> c_14(lt#(x,y)):7
             -->_1 bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs))):4
             -->_1 bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs))):3
          
          3:S:bubble'#(false(),x,x',xs) -> c_5(bubble''#(x',bubble(dd(x,xs))),bubble#(dd(x,xs)))
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          4:S:bubble'#(true(),x,x',xs) -> c_6(bubble''#(x,bubble(dd(x',xs))),bubble#(dd(x',xs)))
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          5:S:bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
             -->_1 bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs)):6
             -->_2 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          6:S:bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
             -->_2 bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs))):5
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          7:S:lt#(s(x),s(y)) -> c_14(lt#(x,y))
             -->_1 lt#(s(x),s(y)) -> c_14(lt#(x,y)):7
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
          bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
* Step 5: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
          bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
        and a lower component
          append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
          bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
          bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
          bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
          lt#(s(x),s(y)) -> c_14(lt#(x,y))
        Further, following extension rules are added to the lower component.
          bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
          bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
          bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
          bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
** Step 5.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs)))
             -->_1 bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs)):2
          
          2:S:bubblesort'#(pair(xs,x)) -> c_10(append#(bubblesort(xs),dd(x,nil())),bubblesort#(xs))
             -->_2 bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))),bubble#(dd(x,xs))):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
          bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
** Step 5.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
            bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/1,c_9/0,c_10/1,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
          bubble(dd(x,nil())) -> pair(nil(),x)
          bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
          bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
          bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
          lt(0(),0()) -> false()
          lt(0(),s(y)) -> true()
          lt(s(x),0()) -> false()
          lt(s(x),s(y)) -> lt(x,y)
          bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
          bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
** Step 5.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
            bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
        - Weak TRS:
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/1,c_9/0,c_10/1,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(bubble') = {1},
            uargs(bubble'') = {2},
            uargs(bubblesort'#) = {1},
            uargs(c_8) = {1},
            uargs(c_10) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                       p(0) = [0]                           
                  p(append) = [0]                           
                  p(bubble) = [2]                           
                 p(bubble') = [1] x1 + [0]                  
                p(bubble'') = [1] x2 + [0]                  
              p(bubblesort) = [0]                           
             p(bubblesort') = [0]                           
                      p(dd) = [1] x2 + [0]                  
                   p(false) = [2]                           
                      p(lt) = [2]                           
                     p(nil) = [0]                           
                    p(pair) = [1]                           
                       p(s) = [0]                           
                    p(true) = [2]                           
                 p(append#) = [0]                           
                 p(bubble#) = [0]                           
                p(bubble'#) = [2] x2 + [1] x3 + [2] x4 + [0]
               p(bubble''#) = [0]                           
             p(bubblesort#) = [0]                           
            p(bubblesort'#) = [1] x1 + [0]                  
                     p(lt#) = [2] x1 + [2]                  
                     p(c_1) = [1] x1 + [0]                  
                     p(c_2) = [1]                           
                     p(c_3) = [4] x1 + [4]                  
                     p(c_4) = [1]                           
                     p(c_5) = [1] x1 + [0]                  
                     p(c_6) = [1] x1 + [0]                  
                     p(c_7) = [2]                           
                     p(c_8) = [1] x1 + [1]                  
                     p(c_9) = [0]                           
                    p(c_10) = [1] x1 + [0]                  
                    p(c_11) = [1]                           
                    p(c_12) = [0]                           
                    p(c_13) = [1]                           
                    p(c_14) = [4] x1 + [0]                  
          
          Following rules are strictly oriented:
          bubblesort'#(pair(xs,x)) = [1]                  
                                   > [0]                  
                                   = c_10(bubblesort#(xs))
          
          
          Following rules are (at-least) weakly oriented:
             bubblesort#(dd(x,xs)) =  [0]                                
                                   >= [3]                                
                                   =  c_8(bubblesort'#(bubble(dd(x,xs))))
          
           bubble(dd(x,dd(x',xs))) =  [2]                                
                                   >= [2]                                
                                   =  bubble'(lt(x,x'),x,x',xs)          
          
               bubble(dd(x,nil())) =  [2]                                
                                   >= [1]                                
                                   =  pair(nil(),x)                      
          
          bubble'(false(),x,x',xs) =  [2]                                
                                   >= [2]                                
                                   =  bubble''(x',bubble(dd(x,xs)))      
          
           bubble'(true(),x,x',xs) =  [2]                                
                                   >= [2]                                
                                   =  bubble''(x,bubble(dd(x',xs)))      
          
           bubble''(x,pair(xs,x')) =  [1]                                
                                   >= [1]                                
                                   =  pair(dd(x,xs),x')                  
          
                       lt(0(),0()) =  [2]                                
                                   >= [2]                                
                                   =  false()                            
          
                      lt(0(),s(y)) =  [2]                                
                                   >= [2]                                
                                   =  true()                             
          
                      lt(s(x),0()) =  [2]                                
                                   >= [2]                                
                                   =  false()                            
          
                     lt(s(x),s(y)) =  [2]                                
                                   >= [2]                                
                                   =  lt(x,y)                            
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 5.a:4: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
        - Weak DPs:
            bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
        - Weak TRS:
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/1,c_9/0,c_10/1,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(bubble') = {1},
            uargs(bubble'') = {2},
            uargs(bubblesort'#) = {1},
            uargs(c_8) = {1},
            uargs(c_10) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                       p(0) = [2]                  
                  p(append) = [1] x1 + [1] x2 + [0]
                  p(bubble) = [1] x1 + [1]         
                 p(bubble') = [1] x1 + [1] x4 + [4]
                p(bubble'') = [1] x2 + [4]         
              p(bubblesort) = [1] x1 + [4]         
             p(bubblesort') = [2] x1 + [1]         
                      p(dd) = [1] x2 + [4]         
                   p(false) = [5]                  
                      p(lt) = [5]                  
                     p(nil) = [2]                  
                    p(pair) = [1] x1 + [2]         
                       p(s) = [0]                  
                    p(true) = [5]                  
                 p(append#) = [2] x1 + [2] x2 + [0]
                 p(bubble#) = [0]                  
                p(bubble'#) = [4] x3 + [2] x4 + [4]
               p(bubble''#) = [4] x1 + [0]         
             p(bubblesort#) = [1] x1 + [2]         
            p(bubblesort'#) = [1] x1 + [0]         
                     p(lt#) = [1] x1 + [1] x2 + [1]
                     p(c_1) = [1] x1 + [0]         
                     p(c_2) = [1]                  
                     p(c_3) = [2] x2 + [0]         
                     p(c_4) = [0]                  
                     p(c_5) = [1] x1 + [0]         
                     p(c_6) = [1]                  
                     p(c_7) = [0]                  
                     p(c_8) = [1] x1 + [0]         
                     p(c_9) = [0]                  
                    p(c_10) = [1] x1 + [0]         
                    p(c_11) = [1]                  
                    p(c_12) = [0]                  
                    p(c_13) = [1]                  
                    p(c_14) = [2]                  
          
          Following rules are strictly oriented:
          bubblesort#(dd(x,xs)) = [1] xs + [6]                       
                                > [1] xs + [5]                       
                                = c_8(bubblesort'#(bubble(dd(x,xs))))
          
          
          Following rules are (at-least) weakly oriented:
          bubblesort'#(pair(xs,x)) =  [1] xs + [2]                 
                                   >= [1] xs + [2]                 
                                   =  c_10(bubblesort#(xs))        
          
           bubble(dd(x,dd(x',xs))) =  [1] xs + [9]                 
                                   >= [1] xs + [9]                 
                                   =  bubble'(lt(x,x'),x,x',xs)    
          
               bubble(dd(x,nil())) =  [7]                          
                                   >= [4]                          
                                   =  pair(nil(),x)                
          
          bubble'(false(),x,x',xs) =  [1] xs + [9]                 
                                   >= [1] xs + [9]                 
                                   =  bubble''(x',bubble(dd(x,xs)))
          
           bubble'(true(),x,x',xs) =  [1] xs + [9]                 
                                   >= [1] xs + [9]                 
                                   =  bubble''(x,bubble(dd(x',xs)))
          
           bubble''(x,pair(xs,x')) =  [1] xs + [6]                 
                                   >= [1] xs + [6]                 
                                   =  pair(dd(x,xs),x')            
          
                       lt(0(),0()) =  [5]                          
                                   >= [5]                          
                                   =  false()                      
          
                      lt(0(),s(y)) =  [5]                          
                                   >= [5]                          
                                   =  true()                       
          
                      lt(s(x),0()) =  [5]                          
                                   >= [5]                          
                                   =  false()                      
          
                     lt(s(x),s(y)) =  [5]                          
                                   >= [5]                          
                                   =  lt(x,y)                      
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 5.a:5: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            bubblesort#(dd(x,xs)) -> c_8(bubblesort'#(bubble(dd(x,xs))))
            bubblesort'#(pair(xs,x)) -> c_10(bubblesort#(xs))
        - Weak TRS:
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/1,c_9/0,c_10/1,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 5.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak DPs:
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
          bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
          bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
          bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
          bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
          bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
          bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
          bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        and a lower component
          lt#(s(x),s(y)) -> c_14(lt#(x,y))
        Further, following extension rules are added to the lower component.
          append#(dd(x,xs),ys) -> append#(xs,ys)
          bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
          bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
          bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
          bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
          bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
          bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
          bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
          bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
*** Step 5.b:1.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
        - Weak DPs:
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          2:S:bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x'))
             -->_1 bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs))):4
             -->_1 bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs))):3
          
          3:S:bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
             -->_1 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          4:S:bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
             -->_1 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          5:W:bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
             -->_1 bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs),lt#(x,x')):2
          
          6:W:bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
             -->_1 bubblesort'#(pair(xs,x)) -> bubblesort#(xs):8
             -->_1 bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil())):7
          
          7:W:bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
             -->_1 append#(dd(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          8:W:bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
             -->_1 bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs))):6
             -->_1 bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs)):5
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
*** Step 5.b:1.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
        - Weak DPs:
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_3) = {1},
          uargs(c_5) = {1},
          uargs(c_6) = {1}
        
        Following symbols are considered usable:
          {bubble,bubble',bubble'',append#,bubble#,bubble'#,bubble''#,bubblesort#,bubblesort'#,lt#}
        TcT has computed the following interpretation:
                     p(0) = [0]                           
                p(append) = [3] x1 + [0]                  
                p(bubble) = [1] x1 + [0]                  
               p(bubble') = [1] x2 + [1] x3 + [1] x4 + [2]
              p(bubble'') = [1] x1 + [1] x2 + [1]         
            p(bubblesort) = [3]                           
           p(bubblesort') = [0]                           
                    p(dd) = [1] x1 + [1] x2 + [1]         
                 p(false) = [0]                           
                    p(lt) = [0]                           
                   p(nil) = [0]                           
                  p(pair) = [1] x1 + [0]                  
                     p(s) = [0]                           
                  p(true) = [0]                           
               p(append#) = [4]                           
               p(bubble#) = [4] x1 + [0]                  
              p(bubble'#) = [4] x2 + [4] x3 + [4] x4 + [4]
             p(bubble''#) = [1] x1 + [2]                  
           p(bubblesort#) = [4] x1 + [5]                  
          p(bubblesort'#) = [4] x1 + [5]                  
                   p(lt#) = [1] x1 + [1] x2 + [4]         
                   p(c_1) = [1] x1 + [0]                  
                   p(c_2) = [1]                           
                   p(c_3) = [1] x1 + [0]                  
                   p(c_4) = [0]                           
                   p(c_5) = [1] x1 + [0]                  
                   p(c_6) = [1] x1 + [0]                  
                   p(c_7) = [4]                           
                   p(c_8) = [1] x1 + [2] x2 + [0]         
                   p(c_9) = [0]                           
                  p(c_10) = [0]                           
                  p(c_11) = [0]                           
                  p(c_12) = [0]                           
                  p(c_13) = [1]                           
                  p(c_14) = [1] x1 + [0]                  
        
        Following rules are strictly oriented:
        bubble#(dd(x,dd(x',xs))) = [4] x + [4] x' + [4] xs + [8]  
                                 > [4] x + [4] x' + [4] xs + [4]  
                                 = c_3(bubble'#(lt(x,x'),x,x',xs))
        
        
        Following rules are (at-least) weakly oriented:
             append#(dd(x,xs),ys) =  [4]                                
                                  >= [4]                                
                                  =  c_1(append#(xs,ys))                
        
        bubble'#(false(),x,x',xs) =  [4] x + [4] x' + [4] xs + [4]      
                                  >= [4] x + [4] xs + [4]               
                                  =  c_5(bubble#(dd(x,xs)))             
        
         bubble'#(true(),x,x',xs) =  [4] x + [4] x' + [4] xs + [4]      
                                  >= [4] x' + [4] xs + [4]              
                                  =  c_6(bubble#(dd(x',xs)))            
        
            bubblesort#(dd(x,xs)) =  [4] x + [4] xs + [9]               
                                  >= [4] x + [4] xs + [4]               
                                  =  bubble#(dd(x,xs))                  
        
            bubblesort#(dd(x,xs)) =  [4] x + [4] xs + [9]               
                                  >= [4] x + [4] xs + [9]               
                                  =  bubblesort'#(bubble(dd(x,xs)))     
        
         bubblesort'#(pair(xs,x)) =  [4] xs + [5]                       
                                  >= [4]                                
                                  =  append#(bubblesort(xs),dd(x,nil()))
        
         bubblesort'#(pair(xs,x)) =  [4] xs + [5]                       
                                  >= [4] xs + [5]                       
                                  =  bubblesort#(xs)                    
        
          bubble(dd(x,dd(x',xs))) =  [1] x + [1] x' + [1] xs + [2]      
                                  >= [1] x + [1] x' + [1] xs + [2]      
                                  =  bubble'(lt(x,x'),x,x',xs)          
        
              bubble(dd(x,nil())) =  [1] x + [1]                        
                                  >= [0]                                
                                  =  pair(nil(),x)                      
        
         bubble'(false(),x,x',xs) =  [1] x + [1] x' + [1] xs + [2]      
                                  >= [1] x + [1] x' + [1] xs + [2]      
                                  =  bubble''(x',bubble(dd(x,xs)))      
        
          bubble'(true(),x,x',xs) =  [1] x + [1] x' + [1] xs + [2]      
                                  >= [1] x + [1] x' + [1] xs + [2]      
                                  =  bubble''(x,bubble(dd(x',xs)))      
        
          bubble''(x,pair(xs,x')) =  [1] x + [1] xs + [1]               
                                  >= [1] x + [1] xs + [1]               
                                  =  pair(dd(x,xs),x')                  
        
*** Step 5.b:1.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
        - Weak DPs:
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(append) = {1},
            uargs(bubble') = {1},
            uargs(bubble'') = {2},
            uargs(bubblesort') = {1},
            uargs(dd) = {2},
            uargs(append#) = {1},
            uargs(bubble'#) = {1},
            uargs(bubblesort'#) = {1},
            uargs(c_1) = {1},
            uargs(c_3) = {1},
            uargs(c_5) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                       p(0) = [0]                  
                  p(append) = [1] x1 + [1] x2 + [0]
                  p(bubble) = [1] x1 + [0]         
                 p(bubble') = [1] x1 + [1] x4 + [2]
                p(bubble'') = [1] x2 + [1]         
              p(bubblesort) = [1] x1 + [0]         
             p(bubblesort') = [1] x1 + [0]         
                      p(dd) = [1] x2 + [1]         
                   p(false) = [0]                  
                      p(lt) = [0]                  
                     p(nil) = [0]                  
                    p(pair) = [1] x1 + [1]         
                       p(s) = [0]                  
                    p(true) = [0]                  
                 p(append#) = [1] x1 + [0]         
                 p(bubble#) = [0]                  
                p(bubble'#) = [1] x1 + [0]         
               p(bubble''#) = [4]                  
             p(bubblesort#) = [1] x1 + [5]         
            p(bubblesort'#) = [1] x1 + [4]         
                     p(lt#) = [4] x1 + [0]         
                     p(c_1) = [1] x1 + [0]         
                     p(c_2) = [0]                  
                     p(c_3) = [1] x1 + [0]         
                     p(c_4) = [1]                  
                     p(c_5) = [1] x1 + [7]         
                     p(c_6) = [1] x1 + [1]         
                     p(c_7) = [2]                  
                     p(c_8) = [2] x1 + [1] x2 + [0]
                     p(c_9) = [1]                  
                    p(c_10) = [1] x2 + [1]         
                    p(c_11) = [0]                  
                    p(c_12) = [2]                  
                    p(c_13) = [0]                  
                    p(c_14) = [0]                  
          
          Following rules are strictly oriented:
          append#(dd(x,xs),ys) = [1] xs + [1]       
                               > [1] xs + [0]       
                               = c_1(append#(xs,ys))
          
          
          Following rules are (at-least) weakly oriented:
           bubble#(dd(x,dd(x',xs))) =  [0]                                
                                    >= [0]                                
                                    =  c_3(bubble'#(lt(x,x'),x,x',xs))    
          
          bubble'#(false(),x,x',xs) =  [0]                                
                                    >= [7]                                
                                    =  c_5(bubble#(dd(x,xs)))             
          
           bubble'#(true(),x,x',xs) =  [0]                                
                                    >= [1]                                
                                    =  c_6(bubble#(dd(x',xs)))            
          
              bubblesort#(dd(x,xs)) =  [1] xs + [6]                       
                                    >= [0]                                
                                    =  bubble#(dd(x,xs))                  
          
              bubblesort#(dd(x,xs)) =  [1] xs + [6]                       
                                    >= [1] xs + [5]                       
                                    =  bubblesort'#(bubble(dd(x,xs)))     
          
           bubblesort'#(pair(xs,x)) =  [1] xs + [5]                       
                                    >= [1] xs + [0]                       
                                    =  append#(bubblesort(xs),dd(x,nil()))
          
           bubblesort'#(pair(xs,x)) =  [1] xs + [5]                       
                                    >= [1] xs + [5]                       
                                    =  bubblesort#(xs)                    
          
                append(dd(x,xs),ys) =  [1] xs + [1] ys + [1]              
                                    >= [1] xs + [1] ys + [1]              
                                    =  dd(x,append(xs,ys))                
          
                   append(nil(),ys) =  [1] ys + [0]                       
                                    >= [1] ys + [0]                       
                                    =  ys                                 
          
            bubble(dd(x,dd(x',xs))) =  [1] xs + [2]                       
                                    >= [1] xs + [2]                       
                                    =  bubble'(lt(x,x'),x,x',xs)          
          
                bubble(dd(x,nil())) =  [1]                                
                                    >= [1]                                
                                    =  pair(nil(),x)                      
          
           bubble'(false(),x,x',xs) =  [1] xs + [2]                       
                                    >= [1] xs + [2]                       
                                    =  bubble''(x',bubble(dd(x,xs)))      
          
            bubble'(true(),x,x',xs) =  [1] xs + [2]                       
                                    >= [1] xs + [2]                       
                                    =  bubble''(x,bubble(dd(x',xs)))      
          
            bubble''(x,pair(xs,x')) =  [1] xs + [2]                       
                                    >= [1] xs + [2]                       
                                    =  pair(dd(x,xs),x')                  
          
               bubblesort(dd(x,xs)) =  [1] xs + [1]                       
                                    >= [1] xs + [1]                       
                                    =  bubblesort'(bubble(dd(x,xs)))      
          
                  bubblesort(nil()) =  [0]                                
                                    >= [0]                                
                                    =  nil()                              
          
            bubblesort'(pair(xs,x)) =  [1] xs + [1]                       
                                    >= [1] xs + [1]                       
                                    =  append(bubblesort(xs),dd(x,nil())) 
          
                        lt(0(),0()) =  [0]                                
                                    >= [0]                                
                                    =  false()                            
          
                       lt(0(),s(y)) =  [0]                                
                                    >= [0]                                
                                    =  true()                             
          
                       lt(s(x),0()) =  [0]                                
                                    >= [0]                                
                                    =  false()                            
          
                      lt(s(x),s(y)) =  [0]                                
                                    >= [0]                                
                                    =  lt(x,y)                            
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 5.b:1.a:4: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
        - Weak DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(append) = {1},
            uargs(bubble') = {1},
            uargs(bubble'') = {2},
            uargs(bubblesort') = {1},
            uargs(dd) = {2},
            uargs(append#) = {1},
            uargs(bubble'#) = {1},
            uargs(bubblesort'#) = {1},
            uargs(c_1) = {1},
            uargs(c_3) = {1},
            uargs(c_5) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                       p(0) = [0]                  
                  p(append) = [1] x1 + [1] x2 + [0]
                  p(bubble) = [1] x1 + [0]         
                 p(bubble') = [1] x1 + [1] x4 + [5]
                p(bubble'') = [1] x2 + [4]         
              p(bubblesort) = [1] x1 + [0]         
             p(bubblesort') = [1] x1 + [0]         
                      p(dd) = [1] x2 + [4]         
                   p(false) = [3]                  
                      p(lt) = [3]                  
                     p(nil) = [0]                  
                    p(pair) = [1] x1 + [4]         
                       p(s) = [1] x1 + [4]         
                    p(true) = [3]                  
                 p(append#) = [1] x1 + [4]         
                 p(bubble#) = [1] x1 + [0]         
                p(bubble'#) = [1] x1 + [1] x4 + [4]
               p(bubble''#) = [4] x1 + [2]         
             p(bubblesort#) = [1] x1 + [0]         
            p(bubblesort'#) = [1] x1 + [0]         
                     p(lt#) = [1] x2 + [1]         
                     p(c_1) = [1] x1 + [0]         
                     p(c_2) = [0]                  
                     p(c_3) = [1] x1 + [1]         
                     p(c_4) = [0]                  
                     p(c_5) = [1] x1 + [1]         
                     p(c_6) = [1] x1 + [3]         
                     p(c_7) = [0]                  
                     p(c_8) = [4] x1 + [0]         
                     p(c_9) = [4]                  
                    p(c_10) = [2] x1 + [2]         
                    p(c_11) = [0]                  
                    p(c_12) = [1]                  
                    p(c_13) = [0]                  
                    p(c_14) = [1] x1 + [1]         
          
          Following rules are strictly oriented:
          bubble'#(false(),x,x',xs) = [1] xs + [7]          
                                    > [1] xs + [5]          
                                    = c_5(bubble#(dd(x,xs)))
          
          
          Following rules are (at-least) weakly oriented:
              append#(dd(x,xs),ys) =  [1] xs + [8]                       
                                   >= [1] xs + [4]                       
                                   =  c_1(append#(xs,ys))                
          
          bubble#(dd(x,dd(x',xs))) =  [1] xs + [8]                       
                                   >= [1] xs + [8]                       
                                   =  c_3(bubble'#(lt(x,x'),x,x',xs))    
          
          bubble'#(true(),x,x',xs) =  [1] xs + [7]                       
                                   >= [1] xs + [7]                       
                                   =  c_6(bubble#(dd(x',xs)))            
          
             bubblesort#(dd(x,xs)) =  [1] xs + [4]                       
                                   >= [1] xs + [4]                       
                                   =  bubble#(dd(x,xs))                  
          
             bubblesort#(dd(x,xs)) =  [1] xs + [4]                       
                                   >= [1] xs + [4]                       
                                   =  bubblesort'#(bubble(dd(x,xs)))     
          
          bubblesort'#(pair(xs,x)) =  [1] xs + [4]                       
                                   >= [1] xs + [4]                       
                                   =  append#(bubblesort(xs),dd(x,nil()))
          
          bubblesort'#(pair(xs,x)) =  [1] xs + [4]                       
                                   >= [1] xs + [0]                       
                                   =  bubblesort#(xs)                    
          
               append(dd(x,xs),ys) =  [1] xs + [1] ys + [4]              
                                   >= [1] xs + [1] ys + [4]              
                                   =  dd(x,append(xs,ys))                
          
                  append(nil(),ys) =  [1] ys + [0]                       
                                   >= [1] ys + [0]                       
                                   =  ys                                 
          
           bubble(dd(x,dd(x',xs))) =  [1] xs + [8]                       
                                   >= [1] xs + [8]                       
                                   =  bubble'(lt(x,x'),x,x',xs)          
          
               bubble(dd(x,nil())) =  [4]                                
                                   >= [4]                                
                                   =  pair(nil(),x)                      
          
          bubble'(false(),x,x',xs) =  [1] xs + [8]                       
                                   >= [1] xs + [8]                       
                                   =  bubble''(x',bubble(dd(x,xs)))      
          
           bubble'(true(),x,x',xs) =  [1] xs + [8]                       
                                   >= [1] xs + [8]                       
                                   =  bubble''(x,bubble(dd(x',xs)))      
          
           bubble''(x,pair(xs,x')) =  [1] xs + [8]                       
                                   >= [1] xs + [8]                       
                                   =  pair(dd(x,xs),x')                  
          
              bubblesort(dd(x,xs)) =  [1] xs + [4]                       
                                   >= [1] xs + [4]                       
                                   =  bubblesort'(bubble(dd(x,xs)))      
          
                 bubblesort(nil()) =  [0]                                
                                   >= [0]                                
                                   =  nil()                              
          
           bubblesort'(pair(xs,x)) =  [1] xs + [4]                       
                                   >= [1] xs + [4]                       
                                   =  append(bubblesort(xs),dd(x,nil())) 
          
                       lt(0(),0()) =  [3]                                
                                   >= [3]                                
                                   =  false()                            
          
                      lt(0(),s(y)) =  [3]                                
                                   >= [3]                                
                                   =  true()                             
          
                      lt(s(x),0()) =  [3]                                
                                   >= [3]                                
                                   =  false()                            
          
                     lt(s(x),s(y)) =  [3]                                
                                   >= [3]                                
                                   =  lt(x,y)                            
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 5.b:1.a:5: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
        - Weak DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(append) = {1},
            uargs(bubble') = {1},
            uargs(bubble'') = {2},
            uargs(bubblesort') = {1},
            uargs(dd) = {2},
            uargs(append#) = {1},
            uargs(bubble'#) = {1},
            uargs(bubblesort'#) = {1},
            uargs(c_1) = {1},
            uargs(c_3) = {1},
            uargs(c_5) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                       p(0) = [0]                  
                  p(append) = [1] x1 + [1] x2 + [0]
                  p(bubble) = [1] x1 + [0]         
                 p(bubble') = [1] x1 + [1] x4 + [2]
                p(bubble'') = [1] x2 + [4]         
              p(bubblesort) = [1] x1 + [1]         
             p(bubblesort') = [1] x1 + [1]         
                      p(dd) = [1] x2 + [4]         
                   p(false) = [6]                  
                      p(lt) = [6]                  
                     p(nil) = [0]                  
                    p(pair) = [1] x1 + [4]         
                       p(s) = [1]                  
                    p(true) = [6]                  
                 p(append#) = [1] x1 + [7]         
                 p(bubble#) = [1] x1 + [2]         
                p(bubble'#) = [1] x1 + [1] x4 + [4]
               p(bubble''#) = [2] x2 + [0]         
             p(bubblesort#) = [1] x1 + [6]         
            p(bubblesort'#) = [1] x1 + [4]         
                     p(lt#) = [1] x1 + [1] x2 + [0]
                     p(c_1) = [1] x1 + [4]         
                     p(c_2) = [0]                  
                     p(c_3) = [1] x1 + [0]         
                     p(c_4) = [4]                  
                     p(c_5) = [1] x1 + [2]         
                     p(c_6) = [1] x1 + [3]         
                     p(c_7) = [1]                  
                     p(c_8) = [2]                  
                     p(c_9) = [1]                  
                    p(c_10) = [0]                  
                    p(c_11) = [0]                  
                    p(c_12) = [0]                  
                    p(c_13) = [1]                  
                    p(c_14) = [1] x1 + [0]         
          
          Following rules are strictly oriented:
          bubble'#(true(),x,x',xs) = [1] xs + [10]          
                                   > [1] xs + [9]           
                                   = c_6(bubble#(dd(x',xs)))
          
          
          Following rules are (at-least) weakly oriented:
               append#(dd(x,xs),ys) =  [1] xs + [11]                      
                                    >= [1] xs + [11]                      
                                    =  c_1(append#(xs,ys))                
          
           bubble#(dd(x,dd(x',xs))) =  [1] xs + [10]                      
                                    >= [1] xs + [10]                      
                                    =  c_3(bubble'#(lt(x,x'),x,x',xs))    
          
          bubble'#(false(),x,x',xs) =  [1] xs + [10]                      
                                    >= [1] xs + [8]                       
                                    =  c_5(bubble#(dd(x,xs)))             
          
              bubblesort#(dd(x,xs)) =  [1] xs + [10]                      
                                    >= [1] xs + [6]                       
                                    =  bubble#(dd(x,xs))                  
          
              bubblesort#(dd(x,xs)) =  [1] xs + [10]                      
                                    >= [1] xs + [8]                       
                                    =  bubblesort'#(bubble(dd(x,xs)))     
          
           bubblesort'#(pair(xs,x)) =  [1] xs + [8]                       
                                    >= [1] xs + [8]                       
                                    =  append#(bubblesort(xs),dd(x,nil()))
          
           bubblesort'#(pair(xs,x)) =  [1] xs + [8]                       
                                    >= [1] xs + [6]                       
                                    =  bubblesort#(xs)                    
          
                append(dd(x,xs),ys) =  [1] xs + [1] ys + [4]              
                                    >= [1] xs + [1] ys + [4]              
                                    =  dd(x,append(xs,ys))                
          
                   append(nil(),ys) =  [1] ys + [0]                       
                                    >= [1] ys + [0]                       
                                    =  ys                                 
          
            bubble(dd(x,dd(x',xs))) =  [1] xs + [8]                       
                                    >= [1] xs + [8]                       
                                    =  bubble'(lt(x,x'),x,x',xs)          
          
                bubble(dd(x,nil())) =  [4]                                
                                    >= [4]                                
                                    =  pair(nil(),x)                      
          
           bubble'(false(),x,x',xs) =  [1] xs + [8]                       
                                    >= [1] xs + [8]                       
                                    =  bubble''(x',bubble(dd(x,xs)))      
          
            bubble'(true(),x,x',xs) =  [1] xs + [8]                       
                                    >= [1] xs + [8]                       
                                    =  bubble''(x,bubble(dd(x',xs)))      
          
            bubble''(x,pair(xs,x')) =  [1] xs + [8]                       
                                    >= [1] xs + [8]                       
                                    =  pair(dd(x,xs),x')                  
          
               bubblesort(dd(x,xs)) =  [1] xs + [5]                       
                                    >= [1] xs + [5]                       
                                    =  bubblesort'(bubble(dd(x,xs)))      
          
                  bubblesort(nil()) =  [1]                                
                                    >= [0]                                
                                    =  nil()                              
          
            bubblesort'(pair(xs,x)) =  [1] xs + [5]                       
                                    >= [1] xs + [5]                       
                                    =  append(bubblesort(xs),dd(x,nil())) 
          
                        lt(0(),0()) =  [6]                                
                                    >= [6]                                
                                    =  false()                            
          
                       lt(0(),s(y)) =  [6]                                
                                    >= [6]                                
                                    =  true()                             
          
                       lt(s(x),0()) =  [6]                                
                                    >= [6]                                
                                    =  false()                            
          
                      lt(s(x),s(y)) =  [6]                                
                                    >= [6]                                
                                    =  lt(x,y)                            
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 5.b:1.a:6: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            append#(dd(x,xs),ys) -> c_1(append#(xs,ys))
            bubble#(dd(x,dd(x',xs))) -> c_3(bubble'#(lt(x,x'),x,x',xs))
            bubble'#(false(),x,x',xs) -> c_5(bubble#(dd(x,xs)))
            bubble'#(true(),x,x',xs) -> c_6(bubble#(dd(x',xs)))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/1,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 5.b:1.b:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak DPs:
            append#(dd(x,xs),ys) -> append#(xs,ys)
            bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
            bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
            bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
            bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:lt#(s(x),s(y)) -> c_14(lt#(x,y))
             -->_1 lt#(s(x),s(y)) -> c_14(lt#(x,y)):1
          
          2:W:append#(dd(x,xs),ys) -> append#(xs,ys)
             -->_1 append#(dd(x,xs),ys) -> append#(xs,ys):2
          
          3:W:bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
             -->_1 bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs)):6
             -->_1 bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs)):5
          
          4:W:bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
             -->_1 lt#(s(x),s(y)) -> c_14(lt#(x,y)):1
          
          5:W:bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
             -->_1 bubble#(dd(x,dd(x',xs))) -> lt#(x,x'):4
             -->_1 bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs):3
          
          6:W:bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
             -->_1 bubble#(dd(x,dd(x',xs))) -> lt#(x,x'):4
             -->_1 bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs):3
          
          7:W:bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
             -->_1 bubble#(dd(x,dd(x',xs))) -> lt#(x,x'):4
             -->_1 bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs):3
          
          8:W:bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
             -->_1 bubblesort'#(pair(xs,x)) -> bubblesort#(xs):10
             -->_1 bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil())):9
          
          9:W:bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
             -->_1 append#(dd(x,xs),ys) -> append#(xs,ys):2
          
          10:W:bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
             -->_1 bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs))):8
             -->_1 bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs)):7
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          9: bubblesort'#(pair(xs,x)) -> append#(bubblesort(xs),dd(x,nil()))
          2: append#(dd(x,xs),ys) -> append#(xs,ys)
*** Step 5.b:1.b:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak DPs:
            bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
            bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
            bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
            bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            append(dd(x,xs),ys) -> dd(x,append(xs,ys))
            append(nil(),ys) -> ys
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            bubblesort(dd(x,xs)) -> bubblesort'(bubble(dd(x,xs)))
            bubblesort(nil()) -> nil()
            bubblesort'(pair(xs,x)) -> append(bubblesort(xs),dd(x,nil()))
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
          bubble(dd(x,nil())) -> pair(nil(),x)
          bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
          bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
          bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
          lt(0(),0()) -> false()
          lt(0(),s(y)) -> true()
          lt(s(x),0()) -> false()
          lt(s(x),s(y)) -> lt(x,y)
          bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
          bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
          bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
          bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
          bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
          bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
          bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
          lt#(s(x),s(y)) -> c_14(lt#(x,y))
*** Step 5.b:1.b:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak DPs:
            bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
            bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
            bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
            bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
        - Weak TRS:
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_14) = {1}
        
        Following symbols are considered usable:
          {bubble,bubble',bubble'',append#,bubble#,bubble'#,bubble''#,bubblesort#,bubblesort'#,lt#}
        TcT has computed the following interpretation:
                     p(0) = [1]                           
                p(append) = [1] x1 + [0]                  
                p(bubble) = [1] x1 + [1]                  
               p(bubble') = [1] x2 + [1] x3 + [1] x4 + [3]
              p(bubble'') = [1] x1 + [1] x2 + [1]         
            p(bubblesort) = [2] x1 + [1]                  
           p(bubblesort') = [0]                           
                    p(dd) = [1] x1 + [1] x2 + [1]         
                 p(false) = [1]                           
                    p(lt) = [1] x1 + [7]                  
                   p(nil) = [0]                           
                  p(pair) = [1] x1 + [2]                  
                     p(s) = [1] x1 + [4]                  
                  p(true) = [2]                           
               p(append#) = [1] x2 + [2]                  
               p(bubble#) = [4] x1 + [0]                  
              p(bubble'#) = [4] x2 + [4] x3 + [4] x4 + [6]
             p(bubble''#) = [4]                           
           p(bubblesort#) = [4] x1 + [4]                  
          p(bubblesort'#) = [4] x1 + [0]                  
                   p(lt#) = [2] x1 + [0]                  
                   p(c_1) = [0]                           
                   p(c_2) = [1]                           
                   p(c_3) = [1] x2 + [1]                  
                   p(c_4) = [1]                           
                   p(c_5) = [1] x1 + [0]                  
                   p(c_6) = [0]                           
                   p(c_7) = [0]                           
                   p(c_8) = [1] x1 + [1] x2 + [0]         
                   p(c_9) = [1]                           
                  p(c_10) = [2] x2 + [1]                  
                  p(c_11) = [0]                           
                  p(c_12) = [2]                           
                  p(c_13) = [0]                           
                  p(c_14) = [1] x1 + [7]                  
        
        Following rules are strictly oriented:
        lt#(s(x),s(y)) = [2] x + [8]   
                       > [2] x + [7]   
                       = c_14(lt#(x,y))
        
        
        Following rules are (at-least) weakly oriented:
         bubble#(dd(x,dd(x',xs))) =  [4] x + [4] x' + [4] xs + [8] 
                                  >= [4] x + [4] x' + [4] xs + [6] 
                                  =  bubble'#(lt(x,x'),x,x',xs)    
        
         bubble#(dd(x,dd(x',xs))) =  [4] x + [4] x' + [4] xs + [8] 
                                  >= [2] x + [0]                   
                                  =  lt#(x,x')                     
        
        bubble'#(false(),x,x',xs) =  [4] x + [4] x' + [4] xs + [6] 
                                  >= [4] x + [4] xs + [4]          
                                  =  bubble#(dd(x,xs))             
        
         bubble'#(true(),x,x',xs) =  [4] x + [4] x' + [4] xs + [6] 
                                  >= [4] x' + [4] xs + [4]         
                                  =  bubble#(dd(x',xs))            
        
            bubblesort#(dd(x,xs)) =  [4] x + [4] xs + [8]          
                                  >= [4] x + [4] xs + [4]          
                                  =  bubble#(dd(x,xs))             
        
            bubblesort#(dd(x,xs)) =  [4] x + [4] xs + [8]          
                                  >= [4] x + [4] xs + [8]          
                                  =  bubblesort'#(bubble(dd(x,xs)))
        
         bubblesort'#(pair(xs,x)) =  [4] xs + [8]                  
                                  >= [4] xs + [4]                  
                                  =  bubblesort#(xs)               
        
          bubble(dd(x,dd(x',xs))) =  [1] x + [1] x' + [1] xs + [3] 
                                  >= [1] x + [1] x' + [1] xs + [3] 
                                  =  bubble'(lt(x,x'),x,x',xs)     
        
              bubble(dd(x,nil())) =  [1] x + [2]                   
                                  >= [2]                           
                                  =  pair(nil(),x)                 
        
         bubble'(false(),x,x',xs) =  [1] x + [1] x' + [1] xs + [3] 
                                  >= [1] x + [1] x' + [1] xs + [3] 
                                  =  bubble''(x',bubble(dd(x,xs))) 
        
          bubble'(true(),x,x',xs) =  [1] x + [1] x' + [1] xs + [3] 
                                  >= [1] x + [1] x' + [1] xs + [3] 
                                  =  bubble''(x,bubble(dd(x',xs))) 
        
          bubble''(x,pair(xs,x')) =  [1] x + [1] xs + [3]          
                                  >= [1] x + [1] xs + [3]          
                                  =  pair(dd(x,xs),x')             
        
*** Step 5.b:1.b:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            bubble#(dd(x,dd(x',xs))) -> bubble'#(lt(x,x'),x,x',xs)
            bubble#(dd(x,dd(x',xs))) -> lt#(x,x')
            bubble'#(false(),x,x',xs) -> bubble#(dd(x,xs))
            bubble'#(true(),x,x',xs) -> bubble#(dd(x',xs))
            bubblesort#(dd(x,xs)) -> bubble#(dd(x,xs))
            bubblesort#(dd(x,xs)) -> bubblesort'#(bubble(dd(x,xs)))
            bubblesort'#(pair(xs,x)) -> bubblesort#(xs)
            lt#(s(x),s(y)) -> c_14(lt#(x,y))
        - Weak TRS:
            bubble(dd(x,dd(x',xs))) -> bubble'(lt(x,x'),x,x',xs)
            bubble(dd(x,nil())) -> pair(nil(),x)
            bubble'(false(),x,x',xs) -> bubble''(x',bubble(dd(x,xs)))
            bubble'(true(),x,x',xs) -> bubble''(x,bubble(dd(x',xs)))
            bubble''(x,pair(xs,x')) -> pair(dd(x,xs),x')
            lt(0(),0()) -> false()
            lt(0(),s(y)) -> true()
            lt(s(x),0()) -> false()
            lt(s(x),s(y)) -> lt(x,y)
        - Signature:
            {append/2,bubble/1,bubble'/4,bubble''/2,bubblesort/1,bubblesort'/1,lt/2,append#/2,bubble#/1,bubble'#/4
            ,bubble''#/2,bubblesort#/1,bubblesort'#/1,lt#/2} / {0/0,dd/2,false/0,nil/0,pair/2,s/1,true/0,c_1/1,c_2/0
            ,c_3/2,c_4/0,c_5/1,c_6/1,c_7/0,c_8/2,c_9/0,c_10/2,c_11/0,c_12/0,c_13/0,c_14/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,bubble#,bubble'#,bubble''#,bubblesort#
            ,bubblesort'#,lt#} and constructors {0,dd,false,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^3))

WORST_CASE(?,O(n^1))
* Step 1: DependencyPairs WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict TRS:
            deleteMin#1(E()) -> ErrorHeap()
            deleteMin#1(T(E(),x6,x8)) -> x8
            deleteMin#1(T(T(E(),x24,x28),x12,x16)) -> T(x28,x12,x16)
            deleteMin#1(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> T(deleteMin#1(T(x32,x36,x40)),x24,T(x28,x12,x16))
            main(x0) -> deleteMin#1(x0)
        - Signature:
            {deleteMin#1/1,main/1} / {E/0,ErrorHeap/0,T/3}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1,main} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          deleteMin#1#(E()) -> c_1()
          deleteMin#1#(T(E(),x6,x8)) -> c_2()
          deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
          deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
          main#(x0) -> c_5(deleteMin#1#(x0))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            deleteMin#1#(E()) -> c_1()
            deleteMin#1#(T(E(),x6,x8)) -> c_2()
            deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
            main#(x0) -> c_5(deleteMin#1#(x0))
        - Weak TRS:
            deleteMin#1(E()) -> ErrorHeap()
            deleteMin#1(T(E(),x6,x8)) -> x8
            deleteMin#1(T(T(E(),x24,x28),x12,x16)) -> T(x28,x12,x16)
            deleteMin#1(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> T(deleteMin#1(T(x32,x36,x40)),x24,T(x28,x12,x16))
            main(x0) -> deleteMin#1(x0)
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1,2,3}
        by application of
          Pre({1,2,3}) = {4,5}.
        Here rules are labelled as follows:
          1: deleteMin#1#(E()) -> c_1()
          2: deleteMin#1#(T(E(),x6,x8)) -> c_2()
          3: deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
          4: deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
          5: main#(x0) -> c_5(deleteMin#1#(x0))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
            main#(x0) -> c_5(deleteMin#1#(x0))
        - Weak DPs:
            deleteMin#1#(E()) -> c_1()
            deleteMin#1#(T(E(),x6,x8)) -> c_2()
            deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
        - Weak TRS:
            deleteMin#1(E()) -> ErrorHeap()
            deleteMin#1(T(E(),x6,x8)) -> x8
            deleteMin#1(T(T(E(),x24,x28),x12,x16)) -> T(x28,x12,x16)
            deleteMin#1(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> T(deleteMin#1(T(x32,x36,x40)),x24,T(x28,x12,x16))
            main(x0) -> deleteMin#1(x0)
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
             -->_1 deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3():5
             -->_1 deleteMin#1#(T(E(),x6,x8)) -> c_2():4
             -->_1 deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40))):1
          
          2:S:main#(x0) -> c_5(deleteMin#1#(x0))
             -->_1 deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3():5
             -->_1 deleteMin#1#(T(E(),x6,x8)) -> c_2():4
             -->_1 deleteMin#1#(E()) -> c_1():3
             -->_1 deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40))):1
          
          3:W:deleteMin#1#(E()) -> c_1()
             
          
          4:W:deleteMin#1#(T(E(),x6,x8)) -> c_2()
             
          
          5:W:deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: deleteMin#1#(E()) -> c_1()
          4: deleteMin#1#(T(E(),x6,x8)) -> c_2()
          5: deleteMin#1#(T(T(E(),x24,x28),x12,x16)) -> c_3()
* Step 4: RemoveHeads WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
            main#(x0) -> c_5(deleteMin#1#(x0))
        - Weak TRS:
            deleteMin#1(E()) -> ErrorHeap()
            deleteMin#1(T(E(),x6,x8)) -> x8
            deleteMin#1(T(T(E(),x24,x28),x12,x16)) -> T(x28,x12,x16)
            deleteMin#1(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> T(deleteMin#1(T(x32,x36,x40)),x24,T(x28,x12,x16))
            main(x0) -> deleteMin#1(x0)
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
           -->_1 deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40))):1
        
        2:S:main#(x0) -> c_5(deleteMin#1#(x0))
           -->_1 deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40))):1
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(2,main#(x0) -> c_5(deleteMin#1#(x0)))]
* Step 5: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
        - Weak TRS:
            deleteMin#1(E()) -> ErrorHeap()
            deleteMin#1(T(E(),x6,x8)) -> x8
            deleteMin#1(T(T(E(),x24,x28),x12,x16)) -> T(x28,x12,x16)
            deleteMin#1(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> T(deleteMin#1(T(x32,x36,x40)),x24,T(x28,x12,x16))
            main(x0) -> deleteMin#1(x0)
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
* Step 6: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_4) = {1}
        
        Following symbols are considered usable:
          {deleteMin#1#,main#}
        TcT has computed the following interpretation:
                     p(E) = [0]         
             p(ErrorHeap) = [2]         
                     p(T) = [1] x1 + [2]
           p(deleteMin#1) = [1] x1 + [0]
                  p(main) = [1]         
          p(deleteMin#1#) = [1] x1 + [8]
                 p(main#) = [1]         
                   p(c_1) = [1]         
                   p(c_2) = [2]         
                   p(c_3) = [8]         
                   p(c_4) = [1] x1 + [0]
                   p(c_5) = [0]         
        
        Following rules are strictly oriented:
        deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) = [1] x32 + [14]                   
                                                           > [1] x32 + [10]                   
                                                           = c_4(deleteMin#1#(T(x32,x36,x40)))
        
        
        Following rules are (at-least) weakly oriented:
        
* Step 7: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            deleteMin#1#(T(T(T(x32,x36,x40),x24,x28),x12,x16)) -> c_4(deleteMin#1#(T(x32,x36,x40)))
        - Signature:
            {deleteMin#1/1,main/1,deleteMin#1#/1,main#/1} / {E/0,ErrorHeap/0,T/3,c_1/0,c_2/0,c_3/0,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {deleteMin#1#,main#} and constructors {E,ErrorHeap,T}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^1))

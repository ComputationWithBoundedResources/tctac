WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1} / {cons/2,nil/0,pair/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append,attach,pairsp} and constructors {cons,nil,pair}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
          append#(nil(),ys) -> c_2()
          attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
          attach#(x,nil()) -> c_4()
          pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
          pairsp#(nil()) -> c_6()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
            append#(nil(),ys) -> c_2()
            attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
            attach#(x,nil()) -> c_4()
            pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
            pairsp#(nil()) -> c_6()
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4,6}
        by application of
          Pre({2,4,6}) = {1,3,5}.
        Here rules are labelled as follows:
          1: append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
          2: append#(nil(),ys) -> c_2()
          3: attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
          4: attach#(x,nil()) -> c_4()
          5: pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
          6: pairsp#(nil()) -> c_6()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
            attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
            pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
        - Weak DPs:
            append#(nil(),ys) -> c_2()
            attach#(x,nil()) -> c_4()
            pairsp#(nil()) -> c_6()
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
             -->_1 append#(nil(),ys) -> c_2():4
             -->_1 append#(cons(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          2:S:attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
             -->_1 attach#(x,nil()) -> c_4():5
             -->_1 attach#(x,cons(y,ys)) -> c_3(attach#(x,ys)):2
          
          3:S:pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
             -->_2 pairsp#(nil()) -> c_6():6
             -->_3 attach#(x,nil()) -> c_4():5
             -->_1 append#(nil(),ys) -> c_2():4
             -->_2 pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs)):3
             -->_3 attach#(x,cons(y,ys)) -> c_3(attach#(x,ys)):2
             -->_1 append#(cons(x,xs),ys) -> c_1(append#(xs,ys)):1
          
          4:W:append#(nil(),ys) -> c_2()
             
          
          5:W:attach#(x,nil()) -> c_4()
             
          
          6:W:pairsp#(nil()) -> c_6()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          6: pairsp#(nil()) -> c_6()
          5: attach#(x,nil()) -> c_4()
          4: append#(nil(),ys) -> c_2()
* Step 4: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
            attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
            pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
        and a lower component
          append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
          attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
        Further, following extension rules are added to the lower component.
          pairsp#(cons(x,xs)) -> append#(pairsp(xs),attach(x,xs))
          pairsp#(cons(x,xs)) -> attach#(x,xs)
          pairsp#(cons(x,xs)) -> pairsp#(xs)
** Step 4.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs))
             -->_2 pairsp#(cons(x,xs)) -> c_5(append#(pairsp(xs),attach(x,xs)),pairsp#(xs),attach#(x,xs)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          pairsp#(cons(x,xs)) -> c_5(pairsp#(xs))
** Step 4.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            pairsp#(cons(x,xs)) -> c_5(pairsp#(xs))
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/1,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          pairsp#(cons(x,xs)) -> c_5(pairsp#(xs))
** Step 4.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            pairsp#(cons(x,xs)) -> c_5(pairsp#(xs))
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/1,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_5) = {1}
        
        Following symbols are considered usable:
          {append#,attach#,pairsp#}
        TcT has computed the following interpretation:
           p(append) = [1] x2 + [2]          
           p(attach) = [1] x2 + [2]          
             p(cons) = [1] x1 + [1] x2 + [14]
              p(nil) = [0]                   
             p(pair) = [1] x1 + [1] x2 + [4] 
           p(pairsp) = [1]                   
          p(append#) = [1] x1 + [1] x2 + [0] 
          p(attach#) = [4] x1 + [2]          
          p(pairsp#) = [2] x1 + [0]          
              p(c_1) = [0]                   
              p(c_2) = [0]                   
              p(c_3) = [1]                   
              p(c_4) = [1]                   
              p(c_5) = [1] x1 + [15]         
              p(c_6) = [1]                   
        
        Following rules are strictly oriented:
        pairsp#(cons(x,xs)) = [2] x + [2] xs + [28]
                            > [2] xs + [15]        
                            = c_5(pairsp#(xs))     
        
        
        Following rules are (at-least) weakly oriented:
        
** Step 4.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            pairsp#(cons(x,xs)) -> c_5(pairsp#(xs))
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/1,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 4.b:1: NaturalMI WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
            attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
        - Weak DPs:
            pairsp#(cons(x,xs)) -> append#(pairsp(xs),attach(x,xs))
            pairsp#(cons(x,xs)) -> attach#(x,xs)
            pairsp#(cons(x,xs)) -> pairsp#(xs)
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_3) = {1}
        
        Following symbols are considered usable:
          {append#,attach#,pairsp#}
        TcT has computed the following interpretation:
           p(append) = [2] x1 + [10]                 
           p(attach) = [2]                           
             p(cons) = [1] x1 + [1] x2 + [8]         
              p(nil) = [1]                           
             p(pair) = [8]                           
           p(pairsp) = [1] x1 + [5]                  
          p(append#) = [0]                           
          p(attach#) = [2] x2 + [0]                  
          p(pairsp#) = [2] x1 + [0]                  
              p(c_1) = [4] x1 + [0]                  
              p(c_2) = [0]                           
              p(c_3) = [1] x1 + [4]                  
              p(c_4) = [8]                           
              p(c_5) = [1] x1 + [1] x2 + [2] x3 + [2]
              p(c_6) = [2]                           
        
        Following rules are strictly oriented:
        attach#(x,cons(y,ys)) = [2] y + [2] ys + [16]
                              > [2] ys + [4]         
                              = c_3(attach#(x,ys))   
        
        
        Following rules are (at-least) weakly oriented:
        append#(cons(x,xs),ys) =  [0]                             
                               >= [0]                             
                               =  c_1(append#(xs,ys))             
        
           pairsp#(cons(x,xs)) =  [2] x + [2] xs + [16]           
                               >= [0]                             
                               =  append#(pairsp(xs),attach(x,xs))
        
           pairsp#(cons(x,xs)) =  [2] x + [2] xs + [16]           
                               >= [2] xs + [0]                    
                               =  attach#(x,xs)                   
        
           pairsp#(cons(x,xs)) =  [2] x + [2] xs + [16]           
                               >= [2] xs + [0]                    
                               =  pairsp#(xs)                     
        
** Step 4.b:2: Ara WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
        - Weak DPs:
            attach#(x,cons(y,ys)) -> c_3(attach#(x,ys))
            pairsp#(cons(x,xs)) -> append#(pairsp(xs),attach(x,xs))
            pairsp#(cons(x,xs)) -> attach#(x,xs)
            pairsp#(cons(x,xs)) -> pairsp#(xs)
        - Weak TRS:
            append(cons(x,xs),ys) -> cons(x,append(xs,ys))
            append(nil(),ys) -> ys
            attach(x,cons(y,ys)) -> cons(pair(x,y),attach(x,ys))
            attach(x,nil()) -> nil()
            pairsp(cons(x,xs)) -> append(pairsp(xs),attach(x,xs))
            pairsp(nil()) -> nil()
        - Signature:
            {append/2,attach/2,pairsp/1,append#/2,attach#/2,pairsp#/1} / {cons/2,nil/0,pair/2,c_1/1,c_2/0,c_3/1,c_4/0
            ,c_5/3,c_6/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,attach#,pairsp#} and constructors {cons,nil,pair}
    + Applied Processor:
        Ara {araHeuristics = NoHeuristics, minDegree = 1, maxDegree = 2, araTimeout = 8, araRuleShifting = Just 1}
    + Details:
        Signatures used:
        ----------------
          append :: ["A"(1, 0) x "A"(1, 0)] -(0)-> "A"(1, 0)
          attach :: ["A"(0, 0) x "A"(1, 0)] -(5)-> "A"(1, 0)
          cons :: ["A"(0, 0) x "A"(1, 0)] -(1)-> "A"(1, 0)
          cons :: ["A"(0, 0) x "A"(9, 4)] -(5)-> "A"(5, 4)
          cons :: ["A"(0, 0) x "A"(13, 1)] -(12)-> "A"(12, 1)
          cons :: ["A"(0, 0) x "A"(14, 7)] -(7)-> "A"(7, 7)
          nil :: [] -(0)-> "A"(1, 0)
          nil :: [] -(0)-> "A"(5, 4)
          nil :: [] -(0)-> "A"(7, 6)
          pair :: ["A"(0, 0) x "A"(0, 0)] -(0)-> "A"(4, 8)
          pairsp :: ["A"(5, 4)] -(1)-> "A"(1, 0)
          append# :: ["A"(1, 0) x "A"(1, 0)] -(1)-> "A"(5, 5)
          attach# :: ["A"(0, 0) x "A"(12, 1)] -(4)-> "A"(10, 3)
          pairsp# :: ["A"(7, 7)] -(9)-> "A"(3, 3)
          c_1 :: ["A"(0, 0)] -(0)-> "A"(5, 12)
          c_3 :: ["A"(0, 0)] -(10)-> "A"(10, 10)
        
        
        Cost-free Signatures used:
        --------------------------
        
        
        
        Base Constructor Signatures used:
        ---------------------------------
          "c_1_A" :: ["A"(0)] -(0)-> "A"(1, 0)
          "c_1_A" :: ["A"(0)] -(0)-> "A"(0, 1)
          "c_3_A" :: ["A"(0)] -(1)-> "A"(1, 0)
          "c_3_A" :: ["A"(0)] -(0)-> "A"(0, 1)
          "cons_A" :: ["A"(0, 0) x "A"(1, 0)] -(1)-> "A"(1, 0)
          "cons_A" :: ["A"(0, 0) x "A"(1, 1)] -(0)-> "A"(0, 1)
          "nil_A" :: [] -(0)-> "A"(1, 0)
          "nil_A" :: [] -(0)-> "A"(0, 1)
          "pair_A" :: ["A"(0, 0) x "A"(0, 0)] -(0)-> "A"(1, 0)
          "pair_A" :: ["A"(0, 0) x "A"(0, 0)] -(0)-> "A"(0, 1)
        
        
        Following Still Strict Rules were Typed as:
        -------------------------------------------
        1. Strict:
          append#(cons(x,xs),ys) -> c_1(append#(xs,ys))
        2. Weak:
          

WORST_CASE(?,O(n^3))

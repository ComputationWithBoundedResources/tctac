WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5} / {cons/2,leaf/0,nil/0,node/3}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append,append#1,subtrees,subtrees#1,subtrees#2
            ,subtrees#3} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          append#(l1,l2) -> c_1(append#1#(l1,l2))
          append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
          append#1#(nil(),l2) -> c_3()
          subtrees#(t) -> c_4(subtrees#1#(t))
          subtrees#1#(leaf()) -> c_5()
          subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
          subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            append#1#(nil(),l2) -> c_3()
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(leaf()) -> c_5()
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {3,5}
        by application of
          Pre({3,5}) = {1,4}.
        Here rules are labelled as follows:
          1: append#(l1,l2) -> c_1(append#1#(l1,l2))
          2: append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
          3: append#1#(nil(),l2) -> c_3()
          4: subtrees#(t) -> c_4(subtrees#1#(t))
          5: subtrees#1#(leaf()) -> c_5()
          6: subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          7: subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
          8: subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak DPs:
            append#1#(nil(),l2) -> c_3()
            subtrees#1#(leaf()) -> c_5()
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:append#(l1,l2) -> c_1(append#1#(l1,l2))
             -->_1 append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2)):2
             -->_1 append#1#(nil(),l2) -> c_3():7
          
          2:S:append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
             -->_1 append#(l1,l2) -> c_1(append#1#(l1,l2)):1
          
          3:S:subtrees#(t) -> c_4(subtrees#1#(t))
             -->_1 subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1)):4
             -->_1 subtrees#1#(leaf()) -> c_5():8
          
          4:S:subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
             -->_1 subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2)):5
             -->_2 subtrees#(t) -> c_4(subtrees#1#(t)):3
          
          5:S:subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
             -->_1 subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2)):6
             -->_2 subtrees#(t) -> c_4(subtrees#1#(t)):3
          
          6:S:subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
             -->_1 append#(l1,l2) -> c_1(append#1#(l1,l2)):1
          
          7:W:append#1#(nil(),l2) -> c_3()
             
          
          8:W:subtrees#1#(leaf()) -> c_5()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          8: subtrees#1#(leaf()) -> c_5()
          7: append#1#(nil(),l2) -> c_3()
* Step 4: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          subtrees#(t) -> c_4(subtrees#1#(t))
          subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
        and a lower component
          append#(l1,l2) -> c_1(append#1#(l1,l2))
          append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
          subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        Further, following extension rules are added to the lower component.
          subtrees#(t) -> subtrees#1#(t)
          subtrees#1#(node(x,t1,t2)) -> subtrees#(t1)
          subtrees#1#(node(x,t1,t2)) -> subtrees#2#(subtrees(t1),t1,t2,x)
          subtrees#2#(l1,t1,t2,x) -> subtrees#(t2)
          subtrees#2#(l1,t1,t2,x) -> subtrees#3#(subtrees(t2),l1,t1,t2,x)
** Step 4.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:subtrees#(t) -> c_4(subtrees#1#(t))
             -->_1 subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1)):2
          
          2:S:subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
             -->_1 subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2)):3
             -->_2 subtrees#(t) -> c_4(subtrees#1#(t)):1
          
          3:S:subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#3#(subtrees(t2),l1,t1,t2,x),subtrees#(t2))
             -->_2 subtrees#(t) -> c_4(subtrees#1#(t)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#(t2))
** Step 4.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#(t2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/1,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(subtrees#2) = {1},
            uargs(subtrees#3) = {1},
            uargs(subtrees#2#) = {1},
            uargs(c_4) = {1},
            uargs(c_6) = {1,2},
            uargs(c_7) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(append) = [1] x1 + [1] x2 + [0]
               p(append#1) = [1] x1 + [1] x2 + [0]
                   p(cons) = [1] x2 + [0]         
                   p(leaf) = [4]                  
                    p(nil) = [0]                  
                   p(node) = [1] x1 + [1] x3 + [0]
               p(subtrees) = [0]                  
             p(subtrees#1) = [0]                  
             p(subtrees#2) = [1] x1 + [0]         
             p(subtrees#3) = [1] x1 + [1] x2 + [0]
                p(append#) = [1] x2 + [0]         
              p(append#1#) = [2] x1 + [4] x2 + [4]
              p(subtrees#) = [2]                  
            p(subtrees#1#) = [3]                  
            p(subtrees#2#) = [1] x1 + [0]         
            p(subtrees#3#) = [2]                  
                    p(c_1) = [0]                  
                    p(c_2) = [0]                  
                    p(c_3) = [0]                  
                    p(c_4) = [1] x1 + [5]         
                    p(c_5) = [0]                  
                    p(c_6) = [1] x1 + [1] x2 + [0]
                    p(c_7) = [1] x1 + [5]         
                    p(c_8) = [1] x1 + [0]         
          
          Following rules are strictly oriented:
          subtrees#1#(node(x,t1,t2)) = [3]                                                 
                                     > [2]                                                 
                                     = c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          
          
          Following rules are (at-least) weakly oriented:
                       subtrees#(t) =  [2]                                
                                    >= [8]                                
                                    =  c_4(subtrees#1#(t))                
          
            subtrees#2#(l1,t1,t2,x) =  [1] l1 + [0]                       
                                    >= [7]                                
                                    =  c_7(subtrees#(t2))                 
          
                      append(l1,l2) =  [1] l1 + [1] l2 + [0]              
                                    >= [1] l1 + [1] l2 + [0]              
                                    =  append#1(l1,l2)                    
          
            append#1(cons(x,xs),l2) =  [1] l2 + [1] xs + [0]              
                                    >= [1] l2 + [1] xs + [0]              
                                    =  cons(x,append(xs,l2))              
          
                 append#1(nil(),l2) =  [1] l2 + [0]                       
                                    >= [1] l2 + [0]                       
                                    =  l2                                 
          
                        subtrees(t) =  [0]                                
                                    >= [0]                                
                                    =  subtrees#1(t)                      
          
                 subtrees#1(leaf()) =  [0]                                
                                    >= [0]                                
                                    =  nil()                              
          
          subtrees#1(node(x,t1,t2)) =  [0]                                
                                    >= [0]                                
                                    =  subtrees#2(subtrees(t1),t1,t2,x)   
          
             subtrees#2(l1,t1,t2,x) =  [1] l1 + [0]                       
                                    >= [1] l1 + [0]                       
                                    =  subtrees#3(subtrees(t2),l1,t1,t2,x)
          
          subtrees#3(l2,l1,t1,t2,x) =  [1] l1 + [1] l2 + [0]              
                                    >= [1] l1 + [1] l2 + [0]              
                                    =  cons(node(x,t1,t2),append(l1,l2))  
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#(t2))
        - Weak DPs:
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/1,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(subtrees#2) = {1},
            uargs(subtrees#3) = {1},
            uargs(subtrees#2#) = {1},
            uargs(c_4) = {1},
            uargs(c_6) = {1,2},
            uargs(c_7) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(append) = [1] x2 + [0]                  
               p(append#1) = [1] x2 + [0]                  
                   p(cons) = [1] x2 + [0]                  
                   p(leaf) = [0]                           
                    p(nil) = [0]                           
                   p(node) = [1] x1 + [1] x2 + [1] x3 + [0]
               p(subtrees) = [0]                           
             p(subtrees#1) = [0]                           
             p(subtrees#2) = [1] x1 + [0]                  
             p(subtrees#3) = [1] x1 + [0]                  
                p(append#) = [2] x1 + [4]                  
              p(append#1#) = [1]                           
              p(subtrees#) = [0]                           
            p(subtrees#1#) = [1]                           
            p(subtrees#2#) = [1] x1 + [1]                  
            p(subtrees#3#) = [4] x2 + [0]                  
                    p(c_1) = [1] x1 + [1]                  
                    p(c_2) = [2]                           
                    p(c_3) = [1]                           
                    p(c_4) = [1] x1 + [7]                  
                    p(c_5) = [1]                           
                    p(c_6) = [1] x1 + [1] x2 + [0]         
                    p(c_7) = [1] x1 + [0]                  
                    p(c_8) = [1] x1 + [2]                  
          
          Following rules are strictly oriented:
          subtrees#2#(l1,t1,t2,x) = [1] l1 + [1]      
                                  > [0]               
                                  = c_7(subtrees#(t2))
          
          
          Following rules are (at-least) weakly oriented:
                        subtrees#(t) =  [0]                                                 
                                     >= [8]                                                 
                                     =  c_4(subtrees#1#(t))                                 
          
          subtrees#1#(node(x,t1,t2)) =  [1]                                                 
                                     >= [1]                                                 
                                     =  c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          
                       append(l1,l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  append#1(l1,l2)                                     
          
             append#1(cons(x,xs),l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  cons(x,append(xs,l2))                               
          
                  append#1(nil(),l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  l2                                                  
          
                         subtrees(t) =  [0]                                                 
                                     >= [0]                                                 
                                     =  subtrees#1(t)                                       
          
                  subtrees#1(leaf()) =  [0]                                                 
                                     >= [0]                                                 
                                     =  nil()                                               
          
           subtrees#1(node(x,t1,t2)) =  [0]                                                 
                                     >= [0]                                                 
                                     =  subtrees#2(subtrees(t1),t1,t2,x)                    
          
              subtrees#2(l1,t1,t2,x) =  [1] l1 + [0]                                        
                                     >= [0]                                                 
                                     =  subtrees#3(subtrees(t2),l1,t1,t2,x)                 
          
           subtrees#3(l2,l1,t1,t2,x) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  cons(node(x,t1,t2),append(l1,l2))                   
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.a:4: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            subtrees#(t) -> c_4(subtrees#1#(t))
        - Weak DPs:
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#(t2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/1,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(subtrees#2) = {1},
            uargs(subtrees#3) = {1},
            uargs(subtrees#2#) = {1},
            uargs(c_4) = {1},
            uargs(c_6) = {1,2},
            uargs(c_7) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(append) = [1] x2 + [0]                  
               p(append#1) = [1] x2 + [0]                  
                   p(cons) = [1] x2 + [0]                  
                   p(leaf) = [1]                           
                    p(nil) = [0]                           
                   p(node) = [1] x1 + [1] x2 + [1] x3 + [7]
               p(subtrees) = [0]                           
             p(subtrees#1) = [0]                           
             p(subtrees#2) = [1] x1 + [0]                  
             p(subtrees#3) = [1] x1 + [0]                  
                p(append#) = [2] x1 + [1] x2 + [0]         
              p(append#1#) = [2] x1 + [4] x2 + [0]         
              p(subtrees#) = [1] x1 + [1]                  
            p(subtrees#1#) = [1] x1 + [0]                  
            p(subtrees#2#) = [1] x1 + [1] x3 + [1] x4 + [1]
            p(subtrees#3#) = [1] x1 + [4]                  
                    p(c_1) = [4]                           
                    p(c_2) = [0]                           
                    p(c_3) = [0]                           
                    p(c_4) = [1] x1 + [0]                  
                    p(c_5) = [2]                           
                    p(c_6) = [1] x1 + [1] x2 + [5]         
                    p(c_7) = [1] x1 + [0]                  
                    p(c_8) = [1] x1 + [4]                  
          
          Following rules are strictly oriented:
          subtrees#(t) = [1] t + [1]        
                       > [1] t + [0]        
                       = c_4(subtrees#1#(t))
          
          
          Following rules are (at-least) weakly oriented:
          subtrees#1#(node(x,t1,t2)) =  [1] t1 + [1] t2 + [1] x + [7]                       
                                     >= [1] t1 + [1] t2 + [1] x + [7]                       
                                     =  c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
          
             subtrees#2#(l1,t1,t2,x) =  [1] l1 + [1] t2 + [1] x + [1]                       
                                     >= [1] t2 + [1]                                        
                                     =  c_7(subtrees#(t2))                                  
          
                       append(l1,l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  append#1(l1,l2)                                     
          
             append#1(cons(x,xs),l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  cons(x,append(xs,l2))                               
          
                  append#1(nil(),l2) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  l2                                                  
          
                         subtrees(t) =  [0]                                                 
                                     >= [0]                                                 
                                     =  subtrees#1(t)                                       
          
                  subtrees#1(leaf()) =  [0]                                                 
                                     >= [0]                                                 
                                     =  nil()                                               
          
           subtrees#1(node(x,t1,t2)) =  [0]                                                 
                                     >= [0]                                                 
                                     =  subtrees#2(subtrees(t1),t1,t2,x)                    
          
              subtrees#2(l1,t1,t2,x) =  [1] l1 + [0]                                        
                                     >= [0]                                                 
                                     =  subtrees#3(subtrees(t2),l1,t1,t2,x)                 
          
           subtrees#3(l2,l1,t1,t2,x) =  [1] l2 + [0]                                        
                                     >= [1] l2 + [0]                                        
                                     =  cons(node(x,t1,t2),append(l1,l2))                   
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.a:5: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            subtrees#(t) -> c_4(subtrees#1#(t))
            subtrees#1#(node(x,t1,t2)) -> c_6(subtrees#2#(subtrees(t1),t1,t2,x),subtrees#(t1))
            subtrees#2#(l1,t1,t2,x) -> c_7(subtrees#(t2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/1,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 4.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak DPs:
            subtrees#(t) -> subtrees#1#(t)
            subtrees#1#(node(x,t1,t2)) -> subtrees#(t1)
            subtrees#1#(node(x,t1,t2)) -> subtrees#2#(subtrees(t1),t1,t2,x)
            subtrees#2#(l1,t1,t2,x) -> subtrees#(t2)
            subtrees#2#(l1,t1,t2,x) -> subtrees#3#(subtrees(t2),l1,t1,t2,x)
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_2) = {1},
          uargs(c_8) = {1}
        
        Following symbols are considered usable:
          {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#,subtrees#3#}
        TcT has computed the following interpretation:
               p(append) = [0]                  
             p(append#1) = [2] x1 + [0]         
                 p(cons) = [1] x1 + [1]         
                 p(leaf) = [0]                  
                  p(nil) = [0]                  
                 p(node) = [1] x2 + [1] x3 + [0]
             p(subtrees) = [0]                  
           p(subtrees#1) = [4] x1 + [0]         
           p(subtrees#2) = [0]                  
           p(subtrees#3) = [4] x3 + [1] x4 + [0]
              p(append#) = [0]                  
            p(append#1#) = [0]                  
            p(subtrees#) = [3]                  
          p(subtrees#1#) = [3]                  
          p(subtrees#2#) = [3]                  
          p(subtrees#3#) = [3]                  
                  p(c_1) = [4] x1 + [0]         
                  p(c_2) = [2] x1 + [0]         
                  p(c_3) = [0]                  
                  p(c_4) = [0]                  
                  p(c_5) = [0]                  
                  p(c_6) = [2] x1 + [8] x2 + [0]
                  p(c_7) = [1] x1 + [0]         
                  p(c_8) = [2] x1 + [1]         
        
        Following rules are strictly oriented:
        subtrees#3#(l2,l1,t1,t2,x) = [3]                
                                   > [1]                
                                   = c_8(append#(l1,l2))
        
        
        Following rules are (at-least) weakly oriented:
                    append#(l1,l2) =  [0]                                 
                                   >= [0]                                 
                                   =  c_1(append#1#(l1,l2))               
        
          append#1#(cons(x,xs),l2) =  [0]                                 
                                   >= [0]                                 
                                   =  c_2(append#(xs,l2))                 
        
                      subtrees#(t) =  [3]                                 
                                   >= [3]                                 
                                   =  subtrees#1#(t)                      
        
        subtrees#1#(node(x,t1,t2)) =  [3]                                 
                                   >= [3]                                 
                                   =  subtrees#(t1)                       
        
        subtrees#1#(node(x,t1,t2)) =  [3]                                 
                                   >= [3]                                 
                                   =  subtrees#2#(subtrees(t1),t1,t2,x)   
        
           subtrees#2#(l1,t1,t2,x) =  [3]                                 
                                   >= [3]                                 
                                   =  subtrees#(t2)                       
        
           subtrees#2#(l1,t1,t2,x) =  [3]                                 
                                   >= [3]                                 
                                   =  subtrees#3#(subtrees(t2),l1,t1,t2,x)
        
** Step 4.b:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
        - Weak DPs:
            subtrees#(t) -> subtrees#1#(t)
            subtrees#1#(node(x,t1,t2)) -> subtrees#(t1)
            subtrees#1#(node(x,t1,t2)) -> subtrees#2#(subtrees(t1),t1,t2,x)
            subtrees#2#(l1,t1,t2,x) -> subtrees#(t2)
            subtrees#2#(l1,t1,t2,x) -> subtrees#3#(subtrees(t2),l1,t1,t2,x)
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(subtrees#2) = {1},
            uargs(subtrees#3) = {1},
            uargs(subtrees#2#) = {1},
            uargs(subtrees#3#) = {1},
            uargs(c_1) = {1},
            uargs(c_2) = {1},
            uargs(c_8) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(append) = [1] x2 + [0]         
               p(append#1) = [1] x2 + [0]         
                   p(cons) = [1] x2 + [0]         
                   p(leaf) = [0]                  
                    p(nil) = [0]                  
                   p(node) = [1] x2 + [0]         
               p(subtrees) = [0]                  
             p(subtrees#1) = [0]                  
             p(subtrees#2) = [1] x1 + [0]         
             p(subtrees#3) = [1] x1 + [0]         
                p(append#) = [1] x2 + [0]         
              p(append#1#) = [1] x2 + [5]         
              p(subtrees#) = [0]                  
            p(subtrees#1#) = [0]                  
            p(subtrees#2#) = [1] x1 + [0]         
            p(subtrees#3#) = [1] x1 + [1] x2 + [0]
                    p(c_1) = [1] x1 + [0]         
                    p(c_2) = [1] x1 + [0]         
                    p(c_3) = [0]                  
                    p(c_4) = [0]                  
                    p(c_5) = [0]                  
                    p(c_6) = [0]                  
                    p(c_7) = [0]                  
                    p(c_8) = [1] x1 + [0]         
          
          Following rules are strictly oriented:
          append#1#(cons(x,xs),l2) = [1] l2 + [5]       
                                   > [1] l2 + [0]       
                                   = c_2(append#(xs,l2))
          
          
          Following rules are (at-least) weakly oriented:
                      append#(l1,l2) =  [1] l2 + [0]                        
                                     >= [1] l2 + [5]                        
                                     =  c_1(append#1#(l1,l2))               
          
                        subtrees#(t) =  [0]                                 
                                     >= [0]                                 
                                     =  subtrees#1#(t)                      
          
          subtrees#1#(node(x,t1,t2)) =  [0]                                 
                                     >= [0]                                 
                                     =  subtrees#(t1)                       
          
          subtrees#1#(node(x,t1,t2)) =  [0]                                 
                                     >= [0]                                 
                                     =  subtrees#2#(subtrees(t1),t1,t2,x)   
          
             subtrees#2#(l1,t1,t2,x) =  [1] l1 + [0]                        
                                     >= [0]                                 
                                     =  subtrees#(t2)                       
          
             subtrees#2#(l1,t1,t2,x) =  [1] l1 + [0]                        
                                     >= [1] l1 + [0]                        
                                     =  subtrees#3#(subtrees(t2),l1,t1,t2,x)
          
          subtrees#3#(l2,l1,t1,t2,x) =  [1] l1 + [1] l2 + [0]               
                                     >= [1] l2 + [0]                        
                                     =  c_8(append#(l1,l2))                 
          
                       append(l1,l2) =  [1] l2 + [0]                        
                                     >= [1] l2 + [0]                        
                                     =  append#1(l1,l2)                     
          
             append#1(cons(x,xs),l2) =  [1] l2 + [0]                        
                                     >= [1] l2 + [0]                        
                                     =  cons(x,append(xs,l2))               
          
                  append#1(nil(),l2) =  [1] l2 + [0]                        
                                     >= [1] l2 + [0]                        
                                     =  l2                                  
          
                         subtrees(t) =  [0]                                 
                                     >= [0]                                 
                                     =  subtrees#1(t)                       
          
                  subtrees#1(leaf()) =  [0]                                 
                                     >= [0]                                 
                                     =  nil()                               
          
           subtrees#1(node(x,t1,t2)) =  [0]                                 
                                     >= [0]                                 
                                     =  subtrees#2(subtrees(t1),t1,t2,x)    
          
              subtrees#2(l1,t1,t2,x) =  [1] l1 + [0]                        
                                     >= [0]                                 
                                     =  subtrees#3(subtrees(t2),l1,t1,t2,x) 
          
           subtrees#3(l2,l1,t1,t2,x) =  [1] l2 + [0]                        
                                     >= [1] l2 + [0]                        
                                     =  cons(node(x,t1,t2),append(l1,l2))   
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.b:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
        - Weak DPs:
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            subtrees#(t) -> subtrees#1#(t)
            subtrees#1#(node(x,t1,t2)) -> subtrees#(t1)
            subtrees#1#(node(x,t1,t2)) -> subtrees#2#(subtrees(t1),t1,t2,x)
            subtrees#2#(l1,t1,t2,x) -> subtrees#(t2)
            subtrees#2#(l1,t1,t2,x) -> subtrees#3#(subtrees(t2),l1,t1,t2,x)
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(subtrees#2) = {1},
            uargs(subtrees#3) = {1},
            uargs(subtrees#2#) = {1},
            uargs(subtrees#3#) = {1},
            uargs(c_1) = {1},
            uargs(c_2) = {1},
            uargs(c_8) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                 p(append) = [1] x1 + [1] x2 + [0]         
               p(append#1) = [1] x1 + [1] x2 + [0]         
                   p(cons) = [1] x2 + [1]                  
                   p(leaf) = [2]                           
                    p(nil) = [2]                           
                   p(node) = [1] x2 + [1] x3 + [2]         
               p(subtrees) = [1] x1 + [0]                  
             p(subtrees#1) = [1] x1 + [0]                  
             p(subtrees#2) = [1] x1 + [1] x3 + [2]         
             p(subtrees#3) = [1] x1 + [1] x2 + [1]         
                p(append#) = [1] x1 + [1] x2 + [1]         
              p(append#1#) = [1] x1 + [1] x2 + [0]         
              p(subtrees#) = [5] x1 + [1]                  
            p(subtrees#1#) = [5] x1 + [1]                  
            p(subtrees#2#) = [1] x1 + [5] x3 + [1]         
            p(subtrees#3#) = [1] x1 + [1] x2 + [4] x4 + [1]
                    p(c_1) = [1] x1 + [0]                  
                    p(c_2) = [1] x1 + [0]                  
                    p(c_3) = [1]                           
                    p(c_4) = [1] x1 + [0]                  
                    p(c_5) = [1]                           
                    p(c_6) = [2] x1 + [1]                  
                    p(c_7) = [1] x1 + [1] x2 + [2]         
                    p(c_8) = [1] x1 + [0]                  
          
          Following rules are strictly oriented:
          append#(l1,l2) = [1] l1 + [1] l2 + [1]
                         > [1] l1 + [1] l2 + [0]
                         = c_1(append#1#(l1,l2))
          
          
          Following rules are (at-least) weakly oriented:
            append#1#(cons(x,xs),l2) =  [1] l2 + [1] xs + [1]               
                                     >= [1] l2 + [1] xs + [1]               
                                     =  c_2(append#(xs,l2))                 
          
                        subtrees#(t) =  [5] t + [1]                         
                                     >= [5] t + [1]                         
                                     =  subtrees#1#(t)                      
          
          subtrees#1#(node(x,t1,t2)) =  [5] t1 + [5] t2 + [11]              
                                     >= [5] t1 + [1]                        
                                     =  subtrees#(t1)                       
          
          subtrees#1#(node(x,t1,t2)) =  [5] t1 + [5] t2 + [11]              
                                     >= [1] t1 + [5] t2 + [1]               
                                     =  subtrees#2#(subtrees(t1),t1,t2,x)   
          
             subtrees#2#(l1,t1,t2,x) =  [1] l1 + [5] t2 + [1]               
                                     >= [5] t2 + [1]                        
                                     =  subtrees#(t2)                       
          
             subtrees#2#(l1,t1,t2,x) =  [1] l1 + [5] t2 + [1]               
                                     >= [1] l1 + [5] t2 + [1]               
                                     =  subtrees#3#(subtrees(t2),l1,t1,t2,x)
          
          subtrees#3#(l2,l1,t1,t2,x) =  [1] l1 + [1] l2 + [4] t2 + [1]      
                                     >= [1] l1 + [1] l2 + [1]               
                                     =  c_8(append#(l1,l2))                 
          
                       append(l1,l2) =  [1] l1 + [1] l2 + [0]               
                                     >= [1] l1 + [1] l2 + [0]               
                                     =  append#1(l1,l2)                     
          
             append#1(cons(x,xs),l2) =  [1] l2 + [1] xs + [1]               
                                     >= [1] l2 + [1] xs + [1]               
                                     =  cons(x,append(xs,l2))               
          
                  append#1(nil(),l2) =  [1] l2 + [2]                        
                                     >= [1] l2 + [0]                        
                                     =  l2                                  
          
                         subtrees(t) =  [1] t + [0]                         
                                     >= [1] t + [0]                         
                                     =  subtrees#1(t)                       
          
                  subtrees#1(leaf()) =  [2]                                 
                                     >= [2]                                 
                                     =  nil()                               
          
           subtrees#1(node(x,t1,t2)) =  [1] t1 + [1] t2 + [2]               
                                     >= [1] t1 + [1] t2 + [2]               
                                     =  subtrees#2(subtrees(t1),t1,t2,x)    
          
              subtrees#2(l1,t1,t2,x) =  [1] l1 + [1] t2 + [2]               
                                     >= [1] l1 + [1] t2 + [1]               
                                     =  subtrees#3(subtrees(t2),l1,t1,t2,x) 
          
           subtrees#3(l2,l1,t1,t2,x) =  [1] l1 + [1] l2 + [1]               
                                     >= [1] l1 + [1] l2 + [1]               
                                     =  cons(node(x,t1,t2),append(l1,l2))   
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 4.b:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            append#(l1,l2) -> c_1(append#1#(l1,l2))
            append#1#(cons(x,xs),l2) -> c_2(append#(xs,l2))
            subtrees#(t) -> subtrees#1#(t)
            subtrees#1#(node(x,t1,t2)) -> subtrees#(t1)
            subtrees#1#(node(x,t1,t2)) -> subtrees#2#(subtrees(t1),t1,t2,x)
            subtrees#2#(l1,t1,t2,x) -> subtrees#(t2)
            subtrees#2#(l1,t1,t2,x) -> subtrees#3#(subtrees(t2),l1,t1,t2,x)
            subtrees#3#(l2,l1,t1,t2,x) -> c_8(append#(l1,l2))
        - Weak TRS:
            append(l1,l2) -> append#1(l1,l2)
            append#1(cons(x,xs),l2) -> cons(x,append(xs,l2))
            append#1(nil(),l2) -> l2
            subtrees(t) -> subtrees#1(t)
            subtrees#1(leaf()) -> nil()
            subtrees#1(node(x,t1,t2)) -> subtrees#2(subtrees(t1),t1,t2,x)
            subtrees#2(l1,t1,t2,x) -> subtrees#3(subtrees(t2),l1,t1,t2,x)
            subtrees#3(l2,l1,t1,t2,x) -> cons(node(x,t1,t2),append(l1,l2))
        - Signature:
            {append/2,append#1/2,subtrees/1,subtrees#1/1,subtrees#2/4,subtrees#3/5,append#/2,append#1#/2,subtrees#/1
            ,subtrees#1#/1,subtrees#2#/4,subtrees#3#/5} / {cons/2,leaf/0,nil/0,node/3,c_1/1,c_2/1,c_3/0,c_4/1,c_5/0
            ,c_6/2,c_7/2,c_8/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#,append#1#,subtrees#,subtrees#1#,subtrees#2#
            ,subtrees#3#} and constructors {cons,leaf,nil,node}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

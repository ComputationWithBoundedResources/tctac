WORST_CASE(?,O(n^1))
* Step 1: DependencyPairs WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict TRS:
            f(cons(x,k),l) -> g(k,l,cons(x,k))
            f(empty(),l) -> l
            g(a,b,c) -> f(a,cons(b,c))
        - Signature:
            {f/2,g/3} / {cons/2,empty/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f,g} and constructors {cons,empty}
    + Applied Processor:
        DependencyPairs {dpKind_ = WIDP}
    + Details:
        We add the following weak innermost dependency pairs:
        
        Strict DPs
          f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
          f#(empty(),l) -> c_2()
          g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            f#(empty(),l) -> c_2()
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Strict TRS:
            f(cons(x,k),l) -> g(k,l,cons(x,k))
            f(empty(),l) -> l
            g(a,b,c) -> f(a,cons(b,c))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
          f#(empty(),l) -> c_2()
          g#(a,b,c) -> c_3(f#(a,cons(b,c)))
* Step 3: PredecessorEstimation WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            f#(empty(),l) -> c_2()
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2}
        by application of
          Pre({2}) = {3}.
        Here rules are labelled as follows:
          1: f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
          2: f#(empty(),l) -> c_2()
          3: g#(a,b,c) -> c_3(f#(a,cons(b,c)))
* Step 4: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Weak DPs:
            f#(empty(),l) -> c_2()
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
             -->_1 g#(a,b,c) -> c_3(f#(a,cons(b,c))):2
          
          2:S:g#(a,b,c) -> c_3(f#(a,cons(b,c)))
             -->_1 f#(empty(),l) -> c_2():3
             -->_1 f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k))):1
          
          3:W:f#(empty(),l) -> c_2()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: f#(empty(),l) -> c_2()
* Step 5: PredecessorEstimationCP WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          2: g#(a,b,c) -> c_3(f#(a,cons(b,c)))
          
        Consider the set of all dependency pairs
          1: f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
          2: g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        Processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}induces the complexity certificateTIME (?,O(n^1))
        SPACE(?,?)on application of the dependency pairs
          {2}
        These cover all (indirect) predecessors of dependency pairs
          {1,2}
        their number of applications is equally bounded.
        The dependency pairs are shifted into the weak component.
** Step 5.a:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_3) = {1}
        
        Following symbols are considered usable:
          {f#,g#}
        TcT has computed the following interpretation:
           p(cons) = [1] x2 + [1]         
          p(empty) = [1]                  
              p(f) = [1] x2 + [1]         
              p(g) = [2] x1 + [1] x3 + [1]
             p(f#) = [2] x1 + [0]         
             p(g#) = [2] x1 + [2]         
            p(c_1) = [1] x1 + [0]         
            p(c_2) = [1]                  
            p(c_3) = [1] x1 + [1]         
        
        Following rules are strictly oriented:
        g#(a,b,c) = [2] a + [2]         
                  > [2] a + [1]         
                  = c_3(f#(a,cons(b,c)))
        
        
        Following rules are (at-least) weakly oriented:
        f#(cons(x,k),l) =  [2] k + [2]           
                        >= [2] k + [2]           
                        =  c_1(g#(k,l,cons(x,k)))
        
** Step 5.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Strict DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
        - Weak DPs:
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

** Step 5.b:1: RemoveWeakSuffixes WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
            g#(a,b,c) -> c_3(f#(a,cons(b,c)))
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:W:f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
             -->_1 g#(a,b,c) -> c_3(f#(a,cons(b,c))):2
          
          2:W:g#(a,b,c) -> c_3(f#(a,cons(b,c)))
             -->_1 f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k))):1
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          1: f#(cons(x,k),l) -> c_1(g#(k,l,cons(x,k)))
          2: g#(a,b,c) -> c_3(f#(a,cons(b,c)))
** Step 5.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        
        - Signature:
            {f/2,g/3,f#/2,g#/3} / {cons/2,empty/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {f#,g#} and constructors {cons,empty}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^1))

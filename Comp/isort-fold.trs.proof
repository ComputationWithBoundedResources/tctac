WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
            main(x3) -> fold#3(insert_ord(leq()),x3)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0
            ,insert_ord/1,leq/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1,fold#3,insert_ord#2,leq#2
            ,main} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
          cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
          fold#3#(insert_ord(x2),Nil()) -> c_3()
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                    ,fold#3#(insert_ord(x6),x2))
          insert_ord#2#(leq(),x2,Nil()) -> c_5()
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
          leq#2#(0(),x8) -> c_7()
          leq#2#(S(x12),0()) -> c_8()
          leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
          main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
            fold#3#(insert_ord(x2),Nil()) -> c_3()
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
            insert_ord#2#(leq(),x2,Nil()) -> c_5()
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(0(),x8) -> c_7()
            leq#2#(S(x12),0()) -> c_8()
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
            main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
            main(x3) -> fold#3(insert_ord(leq()),x3)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,3,5,7,8}
        by application of
          Pre({2,3,5,7,8}) = {1,4,6,9,10}.
        Here rules are labelled as follows:
          1: cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
          2: cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
          3: fold#3#(insert_ord(x2),Nil()) -> c_3()
          4: fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                       ,fold#3#(insert_ord(x6),x2))
          5: insert_ord#2#(leq(),x2,Nil()) -> c_5()
          6: insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
          7: leq#2#(0(),x8) -> c_7()
          8: leq#2#(S(x12),0()) -> c_8()
          9: leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
          10: main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
            main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
        - Weak DPs:
            cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
            fold#3#(insert_ord(x2),Nil()) -> c_3()
            insert_ord#2#(leq(),x2,Nil()) -> c_5()
            leq#2#(0(),x8) -> c_7()
            leq#2#(S(x12),0()) -> c_8()
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
            main(x3) -> fold#3(insert_ord(leq()),x3)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
             -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                             ,leq#2#(x6,x4)):3
             -->_1 insert_ord#2#(leq(),x2,Nil()) -> c_5():8
          
          2:S:fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                        ,fold#3#(insert_ord(x6),x2))
             -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                             ,leq#2#(x6,x4)):3
             -->_1 insert_ord#2#(leq(),x2,Nil()) -> c_5():8
             -->_2 fold#3#(insert_ord(x2),Nil()) -> c_3():7
             -->_2 fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                             ,fold#3#(insert_ord(x6),x2)):2
          
          3:S:insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
             -->_2 leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2)):4
             -->_2 leq#2#(S(x12),0()) -> c_8():10
             -->_2 leq#2#(0(),x8) -> c_7():9
             -->_1 cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2():6
             -->_1 cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2)):1
          
          4:S:leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
             -->_1 leq#2#(S(x12),0()) -> c_8():10
             -->_1 leq#2#(0(),x8) -> c_7():9
             -->_1 leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2)):4
          
          5:S:main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
             -->_1 fold#3#(insert_ord(x2),Nil()) -> c_3():7
             -->_1 fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                             ,fold#3#(insert_ord(x6),x2)):2
          
          6:W:cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
             
          
          7:W:fold#3#(insert_ord(x2),Nil()) -> c_3()
             
          
          8:W:insert_ord#2#(leq(),x2,Nil()) -> c_5()
             
          
          9:W:leq#2#(0(),x8) -> c_7()
             
          
          10:W:leq#2#(S(x12),0()) -> c_8()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          7: fold#3#(insert_ord(x2),Nil()) -> c_3()
          8: insert_ord#2#(leq(),x2,Nil()) -> c_5()
          6: cond_insert_ord_x_ys_1#(True(),x3,x2,x1) -> c_2()
          9: leq#2#(0(),x8) -> c_7()
          10: leq#2#(S(x12),0()) -> c_8()
* Step 4: RemoveHeads WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
            main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
            main(x3) -> fold#3(insert_ord(leq()),x3)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
           -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                           ,leq#2#(x6,x4)):3
        
        2:S:fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
           -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                           ,leq#2#(x6,x4)):3
           -->_2 fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                           ,fold#3#(insert_ord(x6),x2)):2
        
        3:S:insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
           -->_2 leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2)):4
           -->_1 cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2)):1
        
        4:S:leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
           -->_1 leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2)):4
        
        5:S:main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3))
           -->_1 fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                           ,fold#3#(insert_ord(x6),x2)):2
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(5,main#(x3) -> c_10(fold#3#(insert_ord(leq()),x3)))]
* Step 5: UsableRules WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
            main(x3) -> fold#3(insert_ord(leq()),x3)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
          cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
          fold#3(insert_ord(x2),Nil()) -> Nil()
          fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
          insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
          insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
          leq#2(0(),x8) -> True()
          leq#2(S(x12),0()) -> False()
          leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                    ,fold#3#(insert_ord(x6),x2))
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
          leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
* Step 6: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                    ,fold#3#(insert_ord(x6),x2))
        and a lower component
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
          leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        Further, following extension rules are added to the lower component.
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                      ,fold#3#(insert_ord(x6),x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                        ,fold#3#(insert_ord(x6),x2))
             -->_2 fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
                                                             ,fold#3#(insert_ord(x6),x2)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(fold#3#(insert_ord(x6),x2))
** Step 6.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(fold#3#(insert_ord(x6),x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(fold#3#(insert_ord(x6),x2))
** Step 6.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(fold#3#(insert_ord(x6),x2))
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_4) = {1}
        
        Following symbols are considered usable:
          {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#,main#}
        TcT has computed the following interpretation:
                                p(0) = [0]                  
                             p(Cons) = [1] x1 + [1] x2 + [5]
                            p(False) = [0]                  
                              p(Nil) = [0]                  
                                p(S) = [1] x1 + [0]         
                             p(True) = [0]                  
           p(cond_insert_ord_x_ys_1) = [0]                  
                           p(fold#3) = [0]                  
                       p(insert_ord) = [1] x1 + [0]         
                     p(insert_ord#2) = [0]                  
                              p(leq) = [0]                  
                            p(leq#2) = [0]                  
                             p(main) = [4]                  
          p(cond_insert_ord_x_ys_1#) = [1] x3 + [1] x4 + [4]
                          p(fold#3#) = [4] x1 + [1] x2 + [0]
                    p(insert_ord#2#) = [1] x2 + [8] x3 + [0]
                           p(leq#2#) = [4]                  
                            p(main#) = [2] x1 + [8]         
                              p(c_1) = [4] x1 + [4]         
                              p(c_2) = [1]                  
                              p(c_3) = [0]                  
                              p(c_4) = [1] x1 + [0]         
                              p(c_5) = [0]                  
                              p(c_6) = [4] x1 + [1] x2 + [8]
                              p(c_7) = [0]                  
                              p(c_8) = [2]                  
                              p(c_9) = [2] x1 + [2]         
                             p(c_10) = [1] x1 + [1]         
        
        Following rules are strictly oriented:
        fold#3#(insert_ord(x6),Cons(x4,x2)) = [1] x2 + [1] x4 + [4] x6 + [5] 
                                            > [1] x2 + [4] x6 + [0]          
                                            = c_4(fold#3#(insert_ord(x6),x2))
        
        
        Following rules are (at-least) weakly oriented:
        
** Step 6.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> c_4(fold#3#(insert_ord(x6),x2))
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        - Weak DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
        and a lower component
          leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        Further, following extension rules are added to the lower component.
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> insert_ord#2#(leq(),x0,x2)
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
          fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> leq#2#(x6,x4)
*** Step 6.b:1.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
        - Weak DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
             -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                             ,leq#2#(x6,x4)):2
          
          2:S:insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2),leq#2#(x6,x4))
             -->_1 cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2)):1
          
          3:W:fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
             -->_1 fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2)):4
             -->_1 fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2):3
          
          4:W:fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
             -->_1 insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
                                                             ,leq#2#(x6,x4)):2
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
*** Step 6.b:1.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
        - Weak DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/1,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(Cons) = {2},
            uargs(cond_insert_ord_x_ys_1) = {1},
            uargs(insert_ord#2) = {3},
            uargs(cond_insert_ord_x_ys_1#) = {1},
            uargs(insert_ord#2#) = {3},
            uargs(c_1) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                                  p(0) = [0]                  
                               p(Cons) = [1] x2 + [0]         
                              p(False) = [0]                  
                                p(Nil) = [0]                  
                                  p(S) = [1] x1 + [0]         
                               p(True) = [0]                  
             p(cond_insert_ord_x_ys_1) = [1] x1 + [1] x4 + [0]
                             p(fold#3) = [0]                  
                         p(insert_ord) = [1] x1 + [1]         
                       p(insert_ord#2) = [1] x3 + [0]         
                                p(leq) = [2]                  
                              p(leq#2) = [0]                  
                               p(main) = [1] x1 + [1]         
            p(cond_insert_ord_x_ys_1#) = [1] x1 + [1] x4 + [0]
                            p(fold#3#) = [2] x1 + [4] x2 + [6]
                      p(insert_ord#2#) = [2] x1 + [1] x3 + [3]
                             p(leq#2#) = [1]                  
                              p(main#) = [2] x1 + [1]         
                                p(c_1) = [1] x1 + [4]         
                                p(c_2) = [0]                  
                                p(c_3) = [2]                  
                                p(c_4) = [1]                  
                                p(c_5) = [0]                  
                                p(c_6) = [1] x1 + [0]         
                                p(c_7) = [0]                  
                                p(c_8) = [0]                  
                                p(c_9) = [2] x1 + [0]         
                               p(c_10) = [1] x1 + [1]         
          
          Following rules are strictly oriented:
          insert_ord#2#(leq(),x6,Cons(x4,x2)) = [1] x2 + [7]                                       
                                              > [1] x2 + [0]                                       
                                              = c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
          
          
          Following rules are (at-least) weakly oriented:
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) =  [1] x2 + [0]                                  
                                                    >= [1] x2 + [11]                                 
                                                    =  c_1(insert_ord#2#(leq(),x0,x2))               
          
                fold#3#(insert_ord(x6),Cons(x4,x2)) =  [4] x2 + [2] x6 + [8]                         
                                                    >= [4] x2 + [2] x6 + [8]                         
                                                    =  fold#3#(insert_ord(x6),x2)                    
          
                fold#3#(insert_ord(x6),Cons(x4,x2)) =  [4] x2 + [2] x6 + [8]                         
                                                    >= [2] x6 + [3]                                  
                                                    =  insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
          
           cond_insert_ord_x_ys_1(False(),x0,x5,x2) =  [1] x2 + [0]                                  
                                                    >= [1] x2 + [0]                                  
                                                    =  Cons(x5,insert_ord#2(leq(),x0,x2))            
          
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) =  [1] x1 + [0]                                  
                                                    >= [1] x1 + [0]                                  
                                                    =  Cons(x3,Cons(x2,x1))                          
          
                       fold#3(insert_ord(x2),Nil()) =  [0]                                           
                                                    >= [0]                                           
                                                    =  Nil()                                         
          
                 fold#3(insert_ord(x6),Cons(x4,x2)) =  [0]                                           
                                                    >= [0]                                           
                                                    =  insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2)) 
          
                       insert_ord#2(leq(),x2,Nil()) =  [0]                                           
                                                    >= [0]                                           
                                                    =  Cons(x2,Nil())                                
          
                 insert_ord#2(leq(),x6,Cons(x4,x2)) =  [1] x2 + [0]                                  
                                                    >= [1] x2 + [0]                                  
                                                    =  cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2) 
          
                                      leq#2(0(),x8) =  [0]                                           
                                                    >= [0]                                           
                                                    =  True()                                        
          
                                  leq#2(S(x12),0()) =  [0]                                           
                                                    >= [0]                                           
                                                    =  False()                                       
          
                                 leq#2(S(x4),S(x2)) =  [0]                                           
                                                    >= [0]                                           
                                                    =  leq#2(x4,x2)                                  
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 6.b:1.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
        - Weak DPs:
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/1,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(Cons) = {2},
            uargs(cond_insert_ord_x_ys_1) = {1},
            uargs(insert_ord#2) = {3},
            uargs(cond_insert_ord_x_ys_1#) = {1},
            uargs(insert_ord#2#) = {3},
            uargs(c_1) = {1},
            uargs(c_6) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                                  p(0) = [0]                  
                               p(Cons) = [1] x2 + [1]         
                              p(False) = [0]                  
                                p(Nil) = [0]                  
                                  p(S) = [1] x1 + [0]         
                               p(True) = [0]                  
             p(cond_insert_ord_x_ys_1) = [1] x1 + [1] x4 + [2]
                             p(fold#3) = [2] x2 + [0]         
                         p(insert_ord) = [0]                  
                       p(insert_ord#2) = [1] x3 + [1]         
                                p(leq) = [0]                  
                              p(leq#2) = [0]                  
                               p(main) = [1] x1 + [0]         
            p(cond_insert_ord_x_ys_1#) = [1] x1 + [1] x4 + [1]
                            p(fold#3#) = [7] x2 + [1]         
                      p(insert_ord#2#) = [1] x3 + [0]         
                             p(leq#2#) = [2] x1 + [0]         
                              p(main#) = [1] x1 + [0]         
                                p(c_1) = [1] x1 + [0]         
                                p(c_2) = [1]                  
                                p(c_3) = [0]                  
                                p(c_4) = [1] x1 + [0]         
                                p(c_5) = [2]                  
                                p(c_6) = [1] x1 + [0]         
                                p(c_7) = [0]                  
                                p(c_8) = [1]                  
                                p(c_9) = [1] x1 + [1]         
                               p(c_10) = [1] x1 + [4]         
          
          Following rules are strictly oriented:
          cond_insert_ord_x_ys_1#(False(),x0,x5,x2) = [1] x2 + [1]                   
                                                    > [1] x2 + [0]                   
                                                    = c_1(insert_ord#2#(leq(),x0,x2))
          
          
          Following rules are (at-least) weakly oriented:
               fold#3#(insert_ord(x6),Cons(x4,x2)) =  [7] x2 + [8]                                       
                                                   >= [7] x2 + [1]                                       
                                                   =  fold#3#(insert_ord(x6),x2)                         
          
               fold#3#(insert_ord(x6),Cons(x4,x2)) =  [7] x2 + [8]                                       
                                                   >= [2] x2 + [0]                                       
                                                   =  insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))     
          
               insert_ord#2#(leq(),x6,Cons(x4,x2)) =  [1] x2 + [1]                                       
                                                   >= [1] x2 + [1]                                       
                                                   =  c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
          
          cond_insert_ord_x_ys_1(False(),x0,x5,x2) =  [1] x2 + [2]                                       
                                                   >= [1] x2 + [2]                                       
                                                   =  Cons(x5,insert_ord#2(leq(),x0,x2))                 
          
           cond_insert_ord_x_ys_1(True(),x3,x2,x1) =  [1] x1 + [2]                                       
                                                   >= [1] x1 + [2]                                       
                                                   =  Cons(x3,Cons(x2,x1))                               
          
                      fold#3(insert_ord(x2),Nil()) =  [0]                                                
                                                   >= [0]                                                
                                                   =  Nil()                                              
          
                fold#3(insert_ord(x6),Cons(x4,x2)) =  [2] x2 + [2]                                       
                                                   >= [2] x2 + [1]                                       
                                                   =  insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))      
          
                      insert_ord#2(leq(),x2,Nil()) =  [1]                                                
                                                   >= [1]                                                
                                                   =  Cons(x2,Nil())                                     
          
                insert_ord#2(leq(),x6,Cons(x4,x2)) =  [1] x2 + [2]                                       
                                                   >= [1] x2 + [2]                                       
                                                   =  cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)      
          
                                     leq#2(0(),x8) =  [0]                                                
                                                   >= [0]                                                
                                                   =  True()                                             
          
                                 leq#2(S(x12),0()) =  [0]                                                
                                                   >= [0]                                                
                                                   =  False()                                            
          
                                leq#2(S(x4),S(x2)) =  [0]                                                
                                                   >= [0]                                                
                                                   =  leq#2(x4,x2)                                       
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 6.b:1.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> c_1(insert_ord#2#(leq(),x0,x2))
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> c_6(cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/1,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 6.b:1.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        - Weak DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> insert_ord#2#(leq(),x0,x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> leq#2#(x6,x4)
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_9) = {1}
        
        Following symbols are considered usable:
          {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#,main#}
        TcT has computed the following interpretation:
                                p(0) = [0]                  
                             p(Cons) = [1] x1 + [1] x2 + [0]
                            p(False) = [0]                  
                              p(Nil) = [3]                  
                                p(S) = [1] x1 + [6]         
                             p(True) = [0]                  
           p(cond_insert_ord_x_ys_1) = [1] x2 + [0]         
                           p(fold#3) = [4]                  
                       p(insert_ord) = [1] x1 + [0]         
                     p(insert_ord#2) = [1] x3 + [5]         
                              p(leq) = [0]                  
                            p(leq#2) = [2] x2 + [0]         
                             p(main) = [1]                  
          p(cond_insert_ord_x_ys_1#) = [2] x2 + [0]         
                          p(fold#3#) = [3] x1 + [3] x2 + [0]
                    p(insert_ord#2#) = [2] x2 + [0]         
                           p(leq#2#) = [2] x1 + [0]         
                            p(main#) = [0]                  
                              p(c_1) = [0]                  
                              p(c_2) = [0]                  
                              p(c_3) = [0]                  
                              p(c_4) = [0]                  
                              p(c_5) = [0]                  
                              p(c_6) = [0]                  
                              p(c_7) = [0]                  
                              p(c_8) = [0]                  
                              p(c_9) = [1] x1 + [7]         
                             p(c_10) = [0]                  
        
        Following rules are strictly oriented:
        leq#2#(S(x4),S(x2)) = [2] x4 + [12]     
                            > [2] x4 + [7]      
                            = c_9(leq#2#(x4,x2))
        
        
        Following rules are (at-least) weakly oriented:
        cond_insert_ord_x_ys_1#(False(),x0,x5,x2) =  [2] x0 + [0]                                  
                                                  >= [2] x0 + [0]                                  
                                                  =  insert_ord#2#(leq(),x0,x2)                    
        
              fold#3#(insert_ord(x6),Cons(x4,x2)) =  [3] x2 + [3] x4 + [3] x6 + [0]                
                                                  >= [3] x2 + [3] x6 + [0]                         
                                                  =  fold#3#(insert_ord(x6),x2)                    
        
              fold#3#(insert_ord(x6),Cons(x4,x2)) =  [3] x2 + [3] x4 + [3] x6 + [0]                
                                                  >= [2] x4 + [0]                                  
                                                  =  insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
        
              insert_ord#2#(leq(),x6,Cons(x4,x2)) =  [2] x6 + [0]                                  
                                                  >= [2] x6 + [0]                                  
                                                  =  cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
        
              insert_ord#2#(leq(),x6,Cons(x4,x2)) =  [2] x6 + [0]                                  
                                                  >= [2] x6 + [0]                                  
                                                  =  leq#2#(x6,x4)                                 
        
*** Step 6.b:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            cond_insert_ord_x_ys_1#(False(),x0,x5,x2) -> insert_ord#2#(leq(),x0,x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> fold#3#(insert_ord(x6),x2)
            fold#3#(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2#(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1#(leq#2(x6,x4),x6,x4,x2)
            insert_ord#2#(leq(),x6,Cons(x4,x2)) -> leq#2#(x6,x4)
            leq#2#(S(x4),S(x2)) -> c_9(leq#2#(x4,x2))
        - Weak TRS:
            cond_insert_ord_x_ys_1(False(),x0,x5,x2) -> Cons(x5,insert_ord#2(leq(),x0,x2))
            cond_insert_ord_x_ys_1(True(),x3,x2,x1) -> Cons(x3,Cons(x2,x1))
            fold#3(insert_ord(x2),Nil()) -> Nil()
            fold#3(insert_ord(x6),Cons(x4,x2)) -> insert_ord#2(x6,x4,fold#3(insert_ord(x6),x2))
            insert_ord#2(leq(),x2,Nil()) -> Cons(x2,Nil())
            insert_ord#2(leq(),x6,Cons(x4,x2)) -> cond_insert_ord_x_ys_1(leq#2(x6,x4),x6,x4,x2)
            leq#2(0(),x8) -> True()
            leq#2(S(x12),0()) -> False()
            leq#2(S(x4),S(x2)) -> leq#2(x4,x2)
        - Signature:
            {cond_insert_ord_x_ys_1/4,fold#3/2,insert_ord#2/3,leq#2/2,main/1,cond_insert_ord_x_ys_1#/4,fold#3#/2
            ,insert_ord#2#/3,leq#2#/2,main#/1} / {0/0,Cons/2,False/0,Nil/0,S/1,True/0,insert_ord/1,leq/0,c_1/1,c_2/0
            ,c_3/0,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {cond_insert_ord_x_ys_1#,fold#3#,insert_ord#2#,leq#2#
            ,main#} and constructors {0,Cons,False,Nil,S,True,insert_ord,leq}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^3))

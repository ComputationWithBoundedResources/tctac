WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1} / {0/0,cons/2,false/0,nil/0,s/1,true/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert,insert,leq,sort} and constructors {0,cons,false
            ,nil,s,true}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
          if'insert#(true(),x,y,ys) -> c_2()
          insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
          insert#(x,nil()) -> c_4()
          leq#(0(),y) -> c_5()
          leq#(s(x),0()) -> c_6()
          leq#(s(x),s(y)) -> c_7(leq#(x,y))
          sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
          sort#(nil()) -> c_9()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            if'insert#(true(),x,y,ys) -> c_2()
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
            insert#(x,nil()) -> c_4()
            leq#(0(),y) -> c_5()
            leq#(s(x),0()) -> c_6()
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
            sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
            sort#(nil()) -> c_9()
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4,5,6,9}
        by application of
          Pre({2,4,5,6,9}) = {1,3,7,8}.
        Here rules are labelled as follows:
          1: if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
          2: if'insert#(true(),x,y,ys) -> c_2()
          3: insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
          4: insert#(x,nil()) -> c_4()
          5: leq#(0(),y) -> c_5()
          6: leq#(s(x),0()) -> c_6()
          7: leq#(s(x),s(y)) -> c_7(leq#(x,y))
          8: sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
          9: sort#(nil()) -> c_9()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
            sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
        - Weak DPs:
            if'insert#(true(),x,y,ys) -> c_2()
            insert#(x,nil()) -> c_4()
            leq#(0(),y) -> c_5()
            leq#(s(x),0()) -> c_6()
            sort#(nil()) -> c_9()
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
             -->_1 insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y)):2
             -->_1 insert#(x,nil()) -> c_4():6
          
          2:S:insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
             -->_2 leq#(s(x),s(y)) -> c_7(leq#(x,y)):3
             -->_2 leq#(s(x),0()) -> c_6():8
             -->_2 leq#(0(),y) -> c_5():7
             -->_1 if'insert#(true(),x,y,ys) -> c_2():5
             -->_1 if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys)):1
          
          3:S:leq#(s(x),s(y)) -> c_7(leq#(x,y))
             -->_1 leq#(s(x),0()) -> c_6():8
             -->_1 leq#(0(),y) -> c_5():7
             -->_1 leq#(s(x),s(y)) -> c_7(leq#(x,y)):3
          
          4:S:sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
             -->_2 sort#(nil()) -> c_9():9
             -->_1 insert#(x,nil()) -> c_4():6
             -->_2 sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs)):4
             -->_1 insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y)):2
          
          5:W:if'insert#(true(),x,y,ys) -> c_2()
             
          
          6:W:insert#(x,nil()) -> c_4()
             
          
          7:W:leq#(0(),y) -> c_5()
             
          
          8:W:leq#(s(x),0()) -> c_6()
             
          
          9:W:sort#(nil()) -> c_9()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          9: sort#(nil()) -> c_9()
          6: insert#(x,nil()) -> c_4()
          5: if'insert#(true(),x,y,ys) -> c_2()
          7: leq#(0(),y) -> c_5()
          8: leq#(s(x),0()) -> c_6()
* Step 4: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
            sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
        and a lower component
          if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
          insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
          leq#(s(x),s(y)) -> c_7(leq#(x,y))
        Further, following extension rules are added to the lower component.
          sort#(cons(x,xs)) -> insert#(x,sort(xs))
          sort#(cons(x,xs)) -> sort#(xs)
** Step 4.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs))
             -->_2 sort#(cons(x,xs)) -> c_8(insert#(x,sort(xs)),sort#(xs)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          sort#(cons(x,xs)) -> c_8(sort#(xs))
** Step 4.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            sort#(cons(x,xs)) -> c_8(sort#(xs))
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/1,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          sort#(cons(x,xs)) -> c_8(sort#(xs))
** Step 4.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            sort#(cons(x,xs)) -> c_8(sort#(xs))
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/1,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_8) = {1}
        
        Following symbols are considered usable:
          {if'insert#,insert#,leq#,sort#}
        TcT has computed the following interpretation:
                   p(0) = [0]                           
                p(cons) = [1] x1 + [1] x2 + [8]         
               p(false) = [0]                           
           p(if'insert) = [4] x1 + [4] x4 + [0]         
              p(insert) = [2] x1 + [8]                  
                 p(leq) = [2] x2 + [2]                  
                 p(nil) = [4]                           
                   p(s) = [0]                           
                p(sort) = [8] x1 + [8]                  
                p(true) = [0]                           
          p(if'insert#) = [1] x1 + [1] x2 + [8] x3 + [4]
             p(insert#) = [2] x1 + [0]                  
                p(leq#) = [1] x1 + [1] x2 + [4]         
               p(sort#) = [1] x1 + [0]                  
                 p(c_1) = [1] x1 + [2]                  
                 p(c_2) = [8]                           
                 p(c_3) = [0]                           
                 p(c_4) = [1]                           
                 p(c_5) = [2]                           
                 p(c_6) = [1]                           
                 p(c_7) = [1] x1 + [8]                  
                 p(c_8) = [1] x1 + [7]                  
                 p(c_9) = [0]                           
        
        Following rules are strictly oriented:
        sort#(cons(x,xs)) = [1] x + [1] xs + [8]
                          > [1] xs + [7]        
                          = c_8(sort#(xs))      
        
        
        Following rules are (at-least) weakly oriented:
        
** Step 4.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            sort#(cons(x,xs)) -> c_8(sort#(xs))
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/1,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 4.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
        - Weak DPs:
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
          insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
          sort#(cons(x,xs)) -> insert#(x,sort(xs))
          sort#(cons(x,xs)) -> sort#(xs)
        and a lower component
          leq#(s(x),s(y)) -> c_7(leq#(x,y))
        Further, following extension rules are added to the lower component.
          if'insert#(false(),x,y,ys) -> insert#(x,ys)
          insert#(x,cons(y,ys)) -> if'insert#(leq(x,y),x,y,ys)
          insert#(x,cons(y,ys)) -> leq#(x,y)
          sort#(cons(x,xs)) -> insert#(x,sort(xs))
          sort#(cons(x,xs)) -> sort#(xs)
*** Step 4.b:1.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
        - Weak DPs:
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
             -->_1 insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y)):2
          
          2:S:insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y))
             -->_1 if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys)):1
          
          3:W:sort#(cons(x,xs)) -> insert#(x,sort(xs))
             -->_1 insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys),leq#(x,y)):2
          
          4:W:sort#(cons(x,xs)) -> sort#(xs)
             -->_1 sort#(cons(x,xs)) -> sort#(xs):4
             -->_1 sort#(cons(x,xs)) -> insert#(x,sort(xs)):3
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys))
*** Step 4.b:1.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys))
        - Weak DPs:
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(if'insert) = {1},
            uargs(insert) = {2},
            uargs(if'insert#) = {1},
            uargs(insert#) = {2},
            uargs(c_1) = {1},
            uargs(c_3) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                     p(0) = [0]                  
                  p(cons) = [1] x2 + [1]         
                 p(false) = [0]                  
             p(if'insert) = [1] x1 + [1] x4 + [2]
                p(insert) = [1] x2 + [1]         
                   p(leq) = [0]                  
                   p(nil) = [2]                  
                     p(s) = [1] x1 + [0]         
                  p(sort) = [1] x1 + [7]         
                  p(true) = [0]                  
            p(if'insert#) = [1] x1 + [1] x4 + [0]
               p(insert#) = [1] x2 + [2]         
                  p(leq#) = [0]                  
                 p(sort#) = [4] x1 + [5]         
                   p(c_1) = [1] x1 + [0]         
                   p(c_2) = [0]                  
                   p(c_3) = [1] x1 + [0]         
                   p(c_4) = [0]                  
                   p(c_5) = [0]                  
                   p(c_6) = [0]                  
                   p(c_7) = [0]                  
                   p(c_8) = [0]                  
                   p(c_9) = [0]                  
          
          Following rules are strictly oriented:
          insert#(x,cons(y,ys)) = [1] ys + [3]                    
                                > [1] ys + [0]                    
                                = c_3(if'insert#(leq(x,y),x,y,ys))
          
          
          Following rules are (at-least) weakly oriented:
          if'insert#(false(),x,y,ys) =  [1] ys + [0]              
                                     >= [1] ys + [2]              
                                     =  c_1(insert#(x,ys))        
          
                   sort#(cons(x,xs)) =  [4] xs + [9]              
                                     >= [1] xs + [9]              
                                     =  insert#(x,sort(xs))       
          
                   sort#(cons(x,xs)) =  [4] xs + [9]              
                                     >= [4] xs + [5]              
                                     =  sort#(xs)                 
          
           if'insert(false(),x,y,ys) =  [1] ys + [2]              
                                     >= [1] ys + [2]              
                                     =  cons(y,insert(x,ys))      
          
            if'insert(true(),x,y,ys) =  [1] ys + [2]              
                                     >= [1] ys + [2]              
                                     =  cons(x,cons(y,ys))        
          
                insert(x,cons(y,ys)) =  [1] ys + [2]              
                                     >= [1] ys + [2]              
                                     =  if'insert(leq(x,y),x,y,ys)
          
                     insert(x,nil()) =  [3]                       
                                     >= [3]                       
                                     =  cons(x,nil())             
          
                          leq(0(),y) =  [0]                       
                                     >= [0]                       
                                     =  true()                    
          
                       leq(s(x),0()) =  [0]                       
                                     >= [0]                       
                                     =  false()                   
          
                      leq(s(x),s(y)) =  [0]                       
                                     >= [0]                       
                                     =  leq(x,y)                  
          
                    sort(cons(x,xs)) =  [1] xs + [8]              
                                     >= [1] xs + [8]              
                                     =  insert(x,sort(xs))        
          
                         sort(nil()) =  [9]                       
                                     >= [2]                       
                                     =  nil()                     
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 4.b:1.a:3: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
        - Weak DPs:
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys))
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(if'insert) = {1},
            uargs(insert) = {2},
            uargs(if'insert#) = {1},
            uargs(insert#) = {2},
            uargs(c_1) = {1},
            uargs(c_3) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                     p(0) = [1]                  
                  p(cons) = [1] x2 + [2]         
                 p(false) = [4]                  
             p(if'insert) = [1] x1 + [1] x4 + [0]
                p(insert) = [1] x2 + [2]         
                   p(leq) = [4]                  
                   p(nil) = [0]                  
                     p(s) = [0]                  
                  p(sort) = [1] x1 + [0]         
                  p(true) = [4]                  
            p(if'insert#) = [1] x1 + [1] x4 + [0]
               p(insert#) = [1] x2 + [3]         
                  p(leq#) = [4] x1 + [1]         
                 p(sort#) = [1] x1 + [1]         
                   p(c_1) = [1] x1 + [0]         
                   p(c_2) = [2]                  
                   p(c_3) = [1] x1 + [0]         
                   p(c_4) = [4]                  
                   p(c_5) = [0]                  
                   p(c_6) = [1]                  
                   p(c_7) = [2] x1 + [0]         
                   p(c_8) = [0]                  
                   p(c_9) = [0]                  
          
          Following rules are strictly oriented:
          if'insert#(false(),x,y,ys) = [1] ys + [4]      
                                     > [1] ys + [3]      
                                     = c_1(insert#(x,ys))
          
          
          Following rules are (at-least) weakly oriented:
              insert#(x,cons(y,ys)) =  [1] ys + [5]                    
                                    >= [1] ys + [4]                    
                                    =  c_3(if'insert#(leq(x,y),x,y,ys))
          
                  sort#(cons(x,xs)) =  [1] xs + [3]                    
                                    >= [1] xs + [3]                    
                                    =  insert#(x,sort(xs))             
          
                  sort#(cons(x,xs)) =  [1] xs + [3]                    
                                    >= [1] xs + [1]                    
                                    =  sort#(xs)                       
          
          if'insert(false(),x,y,ys) =  [1] ys + [4]                    
                                    >= [1] ys + [4]                    
                                    =  cons(y,insert(x,ys))            
          
           if'insert(true(),x,y,ys) =  [1] ys + [4]                    
                                    >= [1] ys + [4]                    
                                    =  cons(x,cons(y,ys))              
          
               insert(x,cons(y,ys)) =  [1] ys + [4]                    
                                    >= [1] ys + [4]                    
                                    =  if'insert(leq(x,y),x,y,ys)      
          
                    insert(x,nil()) =  [2]                             
                                    >= [2]                             
                                    =  cons(x,nil())                   
          
                         leq(0(),y) =  [4]                             
                                    >= [4]                             
                                    =  true()                          
          
                      leq(s(x),0()) =  [4]                             
                                    >= [4]                             
                                    =  false()                         
          
                     leq(s(x),s(y)) =  [4]                             
                                    >= [4]                             
                                    =  leq(x,y)                        
          
                   sort(cons(x,xs)) =  [1] xs + [2]                    
                                    >= [1] xs + [2]                    
                                    =  insert(x,sort(xs))              
          
                        sort(nil()) =  [0]                             
                                    >= [0]                             
                                    =  nil()                           
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 4.b:1.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            if'insert#(false(),x,y,ys) -> c_1(insert#(x,ys))
            insert#(x,cons(y,ys)) -> c_3(if'insert#(leq(x,y),x,y,ys))
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 4.b:1.b:1: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
        - Weak DPs:
            if'insert#(false(),x,y,ys) -> insert#(x,ys)
            insert#(x,cons(y,ys)) -> if'insert#(leq(x,y),x,y,ys)
            insert#(x,cons(y,ys)) -> leq#(x,y)
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(cons) = {2},
            uargs(if'insert) = {1},
            uargs(insert) = {2},
            uargs(if'insert#) = {1},
            uargs(insert#) = {2},
            uargs(c_7) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                     p(0) = [2]                                    
                  p(cons) = [1] x1 + [1] x2 + [2]                  
                 p(false) = [0]                                    
             p(if'insert) = [1] x1 + [4] x2 + [1] x3 + [1] x4 + [5]
                p(insert) = [4] x1 + [1] x2 + [3]                  
                   p(leq) = [0]                                    
                   p(nil) = [1]                                    
                     p(s) = [1] x1 + [5]                           
                  p(sort) = [5] x1 + [5]                           
                  p(true) = [0]                                    
            p(if'insert#) = [1] x1 + [1] x2 + [1] x4 + [1]         
               p(insert#) = [1] x1 + [1] x2 + [1]                  
                  p(leq#) = [1] x1 + [3]                           
                 p(sort#) = [5] x1 + [1]                           
                   p(c_1) = [1] x1 + [4]                           
                   p(c_2) = [1]                                    
                   p(c_3) = [1] x1 + [4] x2 + [2]                  
                   p(c_4) = [1]                                    
                   p(c_5) = [0]                                    
                   p(c_6) = [2]                                    
                   p(c_7) = [1] x1 + [0]                           
                   p(c_8) = [1] x2 + [1]                           
                   p(c_9) = [1]                                    
          
          Following rules are strictly oriented:
          leq#(s(x),s(y)) = [1] x + [8]   
                          > [1] x + [3]   
                          = c_7(leq#(x,y))
          
          
          Following rules are (at-least) weakly oriented:
          if'insert#(false(),x,y,ys) =  [1] x + [1] ys + [1]        
                                     >= [1] x + [1] ys + [1]        
                                     =  insert#(x,ys)               
          
               insert#(x,cons(y,ys)) =  [1] x + [1] y + [1] ys + [3]
                                     >= [1] x + [1] ys + [1]        
                                     =  if'insert#(leq(x,y),x,y,ys) 
          
               insert#(x,cons(y,ys)) =  [1] x + [1] y + [1] ys + [3]
                                     >= [1] x + [3]                 
                                     =  leq#(x,y)                   
          
                   sort#(cons(x,xs)) =  [5] x + [5] xs + [11]       
                                     >= [1] x + [5] xs + [6]        
                                     =  insert#(x,sort(xs))         
          
                   sort#(cons(x,xs)) =  [5] x + [5] xs + [11]       
                                     >= [5] xs + [1]                
                                     =  sort#(xs)                   
          
           if'insert(false(),x,y,ys) =  [4] x + [1] y + [1] ys + [5]
                                     >= [4] x + [1] y + [1] ys + [5]
                                     =  cons(y,insert(x,ys))        
          
            if'insert(true(),x,y,ys) =  [4] x + [1] y + [1] ys + [5]
                                     >= [1] x + [1] y + [1] ys + [4]
                                     =  cons(x,cons(y,ys))          
          
                insert(x,cons(y,ys)) =  [4] x + [1] y + [1] ys + [5]
                                     >= [4] x + [1] y + [1] ys + [5]
                                     =  if'insert(leq(x,y),x,y,ys)  
          
                     insert(x,nil()) =  [4] x + [4]                 
                                     >= [1] x + [3]                 
                                     =  cons(x,nil())               
          
                          leq(0(),y) =  [0]                         
                                     >= [0]                         
                                     =  true()                      
          
                       leq(s(x),0()) =  [0]                         
                                     >= [0]                         
                                     =  false()                     
          
                      leq(s(x),s(y)) =  [0]                         
                                     >= [0]                         
                                     =  leq(x,y)                    
          
                    sort(cons(x,xs)) =  [5] x + [5] xs + [15]       
                                     >= [4] x + [5] xs + [8]        
                                     =  insert(x,sort(xs))          
          
                         sort(nil()) =  [10]                        
                                     >= [1]                         
                                     =  nil()                       
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 4.b:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            if'insert#(false(),x,y,ys) -> insert#(x,ys)
            insert#(x,cons(y,ys)) -> if'insert#(leq(x,y),x,y,ys)
            insert#(x,cons(y,ys)) -> leq#(x,y)
            leq#(s(x),s(y)) -> c_7(leq#(x,y))
            sort#(cons(x,xs)) -> insert#(x,sort(xs))
            sort#(cons(x,xs)) -> sort#(xs)
        - Weak TRS:
            if'insert(false(),x,y,ys) -> cons(y,insert(x,ys))
            if'insert(true(),x,y,ys) -> cons(x,cons(y,ys))
            insert(x,cons(y,ys)) -> if'insert(leq(x,y),x,y,ys)
            insert(x,nil()) -> cons(x,nil())
            leq(0(),y) -> true()
            leq(s(x),0()) -> false()
            leq(s(x),s(y)) -> leq(x,y)
            sort(cons(x,xs)) -> insert(x,sort(xs))
            sort(nil()) -> nil()
        - Signature:
            {if'insert/4,insert/2,leq/2,sort/1,if'insert#/4,insert#/2,leq#/2,sort#/1} / {0/0,cons/2,false/0,nil/0,s/1
            ,true/0,c_1/1,c_2/0,c_3/2,c_4/0,c_5/0,c_6/0,c_7/1,c_8/2,c_9/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {if'insert#,insert#,leq#,sort#} and constructors {0,cons
            ,false,nil,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^3))

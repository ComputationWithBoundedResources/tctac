WORST_CASE(?,O(n^4))
* Step 1: DependencyPairs WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            forrest(graph(N,E)) -> kruskal(sort(E),nil(),partitions(N))
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            kruskal(dd(e,E),F,P) -> kruskal#q(inBlock(e,P),e,E,F,P)
            kruskal(nil(),F,P) -> pair(F,P)
            kruskal#q(false(),e,E,F,P) -> kruskal(E,dd(e,F),join(e,P,nil()))
            kruskal#q(true(),e,E,F,P) -> kruskal(E,F,P)
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and,elem,eq,forrest,inBlock,insert,insert#q,join,join#q
            ,kruskal,kruskal#q,leq,or,partitions,pp,sort,src,trg,wt} and constructors {0,dd,edge,false,graph,nil,pair,s
            ,true}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          and#(false(),false()) -> c_1()
          and#(false(),true()) -> c_2()
          and#(true(),false()) -> c_3()
          and#(true(),true()) -> c_4()
          elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
          elem#(n,nil()) -> c_6()
          eq#(0(),0()) -> c_7()
          eq#(0(),s(m)) -> c_8()
          eq#(s(n),0()) -> c_9()
          eq#(s(n),s(m)) -> c_10(eq#(n,m))
          forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
          inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                     ,and#(elem(src(e),p),elem(trg(e),p))
                                     ,elem#(src(e),p)
                                     ,src#(e)
                                     ,elem#(trg(e),p)
                                     ,trg#(e)
                                     ,inBlock#(e,P))
          inBlock#(e,nil()) -> c_13()
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
          insert#(e,nil()) -> c_15()
          insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
          insert#q#(true(),e,f,E) -> c_17()
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                    ,or#(elem(src(e),p),elem(trg(e),p))
                                    ,elem#(src(e),p)
                                    ,src#(e)
                                    ,elem#(trg(e),p)
                                    ,trg#(e))
          join#(e,nil(),q) -> c_19()
          join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
          join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
          kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
          kruskal#(nil(),F,P) -> c_23()
          kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
          leq#(0(),0()) -> c_26()
          leq#(0(),s(m)) -> c_27()
          leq#(s(n),0()) -> c_28()
          leq#(s(n),s(m)) -> c_29(leq#(n,m))
          or#(false(),false()) -> c_30()
          or#(false(),true()) -> c_31()
          or#(true(),false()) -> c_32()
          or#(true(),true()) -> c_33()
          partitions#(dd(n,N)) -> c_34(partitions#(N))
          partitions#(nil()) -> c_35()
          pp#(dd(n,p),q) -> c_36(pp#(p,q))
          pp#(nil(),q) -> c_37()
          sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
          sort#(nil()) -> c_39()
          src#(edge(n,w,m)) -> c_40()
          trg#(edge(n,w,m)) -> c_41()
          wt#(edge(n,w,m)) -> c_42()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            and#(false(),false()) -> c_1()
            and#(false(),true()) -> c_2()
            and#(true(),false()) -> c_3()
            and#(true(),true()) -> c_4()
            elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
            elem#(n,nil()) -> c_6()
            eq#(0(),0()) -> c_7()
            eq#(0(),s(m)) -> c_8()
            eq#(s(n),0()) -> c_9()
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                       ,and#(elem(src(e),p),elem(trg(e),p))
                                       ,elem#(src(e),p)
                                       ,src#(e)
                                       ,elem#(trg(e),p)
                                       ,trg#(e)
                                       ,inBlock#(e,P))
            inBlock#(e,nil()) -> c_13()
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
            insert#(e,nil()) -> c_15()
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            insert#q#(true(),e,f,E) -> c_17()
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,or#(elem(src(e),p),elem(trg(e),p))
                                      ,elem#(src(e),p)
                                      ,src#(e)
                                      ,elem#(trg(e),p)
                                      ,trg#(e))
            join#(e,nil(),q) -> c_19()
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#(nil(),F,P) -> c_23()
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            leq#(0(),0()) -> c_26()
            leq#(0(),s(m)) -> c_27()
            leq#(s(n),0()) -> c_28()
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            or#(false(),false()) -> c_30()
            or#(false(),true()) -> c_31()
            or#(true(),false()) -> c_32()
            or#(true(),true()) -> c_33()
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            partitions#(nil()) -> c_35()
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            pp#(nil(),q) -> c_37()
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
            sort#(nil()) -> c_39()
            src#(edge(n,w,m)) -> c_40()
            trg#(edge(n,w,m)) -> c_41()
            wt#(edge(n,w,m)) -> c_42()
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            forrest(graph(N,E)) -> kruskal(sort(E),nil(),partitions(N))
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            kruskal(dd(e,E),F,P) -> kruskal#q(inBlock(e,P),e,E,F,P)
            kruskal(nil(),F,P) -> pair(F,P)
            kruskal#q(false(),e,E,F,P) -> kruskal(E,dd(e,F),join(e,P,nil()))
            kruskal#q(true(),e,E,F,P) -> kruskal(E,F,P)
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/3,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/7,c_13/0,c_14/4,c_15/0,c_16/1,c_17/0,c_18/6,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1,2,3,4,6,7,8,9,13,15,17,19,23,26,27,28,30,31,32,33,35,37,39,40,41,42}
        by application of
          Pre({1,2,3,4,6,7,8,9,13,15,17,19,23,26,27,28,30,31,32,33,35,37,39,40,41,42}) = {5,10,11,12,14,16,18,20,21
          ,22,24,25,29,34,36,38}.
        Here rules are labelled as follows:
          1: and#(false(),false()) -> c_1()
          2: and#(false(),true()) -> c_2()
          3: and#(true(),false()) -> c_3()
          4: and#(true(),true()) -> c_4()
          5: elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
          6: elem#(n,nil()) -> c_6()
          7: eq#(0(),0()) -> c_7()
          8: eq#(0(),s(m)) -> c_8()
          9: eq#(s(n),0()) -> c_9()
          10: eq#(s(n),s(m)) -> c_10(eq#(n,m))
          11: forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
          12: inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                         ,and#(elem(src(e),p),elem(trg(e),p))
                                         ,elem#(src(e),p)
                                         ,src#(e)
                                         ,elem#(trg(e),p)
                                         ,trg#(e)
                                         ,inBlock#(e,P))
          13: inBlock#(e,nil()) -> c_13()
          14: insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
          15: insert#(e,nil()) -> c_15()
          16: insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
          17: insert#q#(true(),e,f,E) -> c_17()
          18: join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                        ,or#(elem(src(e),p),elem(trg(e),p))
                                        ,elem#(src(e),p)
                                        ,src#(e)
                                        ,elem#(trg(e),p)
                                        ,trg#(e))
          19: join#(e,nil(),q) -> c_19()
          20: join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
          21: join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
          22: kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
          23: kruskal#(nil(),F,P) -> c_23()
          24: kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
          25: kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
          26: leq#(0(),0()) -> c_26()
          27: leq#(0(),s(m)) -> c_27()
          28: leq#(s(n),0()) -> c_28()
          29: leq#(s(n),s(m)) -> c_29(leq#(n,m))
          30: or#(false(),false()) -> c_30()
          31: or#(false(),true()) -> c_31()
          32: or#(true(),false()) -> c_32()
          33: or#(true(),true()) -> c_33()
          34: partitions#(dd(n,N)) -> c_34(partitions#(N))
          35: partitions#(nil()) -> c_35()
          36: pp#(dd(n,p),q) -> c_36(pp#(p,q))
          37: pp#(nil(),q) -> c_37()
          38: sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
          39: sort#(nil()) -> c_39()
          40: src#(edge(n,w,m)) -> c_40()
          41: trg#(edge(n,w,m)) -> c_41()
          42: wt#(edge(n,w,m)) -> c_42()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                       ,and#(elem(src(e),p),elem(trg(e),p))
                                       ,elem#(src(e),p)
                                       ,src#(e)
                                       ,elem#(trg(e),p)
                                       ,trg#(e)
                                       ,inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,or#(elem(src(e),p),elem(trg(e),p))
                                      ,elem#(src(e),p)
                                      ,src#(e)
                                      ,elem#(trg(e),p)
                                      ,trg#(e))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        - Weak DPs:
            and#(false(),false()) -> c_1()
            and#(false(),true()) -> c_2()
            and#(true(),false()) -> c_3()
            and#(true(),true()) -> c_4()
            elem#(n,nil()) -> c_6()
            eq#(0(),0()) -> c_7()
            eq#(0(),s(m)) -> c_8()
            eq#(s(n),0()) -> c_9()
            inBlock#(e,nil()) -> c_13()
            insert#(e,nil()) -> c_15()
            insert#q#(true(),e,f,E) -> c_17()
            join#(e,nil(),q) -> c_19()
            kruskal#(nil(),F,P) -> c_23()
            leq#(0(),0()) -> c_26()
            leq#(0(),s(m)) -> c_27()
            leq#(s(n),0()) -> c_28()
            or#(false(),false()) -> c_30()
            or#(false(),true()) -> c_31()
            or#(true(),false()) -> c_32()
            or#(true(),true()) -> c_33()
            partitions#(nil()) -> c_35()
            pp#(nil(),q) -> c_37()
            sort#(nil()) -> c_39()
            src#(edge(n,w,m)) -> c_40()
            trg#(edge(n,w,m)) -> c_41()
            wt#(edge(n,w,m)) -> c_42()
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            forrest(graph(N,E)) -> kruskal(sort(E),nil(),partitions(N))
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            kruskal(dd(e,E),F,P) -> kruskal#q(inBlock(e,P),e,E,F,P)
            kruskal(nil(),F,P) -> pair(F,P)
            kruskal#q(false(),e,E,F,P) -> kruskal(E,dd(e,F),join(e,P,nil()))
            kruskal#q(true(),e,E,F,P) -> kruskal(E,F,P)
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/3,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/7,c_13/0,c_14/4,c_15/0,c_16/1,c_17/0,c_18/6,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
             -->_2 eq#(s(n),s(m)) -> c_10(eq#(n,m)):2
             -->_1 or#(true(),true()) -> c_33():36
             -->_1 or#(true(),false()) -> c_32():35
             -->_1 or#(false(),true()) -> c_31():34
             -->_1 or#(false(),false()) -> c_30():33
             -->_2 eq#(s(n),0()) -> c_9():24
             -->_2 eq#(0(),s(m)) -> c_8():23
             -->_2 eq#(0(),0()) -> c_7():22
             -->_3 elem#(n,nil()) -> c_6():21
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          2:S:eq#(s(n),s(m)) -> c_10(eq#(n,m))
             -->_1 eq#(s(n),0()) -> c_9():24
             -->_1 eq#(0(),s(m)) -> c_8():23
             -->_1 eq#(0(),0()) -> c_7():22
             -->_1 eq#(s(n),s(m)) -> c_10(eq#(n,m)):2
          
          3:S:forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):16
             -->_3 partitions#(dd(n,N)) -> c_34(partitions#(N)):14
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
             -->_2 sort#(nil()) -> c_39():39
             -->_3 partitions#(nil()) -> c_35():37
             -->_1 kruskal#(nil(),F,P) -> c_23():29
          
          4:S:inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                         ,and#(elem(src(e),p),elem(trg(e),p))
                                         ,elem#(src(e),p)
                                         ,src#(e)
                                         ,elem#(trg(e),p)
                                         ,trg#(e)
                                         ,inBlock#(e,P))
             -->_6 trg#(edge(n,w,m)) -> c_41():41
             -->_4 src#(edge(n,w,m)) -> c_40():40
             -->_1 or#(true(),true()) -> c_33():36
             -->_1 or#(true(),false()) -> c_32():35
             -->_1 or#(false(),true()) -> c_31():34
             -->_1 or#(false(),false()) -> c_30():33
             -->_7 inBlock#(e,nil()) -> c_13():25
             -->_5 elem#(n,nil()) -> c_6():21
             -->_3 elem#(n,nil()) -> c_6():21
             -->_2 and#(true(),true()) -> c_4():20
             -->_2 and#(true(),false()) -> c_3():19
             -->_2 and#(false(),true()) -> c_2():18
             -->_2 and#(false(),false()) -> c_1():17
             -->_7 inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                              ,and#(elem(src(e),p),elem(trg(e),p))
                                              ,elem#(src(e),p)
                                              ,src#(e)
                                              ,elem#(trg(e),p)
                                              ,trg#(e)
                                              ,inBlock#(e,P)):4
             -->_5 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          5:S:insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
             -->_2 leq#(s(n),s(m)) -> c_29(leq#(n,m)):13
             -->_1 insert#q#(false(),e,f,E) -> c_16(insert#(e,E)):6
             -->_4 wt#(edge(n,w,m)) -> c_42():42
             -->_3 wt#(edge(n,w,m)) -> c_42():42
             -->_2 leq#(s(n),0()) -> c_28():32
             -->_2 leq#(0(),s(m)) -> c_27():31
             -->_2 leq#(0(),0()) -> c_26():30
             -->_1 insert#q#(true(),e,f,E) -> c_17():27
          
          6:S:insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
             -->_1 insert#(e,nil()) -> c_15():26
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f)):5
          
          7:S:join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                        ,or#(elem(src(e),p),elem(trg(e),p))
                                        ,elem#(src(e),p)
                                        ,src#(e)
                                        ,elem#(trg(e),p)
                                        ,trg#(e))
             -->_1 join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q)):9
             -->_1 join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q)):8
             -->_6 trg#(edge(n,w,m)) -> c_41():41
             -->_4 src#(edge(n,w,m)) -> c_40():40
             -->_2 or#(true(),true()) -> c_33():36
             -->_2 or#(true(),false()) -> c_32():35
             -->_2 or#(false(),true()) -> c_31():34
             -->_2 or#(false(),false()) -> c_30():33
             -->_5 elem#(n,nil()) -> c_6():21
             -->_3 elem#(n,nil()) -> c_6():21
             -->_5 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          8:S:join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
             -->_1 join#(e,nil(),q) -> c_19():28
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          9:S:join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
             -->_2 pp#(dd(n,p),q) -> c_36(pp#(p,q)):15
             -->_2 pp#(nil(),q) -> c_37():38
             -->_1 join#(e,nil(),q) -> c_19():28
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          10:S:kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
             -->_1 kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P)):12
             -->_1 kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil())):11
             -->_2 inBlock#(e,nil()) -> c_13():25
             -->_2 inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                              ,and#(elem(src(e),p),elem(trg(e),p))
                                              ,elem#(src(e),p)
                                              ,src#(e)
                                              ,elem#(trg(e),p)
                                              ,trg#(e)
                                              ,inBlock#(e,P)):4
          
          11:S:kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
             -->_1 kruskal#(nil(),F,P) -> c_23():29
             -->_2 join#(e,nil(),q) -> c_19():28
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
             -->_2 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          12:S:kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
             -->_1 kruskal#(nil(),F,P) -> c_23():29
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
          
          13:S:leq#(s(n),s(m)) -> c_29(leq#(n,m))
             -->_1 leq#(s(n),0()) -> c_28():32
             -->_1 leq#(0(),s(m)) -> c_27():31
             -->_1 leq#(0(),0()) -> c_26():30
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):13
          
          14:S:partitions#(dd(n,N)) -> c_34(partitions#(N))
             -->_1 partitions#(nil()) -> c_35():37
             -->_1 partitions#(dd(n,N)) -> c_34(partitions#(N)):14
          
          15:S:pp#(dd(n,p),q) -> c_36(pp#(p,q))
             -->_1 pp#(nil(),q) -> c_37():38
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):15
          
          16:S:sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
             -->_2 sort#(nil()) -> c_39():39
             -->_1 insert#(e,nil()) -> c_15():26
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):16
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f)):5
          
          17:W:and#(false(),false()) -> c_1()
             
          
          18:W:and#(false(),true()) -> c_2()
             
          
          19:W:and#(true(),false()) -> c_3()
             
          
          20:W:and#(true(),true()) -> c_4()
             
          
          21:W:elem#(n,nil()) -> c_6()
             
          
          22:W:eq#(0(),0()) -> c_7()
             
          
          23:W:eq#(0(),s(m)) -> c_8()
             
          
          24:W:eq#(s(n),0()) -> c_9()
             
          
          25:W:inBlock#(e,nil()) -> c_13()
             
          
          26:W:insert#(e,nil()) -> c_15()
             
          
          27:W:insert#q#(true(),e,f,E) -> c_17()
             
          
          28:W:join#(e,nil(),q) -> c_19()
             
          
          29:W:kruskal#(nil(),F,P) -> c_23()
             
          
          30:W:leq#(0(),0()) -> c_26()
             
          
          31:W:leq#(0(),s(m)) -> c_27()
             
          
          32:W:leq#(s(n),0()) -> c_28()
             
          
          33:W:or#(false(),false()) -> c_30()
             
          
          34:W:or#(false(),true()) -> c_31()
             
          
          35:W:or#(true(),false()) -> c_32()
             
          
          36:W:or#(true(),true()) -> c_33()
             
          
          37:W:partitions#(nil()) -> c_35()
             
          
          38:W:pp#(nil(),q) -> c_37()
             
          
          39:W:sort#(nil()) -> c_39()
             
          
          40:W:src#(edge(n,w,m)) -> c_40()
             
          
          41:W:trg#(edge(n,w,m)) -> c_41()
             
          
          42:W:wt#(edge(n,w,m)) -> c_42()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          17: and#(false(),false()) -> c_1()
          18: and#(false(),true()) -> c_2()
          19: and#(true(),false()) -> c_3()
          20: and#(true(),true()) -> c_4()
          25: inBlock#(e,nil()) -> c_13()
          40: src#(edge(n,w,m)) -> c_40()
          41: trg#(edge(n,w,m)) -> c_41()
          38: pp#(nil(),q) -> c_37()
          28: join#(e,nil(),q) -> c_19()
          29: kruskal#(nil(),F,P) -> c_23()
          37: partitions#(nil()) -> c_35()
          27: insert#q#(true(),e,f,E) -> c_17()
          42: wt#(edge(n,w,m)) -> c_42()
          30: leq#(0(),0()) -> c_26()
          31: leq#(0(),s(m)) -> c_27()
          32: leq#(s(n),0()) -> c_28()
          26: insert#(e,nil()) -> c_15()
          39: sort#(nil()) -> c_39()
          21: elem#(n,nil()) -> c_6()
          33: or#(false(),false()) -> c_30()
          34: or#(false(),true()) -> c_31()
          35: or#(true(),false()) -> c_32()
          36: or#(true(),true()) -> c_33()
          22: eq#(0(),0()) -> c_7()
          23: eq#(0(),s(m)) -> c_8()
          24: eq#(s(n),0()) -> c_9()
* Step 4: SimplifyRHS WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                       ,and#(elem(src(e),p),elem(trg(e),p))
                                       ,elem#(src(e),p)
                                       ,src#(e)
                                       ,elem#(trg(e),p)
                                       ,trg#(e)
                                       ,inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,or#(elem(src(e),p),elem(trg(e),p))
                                      ,elem#(src(e),p)
                                      ,src#(e)
                                      ,elem#(trg(e),p)
                                      ,trg#(e))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            forrest(graph(N,E)) -> kruskal(sort(E),nil(),partitions(N))
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            kruskal(dd(e,E),F,P) -> kruskal#q(inBlock(e,P),e,E,F,P)
            kruskal(nil(),F,P) -> pair(F,P)
            kruskal#q(false(),e,E,F,P) -> kruskal(E,dd(e,F),join(e,P,nil()))
            kruskal#q(true(),e,E,F,P) -> kruskal(E,F,P)
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/3,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/7,c_13/0,c_14/4,c_15/0,c_16/1,c_17/0,c_18/6,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p))
             -->_2 eq#(s(n),s(m)) -> c_10(eq#(n,m)):2
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          2:S:eq#(s(n),s(m)) -> c_10(eq#(n,m))
             -->_1 eq#(s(n),s(m)) -> c_10(eq#(n,m)):2
          
          3:S:forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):16
             -->_3 partitions#(dd(n,N)) -> c_34(partitions#(N)):14
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
          
          4:S:inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                         ,and#(elem(src(e),p),elem(trg(e),p))
                                         ,elem#(src(e),p)
                                         ,src#(e)
                                         ,elem#(trg(e),p)
                                         ,trg#(e)
                                         ,inBlock#(e,P))
             -->_7 inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                              ,and#(elem(src(e),p),elem(trg(e),p))
                                              ,elem#(src(e),p)
                                              ,src#(e)
                                              ,elem#(trg(e),p)
                                              ,trg#(e)
                                              ,inBlock#(e,P)):4
             -->_5 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          5:S:insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f))
             -->_2 leq#(s(n),s(m)) -> c_29(leq#(n,m)):13
             -->_1 insert#q#(false(),e,f,E) -> c_16(insert#(e,E)):6
          
          6:S:insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f)):5
          
          7:S:join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                        ,or#(elem(src(e),p),elem(trg(e),p))
                                        ,elem#(src(e),p)
                                        ,src#(e)
                                        ,elem#(trg(e),p)
                                        ,trg#(e))
             -->_1 join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q)):9
             -->_1 join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q)):8
             -->_5 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
             -->_3 elem#(n,dd(m,p)) -> c_5(or#(eq(n,m),elem(n,p)),eq#(n,m),elem#(n,p)):1
          
          8:S:join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          9:S:join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
             -->_2 pp#(dd(n,p),q) -> c_36(pp#(p,q)):15
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          10:S:kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
             -->_1 kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P)):12
             -->_1 kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil())):11
             -->_2 inBlock#(e,dd(p,P)) -> c_12(or#(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
                                              ,and#(elem(src(e),p),elem(trg(e),p))
                                              ,elem#(src(e),p)
                                              ,src#(e)
                                              ,elem#(trg(e),p)
                                              ,trg#(e)
                                              ,inBlock#(e,P)):4
          
          11:S:kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
             -->_2 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,or#(elem(src(e),p),elem(trg(e),p))
                                             ,elem#(src(e),p)
                                             ,src#(e)
                                             ,elem#(trg(e),p)
                                             ,trg#(e)):7
          
          12:S:kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):10
          
          13:S:leq#(s(n),s(m)) -> c_29(leq#(n,m))
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):13
          
          14:S:partitions#(dd(n,N)) -> c_34(partitions#(N))
             -->_1 partitions#(dd(n,N)) -> c_34(partitions#(N)):14
          
          15:S:pp#(dd(n,p),q) -> c_36(pp#(p,q))
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):15
          
          16:S:sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):16
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)),wt#(e),wt#(f)):5
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
          inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                    ,elem#(src(e),p)
                                    ,elem#(trg(e),p))
* Step 5: UsableRules WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,elem#(src(e),p)
                                      ,elem#(trg(e),p))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            forrest(graph(N,E)) -> kruskal(sort(E),nil(),partitions(N))
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            kruskal(dd(e,E),F,P) -> kruskal#q(inBlock(e,P),e,E,F,P)
            kruskal(nil(),F,P) -> pair(F,P)
            kruskal#q(false(),e,E,F,P) -> kruskal(E,dd(e,F),join(e,P,nil()))
            kruskal#q(true(),e,E,F,P) -> kruskal(E,F,P)
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          and(false(),false()) -> false()
          and(false(),true()) -> false()
          and(true(),false()) -> false()
          and(true(),true()) -> true()
          elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
          elem(n,nil()) -> false()
          eq(0(),0()) -> true()
          eq(0(),s(m)) -> false()
          eq(s(n),0()) -> false()
          eq(s(n),s(m)) -> eq(n,m)
          inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
          inBlock(e,nil()) -> false()
          insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
          insert(e,nil()) -> dd(e,nil())
          insert#q(false(),e,f,E) -> dd(f,insert(e,E))
          insert#q(true(),e,f,E) -> dd(e,dd(f,E))
          join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
          join(e,nil(),q) -> dd(q,nil())
          join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
          join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
          leq(0(),0()) -> true()
          leq(0(),s(m)) -> true()
          leq(s(n),0()) -> false()
          leq(s(n),s(m)) -> leq(n,m)
          or(false(),false()) -> false()
          or(false(),true()) -> true()
          or(true(),false()) -> true()
          or(true(),true()) -> true()
          partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
          partitions(nil()) -> nil()
          pp(dd(n,p),q) -> dd(n,pp(p,q))
          pp(nil(),q) -> q
          sort(dd(e,E)) -> insert(e,sort(E))
          sort(nil()) -> nil()
          src(edge(n,w,m)) -> n
          trg(edge(n,w,m)) -> m
          wt(edge(n,w,m)) -> w
          elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
          eq#(s(n),s(m)) -> c_10(eq#(n,m))
          forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
          inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
          insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                    ,elem#(src(e),p)
                                    ,elem#(trg(e),p))
          join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
          join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
          kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
          kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
          leq#(s(n),s(m)) -> c_29(leq#(n,m))
          partitions#(dd(n,N)) -> c_34(partitions#(N))
          pp#(dd(n,p),q) -> c_36(pp#(p,q))
          sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
* Step 6: DecomposeDG WORST_CASE(?,O(n^4))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,elem#(src(e),p)
                                      ,elem#(trg(e),p))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
          kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
          kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
          partitions#(dd(n,N)) -> c_34(partitions#(N))
          sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        and a lower component
          elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
          eq#(s(n),s(m)) -> c_10(eq#(n,m))
          inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
          insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                    ,elem#(src(e),p)
                                    ,elem#(trg(e),p))
          join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
          join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
          leq#(s(n),s(m)) -> c_29(leq#(n,m))
          pp#(dd(n,p),q) -> c_36(pp#(p,q))
        Further, following extension rules are added to the lower component.
          forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
          forrest#(graph(N,E)) -> partitions#(N)
          forrest#(graph(N,E)) -> sort#(E)
          kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
          kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
          kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
          kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
          partitions#(dd(n,N)) -> partitions#(N)
          sort#(dd(e,E)) -> insert#(e,sort(E))
          sort#(dd(e,E)) -> sort#(E)
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):6
             -->_3 partitions#(dd(n,N)) -> c_34(partitions#(N)):5
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):2
          
          2:S:kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P))
             -->_1 kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P)):4
             -->_1 kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil())):3
          
          3:S:kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())),join#(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):2
          
          4:S:kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
             -->_1 kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P),inBlock#(e,P)):2
          
          5:S:partitions#(dd(n,N)) -> c_34(partitions#(N))
             -->_1 partitions#(dd(n,N)) -> c_34(partitions#(N)):5
          
          6:S:sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E))
             -->_2 sort#(dd(e,E)) -> c_38(insert#(e,sort(E)),sort#(E)):6
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
          kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
          sort#(dd(e,E)) -> c_38(sort#(E))
** Step 6.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_11) = {1,2,3},
          uargs(c_22) = {1},
          uargs(c_24) = {1},
          uargs(c_25) = {1},
          uargs(c_34) = {1},
          uargs(c_38) = {1}
        
        Following symbols are considered usable:
          {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#
          ,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [3]                           
                  p(and) = [4] x2 + [0]                  
                   p(dd) = [1]                           
                 p(edge) = [1] x2 + [1] x3 + [0]         
                 p(elem) = [2] x2 + [0]                  
                   p(eq) = [5] x2 + [0]                  
                p(false) = [0]                           
              p(forrest) = [0]                           
                p(graph) = [1] x1 + [1] x2 + [3]         
              p(inBlock) = [0]                           
               p(insert) = [0]                           
             p(insert#q) = [0]                           
                 p(join) = [4] x2 + [0]                  
               p(join#q) = [3]                           
              p(kruskal) = [0]                           
            p(kruskal#q) = [0]                           
                  p(leq) = [0]                           
                  p(nil) = [0]                           
                   p(or) = [0]                           
                 p(pair) = [1] x1 + [1] x2 + [0]         
           p(partitions) = [0]                           
                   p(pp) = [0]                           
                    p(s) = [3]                           
                 p(sort) = [3]                           
                  p(src) = [0]                           
                  p(trg) = [0]                           
                 p(true) = [2]                           
                   p(wt) = [0]                           
                 p(and#) = [0]                           
                p(elem#) = [4] x1 + [4] x2 + [0]         
                  p(eq#) = [0]                           
             p(forrest#) = [3] x1 + [1]                  
             p(inBlock#) = [0]                           
              p(insert#) = [0]                           
            p(insert#q#) = [0]                           
                p(join#) = [0]                           
              p(join#q#) = [0]                           
             p(kruskal#) = [0]                           
           p(kruskal#q#) = [0]                           
                 p(leq#) = [0]                           
                  p(or#) = [1] x1 + [0]                  
          p(partitions#) = [0]                           
                  p(pp#) = [1] x1 + [4]                  
                p(sort#) = [0]                           
                 p(src#) = [0]                           
                 p(trg#) = [0]                           
                  p(wt#) = [0]                           
                  p(c_1) = [0]                           
                  p(c_2) = [0]                           
                  p(c_3) = [0]                           
                  p(c_4) = [0]                           
                  p(c_5) = [0]                           
                  p(c_6) = [0]                           
                  p(c_7) = [0]                           
                  p(c_8) = [0]                           
                  p(c_9) = [0]                           
                 p(c_10) = [0]                           
                 p(c_11) = [1] x1 + [4] x2 + [1] x3 + [6]
                 p(c_12) = [4] x1 + [0]                  
                 p(c_13) = [0]                           
                 p(c_14) = [0]                           
                 p(c_15) = [0]                           
                 p(c_16) = [0]                           
                 p(c_17) = [0]                           
                 p(c_18) = [0]                           
                 p(c_19) = [0]                           
                 p(c_20) = [0]                           
                 p(c_21) = [0]                           
                 p(c_22) = [4] x1 + [0]                  
                 p(c_23) = [0]                           
                 p(c_24) = [1] x1 + [0]                  
                 p(c_25) = [4] x1 + [0]                  
                 p(c_26) = [0]                           
                 p(c_27) = [0]                           
                 p(c_28) = [0]                           
                 p(c_29) = [0]                           
                 p(c_30) = [0]                           
                 p(c_31) = [0]                           
                 p(c_32) = [0]                           
                 p(c_33) = [0]                           
                 p(c_34) = [2] x1 + [0]                  
                 p(c_35) = [0]                           
                 p(c_36) = [0]                           
                 p(c_37) = [0]                           
                 p(c_38) = [1] x1 + [0]                  
                 p(c_39) = [0]                           
                 p(c_40) = [0]                           
                 p(c_41) = [1]                           
                 p(c_42) = [0]                           
        
        Following rules are strictly oriented:
        forrest#(graph(N,E)) = [3] E + [3] N + [10]                                               
                             > [6]                                                                
                             = c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        
        
        Following rules are (at-least) weakly oriented:
              kruskal#(dd(e,E),F,P) =  [0]                                      
                                    >= [0]                                      
                                    =  c_22(kruskal#q#(inBlock(e,P),e,E,F,P))   
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                      
                                    >= [0]                                      
                                    =  c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
        
         kruskal#q#(true(),e,E,F,P) =  [0]                                      
                                    >= [0]                                      
                                    =  c_25(kruskal#(E,F,P))                    
        
               partitions#(dd(n,N)) =  [0]                                      
                                    >= [0]                                      
                                    =  c_34(partitions#(N))                     
        
                     sort#(dd(e,E)) =  [0]                                      
                                    >= [0]                                      
                                    =  c_38(sort#(E))                           
        
** Step 6.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_11) = {1,2,3},
          uargs(c_22) = {1},
          uargs(c_24) = {1},
          uargs(c_25) = {1},
          uargs(c_34) = {1},
          uargs(c_38) = {1}
        
        Following symbols are considered usable:
          {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#
          ,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [1] x2 + [7]                  
                   p(dd) = [1] x2 + [7]                  
                 p(edge) = [1] x1 + [1] x2 + [1] x3 + [0]
                 p(elem) = [0]                           
                   p(eq) = [0]                           
                p(false) = [0]                           
              p(forrest) = [0]                           
                p(graph) = [1] x1 + [1]                  
              p(inBlock) = [0]                           
               p(insert) = [0]                           
             p(insert#q) = [0]                           
                 p(join) = [2] x3 + [0]                  
               p(join#q) = [0]                           
              p(kruskal) = [0]                           
            p(kruskal#q) = [0]                           
                  p(leq) = [1] x1 + [0]                  
                  p(nil) = [0]                           
                   p(or) = [2] x1 + [1] x2 + [0]         
                 p(pair) = [1] x1 + [1] x2 + [0]         
           p(partitions) = [0]                           
                   p(pp) = [0]                           
                    p(s) = [1] x1 + [0]                  
                 p(sort) = [0]                           
                  p(src) = [0]                           
                  p(trg) = [0]                           
                 p(true) = [4]                           
                   p(wt) = [3]                           
                 p(and#) = [0]                           
                p(elem#) = [0]                           
                  p(eq#) = [0]                           
             p(forrest#) = [4] x1 + [5]                  
             p(inBlock#) = [0]                           
              p(insert#) = [0]                           
            p(insert#q#) = [0]                           
                p(join#) = [0]                           
              p(join#q#) = [0]                           
             p(kruskal#) = [0]                           
           p(kruskal#q#) = [0]                           
                 p(leq#) = [0]                           
                  p(or#) = [0]                           
          p(partitions#) = [1] x1 + [1]                  
                  p(pp#) = [0]                           
                p(sort#) = [0]                           
                 p(src#) = [0]                           
                 p(trg#) = [0]                           
                  p(wt#) = [0]                           
                  p(c_1) = [0]                           
                  p(c_2) = [0]                           
                  p(c_3) = [0]                           
                  p(c_4) = [0]                           
                  p(c_5) = [0]                           
                  p(c_6) = [0]                           
                  p(c_7) = [0]                           
                  p(c_8) = [0]                           
                  p(c_9) = [0]                           
                 p(c_10) = [1] x1 + [0]                  
                 p(c_11) = [2] x1 + [1] x2 + [4] x3 + [5]
                 p(c_12) = [0]                           
                 p(c_13) = [0]                           
                 p(c_14) = [0]                           
                 p(c_15) = [0]                           
                 p(c_16) = [2]                           
                 p(c_17) = [4]                           
                 p(c_18) = [2] x3 + [1]                  
                 p(c_19) = [4]                           
                 p(c_20) = [4]                           
                 p(c_21) = [1] x1 + [0]                  
                 p(c_22) = [4] x1 + [0]                  
                 p(c_23) = [0]                           
                 p(c_24) = [1] x1 + [0]                  
                 p(c_25) = [4] x1 + [0]                  
                 p(c_26) = [0]                           
                 p(c_27) = [0]                           
                 p(c_28) = [2]                           
                 p(c_29) = [1] x1 + [1]                  
                 p(c_30) = [1]                           
                 p(c_31) = [0]                           
                 p(c_32) = [2]                           
                 p(c_33) = [0]                           
                 p(c_34) = [1] x1 + [0]                  
                 p(c_35) = [0]                           
                 p(c_36) = [0]                           
                 p(c_37) = [1]                           
                 p(c_38) = [4] x1 + [0]                  
                 p(c_39) = [1]                           
                 p(c_40) = [1]                           
                 p(c_41) = [1]                           
                 p(c_42) = [0]                           
        
        Following rules are strictly oriented:
        partitions#(dd(n,N)) = [1] N + [8]         
                             > [1] N + [1]         
                             = c_34(partitions#(N))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [4] N + [9]                                                        
                                    >= [4] N + [9]                                                        
                                    =  c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        
              kruskal#(dd(e,E),F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_22(kruskal#q#(inBlock(e,P),e,E,F,P))                             
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_24(kruskal#(E,dd(e,F),join(e,P,nil())))                          
        
         kruskal#q#(true(),e,E,F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_25(kruskal#(E,F,P))                                              
        
                     sort#(dd(e,E)) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_38(sort#(E))                                                     
        
** Step 6.a:4: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_11) = {1,2,3},
          uargs(c_22) = {1},
          uargs(c_24) = {1},
          uargs(c_25) = {1},
          uargs(c_34) = {1},
          uargs(c_38) = {1}
        
        Following symbols are considered usable:
          {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#
          ,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                                    
                  p(and) = [6] x1 + [1]                           
                   p(dd) = [1] x2 + [4]                           
                 p(edge) = [1] x1 + [2]                           
                 p(elem) = [1] x1 + [1]                           
                   p(eq) = [0]                                    
                p(false) = [0]                                    
              p(forrest) = [2] x1 + [0]                           
                p(graph) = [1] x1 + [1] x2 + [2]                  
              p(inBlock) = [4] x1 + [0]                           
               p(insert) = [1] x2 + [0]                           
             p(insert#q) = [4] x2 + [6]                           
                 p(join) = [1] x2 + [5] x3 + [5]                  
               p(join#q) = [1] x1 + [7]                           
              p(kruskal) = [1] x1 + [2] x2 + [2]                  
            p(kruskal#q) = [1] x3 + [4] x4 + [2]                  
                  p(leq) = [1] x1 + [1] x2 + [2]                  
                  p(nil) = [1]                                    
                   p(or) = [2] x2 + [0]                           
                 p(pair) = [1] x2 + [1]                           
           p(partitions) = [6]                                    
                   p(pp) = [3] x1 + [0]                           
                    p(s) = [1] x1 + [0]                           
                 p(sort) = [3]                                    
                  p(src) = [0]                                    
                  p(trg) = [5] x1 + [2]                           
                 p(true) = [0]                                    
                   p(wt) = [1] x1 + [1]                           
                 p(and#) = [4] x1 + [4] x2 + [1]                  
                p(elem#) = [1] x1 + [1] x2 + [1]                  
                  p(eq#) = [1] x2 + [2]                           
             p(forrest#) = [4] x1 + [4]                           
             p(inBlock#) = [0]                                    
              p(insert#) = [1] x1 + [1]                           
            p(insert#q#) = [2] x2 + [2] x3 + [4] x4 + [0]         
                p(join#) = [1] x1 + [4] x2 + [0]                  
              p(join#q#) = [1] x1 + [1] x2 + [2] x3 + [1] x5 + [1]
             p(kruskal#) = [0]                                    
           p(kruskal#q#) = [0]                                    
                 p(leq#) = [1] x2 + [4]                           
                  p(or#) = [4] x2 + [1]                           
          p(partitions#) = [2] x1 + [1]                           
                  p(pp#) = [2] x1 + [0]                           
                p(sort#) = [2] x1 + [0]                           
                 p(src#) = [1]                                    
                 p(trg#) = [1]                                    
                  p(wt#) = [0]                                    
                  p(c_1) = [4]                                    
                  p(c_2) = [1]                                    
                  p(c_3) = [0]                                    
                  p(c_4) = [0]                                    
                  p(c_5) = [1] x2 + [0]                           
                  p(c_6) = [0]                                    
                  p(c_7) = [1]                                    
                  p(c_8) = [0]                                    
                  p(c_9) = [1]                                    
                 p(c_10) = [0]                                    
                 p(c_11) = [2] x1 + [1] x2 + [2] x3 + [0]         
                 p(c_12) = [4] x2 + [1] x3 + [0]                  
                 p(c_13) = [0]                                    
                 p(c_14) = [4] x2 + [0]                           
                 p(c_15) = [1]                                    
                 p(c_16) = [1] x1 + [2]                           
                 p(c_17) = [1]                                    
                 p(c_18) = [4] x1 + [1] x2 + [2]                  
                 p(c_19) = [1]                                    
                 p(c_20) = [0]                                    
                 p(c_21) = [1] x2 + [0]                           
                 p(c_22) = [2] x1 + [0]                           
                 p(c_23) = [1]                                    
                 p(c_24) = [2] x1 + [0]                           
                 p(c_25) = [2] x1 + [0]                           
                 p(c_26) = [1]                                    
                 p(c_27) = [0]                                    
                 p(c_28) = [0]                                    
                 p(c_29) = [1] x1 + [4]                           
                 p(c_30) = [0]                                    
                 p(c_31) = [0]                                    
                 p(c_32) = [0]                                    
                 p(c_33) = [2]                                    
                 p(c_34) = [1] x1 + [0]                           
                 p(c_35) = [1]                                    
                 p(c_36) = [1] x1 + [0]                           
                 p(c_37) = [1]                                    
                 p(c_38) = [1] x1 + [7]                           
                 p(c_39) = [0]                                    
                 p(c_40) = [0]                                    
                 p(c_41) = [1]                                    
                 p(c_42) = [1]                                    
        
        Following rules are strictly oriented:
        sort#(dd(e,E)) = [2] E + [8]   
                       > [2] E + [7]   
                       = c_38(sort#(E))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [4] E + [4] N + [12]                                               
                                    >= [2] E + [4] N + [2]                                                
                                    =  c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        
              kruskal#(dd(e,E),F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_22(kruskal#q#(inBlock(e,P),e,E,F,P))                             
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_24(kruskal#(E,dd(e,F),join(e,P,nil())))                          
        
         kruskal#q#(true(),e,E,F,P) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_25(kruskal#(E,F,P))                                              
        
               partitions#(dd(n,N)) =  [2] N + [9]                                                        
                                    >= [2] N + [1]                                                        
                                    =  c_34(partitions#(N))                                               
        
** Step 6.a:5: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
        - Weak DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_11) = {1,2,3},
          uargs(c_22) = {1},
          uargs(c_24) = {1},
          uargs(c_25) = {1},
          uargs(c_34) = {1},
          uargs(c_38) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#
          ,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [1]                                    
                  p(and) = [2] x2 + [1]                           
                   p(dd) = [1] x2 + [2]                           
                 p(edge) = [1] x1 + [1] x2 + [1] x3 + [0]         
                 p(elem) = [2] x2 + [7]                           
                   p(eq) = [0]                                    
                p(false) = [0]                                    
              p(forrest) = [0]                                    
                p(graph) = [1] x2 + [0]                           
              p(inBlock) = [0]                                    
               p(insert) = [1] x2 + [2]                           
             p(insert#q) = [1] x4 + [4]                           
                 p(join) = [2] x1 + [2] x3 + [0]                  
               p(join#q) = [0]                                    
              p(kruskal) = [2] x1 + [1] x2 + [1]                  
            p(kruskal#q) = [4] x1 + [2] x3 + [1] x4 + [2] x5 + [0]
                  p(leq) = [1] x1 + [1] x2 + [5]                  
                  p(nil) = [4]                                    
                   p(or) = [0]                                    
                 p(pair) = [1]                                    
           p(partitions) = [0]                                    
                   p(pp) = [0]                                    
                    p(s) = [0]                                    
                 p(sort) = [1] x1 + [0]                           
                  p(src) = [0]                                    
                  p(trg) = [0]                                    
                 p(true) = [0]                                    
                   p(wt) = [1] x1 + [1]                           
                 p(and#) = [0]                                    
                p(elem#) = [4] x2 + [1]                           
                  p(eq#) = [1] x1 + [0]                           
             p(forrest#) = [6] x1 + [7]                           
             p(inBlock#) = [0]                                    
              p(insert#) = [1] x1 + [4] x2 + [0]                  
            p(insert#q#) = [4] x2 + [4] x4 + [2]                  
                p(join#) = [1] x2 + [4] x3 + [1]                  
              p(join#q#) = [4] x1 + [2] x4 + [1] x5 + [0]         
             p(kruskal#) = [4] x1 + [0]                           
           p(kruskal#q#) = [4] x3 + [0]                           
                 p(leq#) = [1] x2 + [0]                           
                  p(or#) = [4]                                    
          p(partitions#) = [0]                                    
                  p(pp#) = [1] x1 + [1] x2 + [1]                  
                p(sort#) = [1] x1 + [0]                           
                 p(src#) = [0]                                    
                 p(trg#) = [1] x1 + [4]                           
                  p(wt#) = [1] x1 + [4]                           
                  p(c_1) = [0]                                    
                  p(c_2) = [1]                                    
                  p(c_3) = [0]                                    
                  p(c_4) = [0]                                    
                  p(c_5) = [1] x1 + [0]                           
                  p(c_6) = [0]                                    
                  p(c_7) = [1]                                    
                  p(c_8) = [1]                                    
                  p(c_9) = [1]                                    
                 p(c_10) = [1] x1 + [0]                           
                 p(c_11) = [1] x1 + [2] x2 + [4] x3 + [0]         
                 p(c_12) = [1] x1 + [1] x2 + [1] x3 + [0]         
                 p(c_13) = [0]                                    
                 p(c_14) = [4] x2 + [0]                           
                 p(c_15) = [0]                                    
                 p(c_16) = [1] x1 + [0]                           
                 p(c_17) = [0]                                    
                 p(c_18) = [4] x1 + [1] x2 + [4] x3 + [0]         
                 p(c_19) = [1]                                    
                 p(c_20) = [1] x1 + [1]                           
                 p(c_21) = [1] x1 + [0]                           
                 p(c_22) = [1] x1 + [7]                           
                 p(c_23) = [0]                                    
                 p(c_24) = [1] x1 + [0]                           
                 p(c_25) = [1] x1 + [0]                           
                 p(c_26) = [1]                                    
                 p(c_27) = [0]                                    
                 p(c_28) = [1]                                    
                 p(c_29) = [2]                                    
                 p(c_30) = [1]                                    
                 p(c_31) = [0]                                    
                 p(c_32) = [0]                                    
                 p(c_33) = [2]                                    
                 p(c_34) = [4] x1 + [0]                           
                 p(c_35) = [0]                                    
                 p(c_36) = [0]                                    
                 p(c_37) = [4]                                    
                 p(c_38) = [1] x1 + [2]                           
                 p(c_39) = [1]                                    
                 p(c_40) = [4]                                    
                 p(c_41) = [4]                                    
                 p(c_42) = [1]                                    
        
        Following rules are strictly oriented:
        kruskal#(dd(e,E),F,P) = [4] E + [8]                           
                              > [4] E + [7]                           
                              = c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [6] E + [7]                                                        
                                    >= [6] E + [0]                                                        
                                    =  c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        
        kruskal#q#(false(),e,E,F,P) =  [4] E + [0]                                                        
                                    >= [4] E + [0]                                                        
                                    =  c_24(kruskal#(E,dd(e,F),join(e,P,nil())))                          
        
         kruskal#q#(true(),e,E,F,P) =  [4] E + [0]                                                        
                                    >= [4] E + [0]                                                        
                                    =  c_25(kruskal#(E,F,P))                                              
        
               partitions#(dd(n,N)) =  [0]                                                                
                                    >= [0]                                                                
                                    =  c_34(partitions#(N))                                               
        
                     sort#(dd(e,E)) =  [1] E + [2]                                                        
                                    >= [1] E + [2]                                                        
                                    =  c_38(sort#(E))                                                     
        
                  insert(e,dd(f,E)) =  [1] E + [4]                                                        
                                    >= [1] E + [4]                                                        
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                                   
        
                    insert(e,nil()) =  [6]                                                                
                                    >= [6]                                                                
                                    =  dd(e,nil())                                                        
        
            insert#q(false(),e,f,E) =  [1] E + [4]                                                        
                                    >= [1] E + [4]                                                        
                                    =  dd(f,insert(e,E))                                                  
        
             insert#q(true(),e,f,E) =  [1] E + [4]                                                        
                                    >= [1] E + [4]                                                        
                                    =  dd(e,dd(f,E))                                                      
        
                      sort(dd(e,E)) =  [1] E + [2]                                                        
                                    >= [1] E + [2]                                                        
                                    =  insert(e,sort(E))                                                  
        
                        sort(nil()) =  [4]                                                                
                                    >= [4]                                                                
                                    =  nil()                                                              
        
** Step 6.a:6: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
        - Weak DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_11) = {1,2,3},
          uargs(c_22) = {1},
          uargs(c_24) = {1},
          uargs(c_25) = {1},
          uargs(c_34) = {1},
          uargs(c_38) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#
          ,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [1] x2 + [1]                  
                   p(dd) = [1] x2 + [2]                  
                 p(edge) = [1] x1 + [1] x2 + [0]         
                 p(elem) = [1] x1 + [4] x2 + [0]         
                   p(eq) = [7] x1 + [7] x2 + [4]         
                p(false) = [0]                           
              p(forrest) = [1] x1 + [1]                  
                p(graph) = [1] x1 + [1] x2 + [0]         
              p(inBlock) = [0]                           
               p(insert) = [1] x2 + [2]                  
             p(insert#q) = [1] x4 + [4]                  
                 p(join) = [1] x1 + [4] x3 + [0]         
               p(join#q) = [1] x2 + [1] x3 + [1] x5 + [1]
              p(kruskal) = [1] x2 + [0]                  
            p(kruskal#q) = [1] x1 + [4] x4 + [2] x5 + [1]
                  p(leq) = [5] x1 + [2]                  
                  p(nil) = [0]                           
                   p(or) = [2] x1 + [0]                  
                 p(pair) = [1] x2 + [4]                  
           p(partitions) = [2] x1 + [2]                  
                   p(pp) = [0]                           
                    p(s) = [0]                           
                 p(sort) = [1] x1 + [0]                  
                  p(src) = [0]                           
                  p(trg) = [5]                           
                 p(true) = [0]                           
                   p(wt) = [2] x1 + [0]                  
                 p(and#) = [2] x2 + [4]                  
                p(elem#) = [4] x1 + [1] x2 + [0]         
                  p(eq#) = [2] x2 + [0]                  
             p(forrest#) = [4] x1 + [0]                  
             p(inBlock#) = [1]                           
              p(insert#) = [4] x1 + [1]                  
            p(insert#q#) = [1] x1 + [1] x4 + [1]         
                p(join#) = [1] x2 + [1] x3 + [1]         
              p(join#q#) = [1] x3 + [2] x4 + [1] x5 + [1]
             p(kruskal#) = [4] x1 + [0]                  
           p(kruskal#q#) = [4] x3 + [1]                  
                 p(leq#) = [4] x2 + [0]                  
                  p(or#) = [4]                           
          p(partitions#) = [4] x1 + [0]                  
                  p(pp#) = [1] x1 + [4]                  
                p(sort#) = [0]                           
                 p(src#) = [1]                           
                 p(trg#) = [4]                           
                  p(wt#) = [1]                           
                  p(c_1) = [1]                           
                  p(c_2) = [0]                           
                  p(c_3) = [0]                           
                  p(c_4) = [0]                           
                  p(c_5) = [1] x1 + [1]                  
                  p(c_6) = [4]                           
                  p(c_7) = [4]                           
                  p(c_8) = [1]                           
                  p(c_9) = [1]                           
                 p(c_10) = [1] x1 + [0]                  
                 p(c_11) = [1] x1 + [4] x2 + [1] x3 + [0]
                 p(c_12) = [4] x1 + [1] x2 + [4]         
                 p(c_13) = [2]                           
                 p(c_14) = [4] x1 + [4]                  
                 p(c_15) = [2]                           
                 p(c_16) = [2] x1 + [0]                  
                 p(c_17) = [1]                           
                 p(c_18) = [1] x1 + [1] x2 + [4] x3 + [2]
                 p(c_19) = [0]                           
                 p(c_20) = [1]                           
                 p(c_21) = [0]                           
                 p(c_22) = [1] x1 + [7]                  
                 p(c_23) = [4]                           
                 p(c_24) = [1] x1 + [0]                  
                 p(c_25) = [1] x1 + [0]                  
                 p(c_26) = [0]                           
                 p(c_27) = [0]                           
                 p(c_28) = [0]                           
                 p(c_29) = [1] x1 + [1]                  
                 p(c_30) = [1]                           
                 p(c_31) = [1]                           
                 p(c_32) = [1]                           
                 p(c_33) = [4]                           
                 p(c_34) = [1] x1 + [5]                  
                 p(c_35) = [2]                           
                 p(c_36) = [0]                           
                 p(c_37) = [4]                           
                 p(c_38) = [2] x1 + [0]                  
                 p(c_39) = [1]                           
                 p(c_40) = [1]                           
                 p(c_41) = [0]                           
                 p(c_42) = [1]                           
        
        Following rules are strictly oriented:
        kruskal#q#(false(),e,E,F,P) = [4] E + [1]                              
                                    > [4] E + [0]                              
                                    = c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
        
         kruskal#q#(true(),e,E,F,P) = [4] E + [1]                              
                                    > [4] E + [0]                              
                                    = c_25(kruskal#(E,F,P))                    
        
        
        Following rules are (at-least) weakly oriented:
           forrest#(graph(N,E)) =  [4] E + [4] N + [0]                                                
                                >= [4] E + [4] N + [0]                                                
                                =  c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
        
          kruskal#(dd(e,E),F,P) =  [4] E + [8]                                                        
                                >= [4] E + [8]                                                        
                                =  c_22(kruskal#q#(inBlock(e,P),e,E,F,P))                             
        
           partitions#(dd(n,N)) =  [4] N + [8]                                                        
                                >= [4] N + [5]                                                        
                                =  c_34(partitions#(N))                                               
        
                 sort#(dd(e,E)) =  [0]                                                                
                                >= [0]                                                                
                                =  c_38(sort#(E))                                                     
        
              insert(e,dd(f,E)) =  [1] E + [4]                                                        
                                >= [1] E + [4]                                                        
                                =  insert#q(leq(wt(e),wt(f)),e,f,E)                                   
        
                insert(e,nil()) =  [2]                                                                
                                >= [2]                                                                
                                =  dd(e,nil())                                                        
        
        insert#q(false(),e,f,E) =  [1] E + [4]                                                        
                                >= [1] E + [4]                                                        
                                =  dd(f,insert(e,E))                                                  
        
         insert#q(true(),e,f,E) =  [1] E + [4]                                                        
                                >= [1] E + [4]                                                        
                                =  dd(e,dd(f,E))                                                      
        
                  sort(dd(e,E)) =  [1] E + [2]                                                        
                                >= [1] E + [2]                                                        
                                =  insert(e,sort(E))                                                  
        
                    sort(nil()) =  [0]                                                                
                                >= [0]                                                                
                                =  nil()                                                              
        
** Step 6.a:7: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            forrest#(graph(N,E)) -> c_11(kruskal#(sort(E),nil(),partitions(N)),sort#(E),partitions#(N))
            kruskal#(dd(e,E),F,P) -> c_22(kruskal#q#(inBlock(e,P),e,E,F,P))
            kruskal#q#(false(),e,E,F,P) -> c_24(kruskal#(E,dd(e,F),join(e,P,nil())))
            kruskal#q#(true(),e,E,F,P) -> c_25(kruskal#(E,F,P))
            partitions#(dd(n,N)) -> c_34(partitions#(N))
            sort#(dd(e,E)) -> c_38(sort#(E))
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/1
            ,c_23/0,c_24/1,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/1,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,elem#(src(e),p)
                                      ,elem#(trg(e),p))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> partitions#(N)
            forrest#(graph(N,E)) -> sort#(E)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            partitions#(dd(n,N)) -> partitions#(N)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
          forrest#(graph(N,E)) -> partitions#(N)
          forrest#(graph(N,E)) -> sort#(E)
          inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
          insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                    ,elem#(src(e),p)
                                    ,elem#(trg(e),p))
          join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
          join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
          kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
          kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
          kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
          kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
          partitions#(dd(n,N)) -> partitions#(N)
          sort#(dd(e,E)) -> insert#(e,sort(E))
          sort#(dd(e,E)) -> sort#(E)
        and a lower component
          elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
          eq#(s(n),s(m)) -> c_10(eq#(n,m))
          leq#(s(n),s(m)) -> c_29(leq#(n,m))
          pp#(dd(n,p),q) -> c_36(pp#(p,q))
        Further, following extension rules are added to the lower component.
          forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
          forrest#(graph(N,E)) -> partitions#(N)
          forrest#(graph(N,E)) -> sort#(E)
          inBlock#(e,dd(p,P)) -> elem#(src(e),p)
          inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
          inBlock#(e,dd(p,P)) -> inBlock#(e,P)
          insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
          insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
          insert#q#(false(),e,f,E) -> insert#(e,E)
          join#(e,dd(p,P),q) -> elem#(src(e),p)
          join#(e,dd(p,P),q) -> elem#(trg(e),p)
          join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
          join#q#(false(),e,p,P,q) -> join#(e,P,q)
          join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
          join#q#(true(),e,p,P,q) -> pp#(p,q)
          kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
          kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
          kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
          kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
          partitions#(dd(n,N)) -> partitions#(N)
          sort#(dd(e,E)) -> insert#(e,sort(E))
          sort#(dd(e,E)) -> sort#(E)
*** Step 6.b:1.a:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,elem#(src(e),p)
                                      ,elem#(trg(e),p))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> partitions#(N)
            forrest#(graph(N,E)) -> sort#(E)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            partitions#(dd(n,N)) -> partitions#(N)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
             -->_3 inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P)):1
          
          2:S:insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
             -->_1 insert#q#(false(),e,f,E) -> c_16(insert#(e,E)):3
          
          3:S:insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f))):2
          
          4:S:join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                        ,elem#(src(e),p)
                                        ,elem#(trg(e),p))
             -->_1 join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q)):6
             -->_1 join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q)):5
          
          5:S:join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          6:S:join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          7:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          8:W:forrest#(graph(N,E)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):15
          
          9:W:forrest#(graph(N,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):17
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):16
          
          10:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P)):1
          
          11:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
             -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):14
             -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):13
             -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):12
          
          12:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          13:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          14:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          15:W:partitions#(dd(n,N)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):15
          
          16:W:sort#(dd(e,E)) -> insert#(e,sort(E))
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f))):2
          
          17:W:sort#(dd(e,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):17
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):16
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          8: forrest#(graph(N,E)) -> partitions#(N)
          15: partitions#(dd(n,N)) -> partitions#(N)
*** Step 6.b:1.a:2: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                      ,elem#(src(e),p)
                                      ,elem#(trg(e),p))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> sort#(E)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P))
             -->_3 inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P)):1
          
          2:S:insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f)))
             -->_1 insert#q#(false(),e,f,E) -> c_16(insert#(e,E)):3
          
          3:S:insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f))):2
          
          4:S:join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                        ,elem#(src(e),p)
                                        ,elem#(trg(e),p))
             -->_1 join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q)):6
             -->_1 join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q)):5
          
          5:S:join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          6:S:join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)),pp#(p,q))
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          7:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          9:W:forrest#(graph(N,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):17
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):16
          
          10:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> c_12(elem#(src(e),p),elem#(trg(e),p),inBlock#(e,P)):1
          
          11:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
             -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):14
             -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):13
             -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):12
          
          12:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
             -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
                                             ,elem#(src(e),p)
                                             ,elem#(trg(e),p)):4
          
          13:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          14:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):11
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):10
          
          16:W:sort#(dd(e,E)) -> insert#(e,sort(E))
             -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E),leq#(wt(e),wt(f))):2
          
          17:W:sort#(dd(e,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):17
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):16
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
          insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
          join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
          join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
*** Step 6.b:1.a:3: RemoveHeads WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> sort#(E)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
           -->_1 inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P)):1
        
        2:S:insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
           -->_1 insert#q#(false(),e,f,E) -> c_16(insert#(e,E)):3
        
        3:S:insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
           -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E)):2
        
        4:S:join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
           -->_1 join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q))):6
           -->_1 join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q)):5
        
        5:S:join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
           -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)):4
        
        6:S:join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
           -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)):4
        
        7:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):10
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):9
        
        8:W:forrest#(graph(N,E)) -> sort#(E)
           -->_1 sort#(dd(e,E)) -> sort#(E):15
           -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):14
        
        9:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
           -->_1 inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P)):1
        
        10:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
           -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):13
           -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):12
           -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):11
        
        11:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
           -->_1 join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)):4
        
        12:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):10
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):9
        
        13:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):10
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):9
        
        14:W:sort#(dd(e,E)) -> insert#(e,sort(E))
           -->_1 insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E)):2
        
        15:W:sort#(dd(e,E)) -> sort#(E)
           -->_1 sort#(dd(e,E)) -> sort#(E):15
           -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):14
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(8,forrest#(graph(N,E)) -> sort#(E))]
*** Step 6.b:1.a:4: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_12) = {1},
          uargs(c_14) = {1},
          uargs(c_16) = {1},
          uargs(c_18) = {1},
          uargs(c_20) = {1},
          uargs(c_21) = {1}
        
        Following symbols are considered usable:
          {inBlock,insert,insert#q,join,join#q,or,partitions,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#
          ,join#,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                                    
                  p(and) = [3] x2 + [0]                           
                   p(dd) = [1] x2 + [2]                           
                 p(edge) = [7]                                    
                 p(elem) = [0]                                    
                   p(eq) = [0]                                    
                p(false) = [4]                                    
              p(forrest) = [0]                                    
                p(graph) = [1] x1 + [1] x2 + [2]                  
              p(inBlock) = [4]                                    
               p(insert) = [1] x2 + [2]                           
             p(insert#q) = [1] x4 + [4]                           
                 p(join) = [1] x2 + [2]                           
               p(join#q) = [1] x4 + [4]                           
              p(kruskal) = [2] x1 + [4] x2 + [4]                  
            p(kruskal#q) = [4] x1 + [4] x2 + [1] x3 + [2] x5 + [0]
                  p(leq) = [4] x1 + [0]                           
                  p(nil) = [0]                                    
                   p(or) = [4]                                    
                 p(pair) = [0]                                    
           p(partitions) = [1] x1 + [2]                           
                   p(pp) = [2] x1 + [0]                           
                    p(s) = [0]                                    
                 p(sort) = [1] x1 + [0]                           
                  p(src) = [1] x1 + [0]                           
                  p(trg) = [2] x1 + [0]                           
                 p(true) = [3]                                    
                   p(wt) = [1] x1 + [2]                           
                 p(and#) = [0]                                    
                p(elem#) = [4] x1 + [1]                           
                  p(eq#) = [1]                                    
             p(forrest#) = [4] x1 + [5]                           
             p(inBlock#) = [4] x2 + [0]                           
              p(insert#) = [0]                                    
            p(insert#q#) = [0]                                    
                p(join#) = [0]                                    
              p(join#q#) = [0]                                    
             p(kruskal#) = [4] x1 + [4] x3 + [0]                  
           p(kruskal#q#) = [1] x1 + [4] x3 + [4] x5 + [4]         
                 p(leq#) = [1] x2 + [4]                           
                  p(or#) = [1] x2 + [0]                           
          p(partitions#) = [1] x1 + [1]                           
                  p(pp#) = [4] x2 + [1]                           
                p(sort#) = [4] x1 + [1]                           
                 p(src#) = [1] x1 + [0]                           
                 p(trg#) = [1]                                    
                  p(wt#) = [4]                                    
                  p(c_1) = [1]                                    
                  p(c_2) = [2]                                    
                  p(c_3) = [0]                                    
                  p(c_4) = [0]                                    
                  p(c_5) = [4] x1 + [1]                           
                  p(c_6) = [0]                                    
                  p(c_7) = [0]                                    
                  p(c_8) = [1]                                    
                  p(c_9) = [1]                                    
                 p(c_10) = [4] x1 + [0]                           
                 p(c_11) = [4] x1 + [4] x3 + [1]                  
                 p(c_12) = [1] x1 + [7]                           
                 p(c_13) = [0]                                    
                 p(c_14) = [4] x1 + [0]                           
                 p(c_15) = [0]                                    
                 p(c_16) = [4] x1 + [0]                           
                 p(c_17) = [4]                                    
                 p(c_18) = [2] x1 + [0]                           
                 p(c_19) = [0]                                    
                 p(c_20) = [4] x1 + [0]                           
                 p(c_21) = [4] x1 + [0]                           
                 p(c_22) = [1]                                    
                 p(c_23) = [1]                                    
                 p(c_24) = [1] x1 + [0]                           
                 p(c_25) = [1] x1 + [1]                           
                 p(c_26) = [1]                                    
                 p(c_27) = [4]                                    
                 p(c_28) = [1]                                    
                 p(c_29) = [2] x1 + [1]                           
                 p(c_30) = [1]                                    
                 p(c_31) = [0]                                    
                 p(c_32) = [4]                                    
                 p(c_33) = [0]                                    
                 p(c_34) = [4]                                    
                 p(c_35) = [0]                                    
                 p(c_36) = [4] x1 + [1]                           
                 p(c_37) = [4]                                    
                 p(c_38) = [4] x1 + [2]                           
                 p(c_39) = [2]                                    
                 p(c_40) = [0]                                    
                 p(c_41) = [1]                                    
                 p(c_42) = [0]                                    
        
        Following rules are strictly oriented:
        inBlock#(e,dd(p,P)) = [4] P + [8]        
                            > [4] P + [7]        
                            = c_12(inBlock#(e,P))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [4] E + [4] N + [13]                                    
                                    >= [4] E + [4] N + [8]                                     
                                    =  kruskal#(sort(E),nil(),partitions(N))                   
        
                 insert#(e,dd(f,E)) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))                 
        
           insert#q#(false(),e,f,E) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_16(insert#(e,E))                                      
        
                 join#(e,dd(p,P),q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
        
           join#q#(false(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_20(join#(e,P,q))                                      
        
            join#q#(true(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_21(join#(e,P,pp(p,q)))                                
        
              kruskal#(dd(e,E),F,P) =  [4] E + [4] P + [8]                                     
                                    >= [4] P + [0]                                             
                                    =  inBlock#(e,P)                                           
        
              kruskal#(dd(e,E),F,P) =  [4] E + [4] P + [8]                                     
                                    >= [4] E + [4] P + [8]                                     
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                        
        
        kruskal#q#(false(),e,E,F,P) =  [4] E + [4] P + [8]                                     
                                    >= [0]                                                     
                                    =  join#(e,P,nil())                                        
        
        kruskal#q#(false(),e,E,F,P) =  [4] E + [4] P + [8]                                     
                                    >= [4] E + [4] P + [8]                                     
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))                     
        
         kruskal#q#(true(),e,E,F,P) =  [4] E + [4] P + [7]                                     
                                    >= [4] E + [4] P + [0]                                     
                                    =  kruskal#(E,F,P)                                         
        
                     sort#(dd(e,E)) =  [4] E + [9]                                             
                                    >= [0]                                                     
                                    =  insert#(e,sort(E))                                      
        
                     sort#(dd(e,E)) =  [4] E + [9]                                             
                                    >= [4] E + [1]                                             
                                    =  sort#(E)                                                
        
                 inBlock(e,dd(p,P)) =  [4]                                                     
                                    >= [4]                                                     
                                    =  or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))     
        
                   inBlock(e,nil()) =  [4]                                                     
                                    >= [4]                                                     
                                    =  false()                                                 
        
                  insert(e,dd(f,E)) =  [1] E + [4]                                             
                                    >= [1] E + [4]                                             
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                        
        
                    insert(e,nil()) =  [2]                                                     
                                    >= [2]                                                     
                                    =  dd(e,nil())                                             
        
            insert#q(false(),e,f,E) =  [1] E + [4]                                             
                                    >= [1] E + [4]                                             
                                    =  dd(f,insert(e,E))                                       
        
             insert#q(true(),e,f,E) =  [1] E + [4]                                             
                                    >= [1] E + [4]                                             
                                    =  dd(e,dd(f,E))                                           
        
                  join(e,dd(p,P),q) =  [1] P + [4]                                             
                                    >= [1] P + [4]                                             
                                    =  join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)       
        
                    join(e,nil(),q) =  [2]                                                     
                                    >= [2]                                                     
                                    =  dd(q,nil())                                             
        
            join#q(false(),e,p,P,q) =  [1] P + [4]                                             
                                    >= [1] P + [4]                                             
                                    =  dd(p,join(e,P,q))                                       
        
             join#q(true(),e,p,P,q) =  [1] P + [4]                                             
                                    >= [1] P + [2]                                             
                                    =  join(e,P,pp(p,q))                                       
        
                or(false(),false()) =  [4]                                                     
                                    >= [4]                                                     
                                    =  false()                                                 
        
                 or(false(),true()) =  [4]                                                     
                                    >= [3]                                                     
                                    =  true()                                                  
        
                 or(true(),false()) =  [4]                                                     
                                    >= [3]                                                     
                                    =  true()                                                  
        
                  or(true(),true()) =  [4]                                                     
                                    >= [3]                                                     
                                    =  true()                                                  
        
                partitions(dd(n,N)) =  [1] N + [4]                                             
                                    >= [1] N + [4]                                             
                                    =  dd(dd(n,nil()),partitions(N))                           
        
                  partitions(nil()) =  [2]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
                      sort(dd(e,E)) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  insert(e,sort(E))                                       
        
                        sort(nil()) =  [0]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
*** Step 6.b:1.a:5: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_12) = {1},
          uargs(c_14) = {1},
          uargs(c_16) = {1},
          uargs(c_18) = {1},
          uargs(c_20) = {1},
          uargs(c_21) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#
          ,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [3]                           
                   p(dd) = [1] x2 + [1]                  
                 p(edge) = [1] x1 + [1] x3 + [1]         
                 p(elem) = [1] x1 + [3] x2 + [0]         
                   p(eq) = [3] x1 + [7] x2 + [3]         
                p(false) = [0]                           
              p(forrest) = [2]                           
                p(graph) = [1] x1 + [1] x2 + [0]         
              p(inBlock) = [6] x1 + [0]                  
               p(insert) = [1] x2 + [1]                  
             p(insert#q) = [1] x4 + [2]                  
                 p(join) = [0]                           
               p(join#q) = [2] x2 + [0]                  
              p(kruskal) = [0]                           
            p(kruskal#q) = [1] x2 + [1] x4 + [1] x5 + [0]
                  p(leq) = [0]                           
                  p(nil) = [0]                           
                   p(or) = [2] x1 + [2] x2 + [0]         
                 p(pair) = [1] x1 + [0]                  
           p(partitions) = [2] x1 + [4]                  
                   p(pp) = [2]                           
                    p(s) = [1] x1 + [0]                  
                 p(sort) = [2] x1 + [1]                  
                  p(src) = [4] x1 + [0]                  
                  p(trg) = [2] x1 + [7]                  
                 p(true) = [0]                           
                   p(wt) = [0]                           
                 p(and#) = [1] x1 + [1] x2 + [0]         
                p(elem#) = [1]                           
                  p(eq#) = [4] x1 + [2]                  
             p(forrest#) = [2] x1 + [6]                  
             p(inBlock#) = [0]                           
              p(insert#) = [1] x2 + [0]                  
            p(insert#q#) = [1] x4 + [0]                  
                p(join#) = [0]                           
              p(join#q#) = [0]                           
             p(kruskal#) = [2]                           
           p(kruskal#q#) = [2]                           
                 p(leq#) = [1] x1 + [2] x2 + [1]         
                  p(or#) = [1]                           
          p(partitions#) = [2]                           
                  p(pp#) = [4] x1 + [1] x2 + [0]         
                p(sort#) = [3] x1 + [0]                  
                 p(src#) = [1] x1 + [0]                  
                 p(trg#) = [1] x1 + [0]                  
                  p(wt#) = [4]                           
                  p(c_1) = [1]                           
                  p(c_2) = [1]                           
                  p(c_3) = [0]                           
                  p(c_4) = [0]                           
                  p(c_5) = [1] x1 + [1] x2 + [0]         
                  p(c_6) = [1]                           
                  p(c_7) = [1]                           
                  p(c_8) = [0]                           
                  p(c_9) = [1]                           
                 p(c_10) = [1]                           
                 p(c_11) = [2] x3 + [1]                  
                 p(c_12) = [4] x1 + [0]                  
                 p(c_13) = [1]                           
                 p(c_14) = [1] x1 + [0]                  
                 p(c_15) = [0]                           
                 p(c_16) = [1] x1 + [0]                  
                 p(c_17) = [2]                           
                 p(c_18) = [2] x1 + [0]                  
                 p(c_19) = [1]                           
                 p(c_20) = [2] x1 + [0]                  
                 p(c_21) = [2] x1 + [0]                  
                 p(c_22) = [2] x1 + [1]                  
                 p(c_23) = [1]                           
                 p(c_24) = [4] x1 + [1] x2 + [4]         
                 p(c_25) = [1]                           
                 p(c_26) = [0]                           
                 p(c_27) = [0]                           
                 p(c_28) = [0]                           
                 p(c_29) = [4] x1 + [4]                  
                 p(c_30) = [1]                           
                 p(c_31) = [1]                           
                 p(c_32) = [0]                           
                 p(c_33) = [0]                           
                 p(c_34) = [4] x1 + [1]                  
                 p(c_35) = [1]                           
                 p(c_36) = [1]                           
                 p(c_37) = [0]                           
                 p(c_38) = [1] x1 + [1]                  
                 p(c_39) = [0]                           
                 p(c_40) = [0]                           
                 p(c_41) = [0]                           
                 p(c_42) = [2]                           
        
        Following rules are strictly oriented:
        insert#(e,dd(f,E)) = [1] E + [1]                            
                           > [1] E + [0]                            
                           = c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [2] E + [2] N + [6]                                     
                                    >= [2]                                                     
                                    =  kruskal#(sort(E),nil(),partitions(N))                   
        
                inBlock#(e,dd(p,P)) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_12(inBlock#(e,P))                                     
        
           insert#q#(false(),e,f,E) =  [1] E + [0]                                             
                                    >= [1] E + [0]                                             
                                    =  c_16(insert#(e,E))                                      
        
                 join#(e,dd(p,P),q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
        
           join#q#(false(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_20(join#(e,P,q))                                      
        
            join#q#(true(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_21(join#(e,P,pp(p,q)))                                
        
              kruskal#(dd(e,E),F,P) =  [2]                                                     
                                    >= [0]                                                     
                                    =  inBlock#(e,P)                                           
        
              kruskal#(dd(e,E),F,P) =  [2]                                                     
                                    >= [2]                                                     
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                        
        
        kruskal#q#(false(),e,E,F,P) =  [2]                                                     
                                    >= [0]                                                     
                                    =  join#(e,P,nil())                                        
        
        kruskal#q#(false(),e,E,F,P) =  [2]                                                     
                                    >= [2]                                                     
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))                     
        
         kruskal#q#(true(),e,E,F,P) =  [2]                                                     
                                    >= [2]                                                     
                                    =  kruskal#(E,F,P)                                         
        
                     sort#(dd(e,E)) =  [3] E + [3]                                             
                                    >= [2] E + [1]                                             
                                    =  insert#(e,sort(E))                                      
        
                     sort#(dd(e,E)) =  [3] E + [3]                                             
                                    >= [3] E + [0]                                             
                                    =  sort#(E)                                                
        
                  insert(e,dd(f,E)) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                        
        
                    insert(e,nil()) =  [1]                                                     
                                    >= [1]                                                     
                                    =  dd(e,nil())                                             
        
            insert#q(false(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(f,insert(e,E))                                       
        
             insert#q(true(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(e,dd(f,E))                                           
        
                      sort(dd(e,E)) =  [2] E + [3]                                             
                                    >= [2] E + [2]                                             
                                    =  insert(e,sort(E))                                       
        
                        sort(nil()) =  [1]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
*** Step 6.b:1.a:6: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_12) = {1},
          uargs(c_14) = {1},
          uargs(c_16) = {1},
          uargs(c_18) = {1},
          uargs(c_20) = {1},
          uargs(c_21) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,join,join#q,partitions,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
          ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [1]                           
                   p(dd) = [1] x2 + [1]                  
                 p(edge) = [1] x2 + [0]                  
                 p(elem) = [1] x1 + [1] x2 + [0]         
                   p(eq) = [2] x2 + [2]                  
                p(false) = [0]                           
              p(forrest) = [2] x1 + [1]                  
                p(graph) = [1] x1 + [1] x2 + [2]         
              p(inBlock) = [2] x1 + [0]                  
               p(insert) = [1] x2 + [1]                  
             p(insert#q) = [1] x4 + [2]                  
                 p(join) = [1] x2 + [1]                  
               p(join#q) = [1] x4 + [2]                  
              p(kruskal) = [2] x2 + [1] x3 + [1]         
            p(kruskal#q) = [1] x1 + [4] x4 + [1]         
                  p(leq) = [4] x1 + [2]                  
                  p(nil) = [6]                           
                   p(or) = [6] x1 + [4] x2 + [0]         
                 p(pair) = [1] x1 + [1] x2 + [2]         
           p(partitions) = [1] x1 + [0]                  
                   p(pp) = [0]                           
                    p(s) = [1] x1 + [0]                  
                 p(sort) = [1] x1 + [0]                  
                  p(src) = [1]                           
                  p(trg) = [1] x1 + [2]                  
                 p(true) = [0]                           
                   p(wt) = [1] x1 + [0]                  
                 p(and#) = [2] x2 + [0]                  
                p(elem#) = [1] x1 + [2]                  
                  p(eq#) = [2] x2 + [0]                  
             p(forrest#) = [4] x1 + [6]                  
             p(inBlock#) = [1]                           
              p(insert#) = [0]                           
            p(insert#q#) = [0]                           
                p(join#) = [2] x2 + [0]                  
              p(join#q#) = [2] x4 + [0]                  
             p(kruskal#) = [4] x1 + [2] x2 + [2] x3 + [1]
           p(kruskal#q#) = [4] x3 + [2] x4 + [2] x5 + [5]
                 p(leq#) = [1]                           
                  p(or#) = [4]                           
          p(partitions#) = [1] x1 + [2]                  
                  p(pp#) = [1] x2 + [0]                  
                p(sort#) = [2]                           
                 p(src#) = [1]                           
                 p(trg#) = [0]                           
                  p(wt#) = [4] x1 + [1]                  
                  p(c_1) = [1]                           
                  p(c_2) = [0]                           
                  p(c_3) = [0]                           
                  p(c_4) = [4]                           
                  p(c_5) = [1] x1 + [1] x2 + [0]         
                  p(c_6) = [0]                           
                  p(c_7) = [1]                           
                  p(c_8) = [0]                           
                  p(c_9) = [2]                           
                 p(c_10) = [2] x1 + [0]                  
                 p(c_11) = [0]                           
                 p(c_12) = [1] x1 + [0]                  
                 p(c_13) = [2]                           
                 p(c_14) = [4] x1 + [0]                  
                 p(c_15) = [0]                           
                 p(c_16) = [4] x1 + [0]                  
                 p(c_17) = [1]                           
                 p(c_18) = [1] x1 + [1]                  
                 p(c_19) = [1]                           
                 p(c_20) = [1] x1 + [0]                  
                 p(c_21) = [1] x1 + [0]                  
                 p(c_22) = [1] x1 + [2]                  
                 p(c_23) = [0]                           
                 p(c_24) = [4] x1 + [1] x2 + [0]         
                 p(c_25) = [1]                           
                 p(c_26) = [1]                           
                 p(c_27) = [1]                           
                 p(c_28) = [0]                           
                 p(c_29) = [1] x1 + [1]                  
                 p(c_30) = [0]                           
                 p(c_31) = [1]                           
                 p(c_32) = [4]                           
                 p(c_33) = [0]                           
                 p(c_34) = [1]                           
                 p(c_35) = [0]                           
                 p(c_36) = [4] x1 + [0]                  
                 p(c_37) = [2]                           
                 p(c_38) = [1] x1 + [1] x2 + [1]         
                 p(c_39) = [2]                           
                 p(c_40) = [1]                           
                 p(c_41) = [1]                           
                 p(c_42) = [1]                           
        
        Following rules are strictly oriented:
        join#(e,dd(p,P),q) = [2] P + [2]                                             
                           > [2] P + [1]                                             
                           = c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [4] E + [4] N + [14]                             
                                    >= [4] E + [2] N + [13]                             
                                    =  kruskal#(sort(E),nil(),partitions(N))            
        
                inBlock#(e,dd(p,P)) =  [1]                                              
                                    >= [1]                                              
                                    =  c_12(inBlock#(e,P))                              
        
                 insert#(e,dd(f,E)) =  [0]                                              
                                    >= [0]                                              
                                    =  c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))          
        
           insert#q#(false(),e,f,E) =  [0]                                              
                                    >= [0]                                              
                                    =  c_16(insert#(e,E))                               
        
           join#q#(false(),e,p,P,q) =  [2] P + [0]                                      
                                    >= [2] P + [0]                                      
                                    =  c_20(join#(e,P,q))                               
        
            join#q#(true(),e,p,P,q) =  [2] P + [0]                                      
                                    >= [2] P + [0]                                      
                                    =  c_21(join#(e,P,pp(p,q)))                         
        
              kruskal#(dd(e,E),F,P) =  [4] E + [2] F + [2] P + [5]                      
                                    >= [1]                                              
                                    =  inBlock#(e,P)                                    
        
              kruskal#(dd(e,E),F,P) =  [4] E + [2] F + [2] P + [5]                      
                                    >= [4] E + [2] F + [2] P + [5]                      
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                 
        
        kruskal#q#(false(),e,E,F,P) =  [4] E + [2] F + [2] P + [5]                      
                                    >= [2] P + [0]                                      
                                    =  join#(e,P,nil())                                 
        
        kruskal#q#(false(),e,E,F,P) =  [4] E + [2] F + [2] P + [5]                      
                                    >= [4] E + [2] F + [2] P + [5]                      
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))              
        
         kruskal#q#(true(),e,E,F,P) =  [4] E + [2] F + [2] P + [5]                      
                                    >= [4] E + [2] F + [2] P + [1]                      
                                    =  kruskal#(E,F,P)                                  
        
                     sort#(dd(e,E)) =  [2]                                              
                                    >= [0]                                              
                                    =  insert#(e,sort(E))                               
        
                     sort#(dd(e,E)) =  [2]                                              
                                    >= [2]                                              
                                    =  sort#(E)                                         
        
                  insert(e,dd(f,E)) =  [1] E + [2]                                      
                                    >= [1] E + [2]                                      
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                 
        
                    insert(e,nil()) =  [7]                                              
                                    >= [7]                                              
                                    =  dd(e,nil())                                      
        
            insert#q(false(),e,f,E) =  [1] E + [2]                                      
                                    >= [1] E + [2]                                      
                                    =  dd(f,insert(e,E))                                
        
             insert#q(true(),e,f,E) =  [1] E + [2]                                      
                                    >= [1] E + [2]                                      
                                    =  dd(e,dd(f,E))                                    
        
                  join(e,dd(p,P),q) =  [1] P + [2]                                      
                                    >= [1] P + [2]                                      
                                    =  join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
        
                    join(e,nil(),q) =  [7]                                              
                                    >= [7]                                              
                                    =  dd(q,nil())                                      
        
            join#q(false(),e,p,P,q) =  [1] P + [2]                                      
                                    >= [1] P + [2]                                      
                                    =  dd(p,join(e,P,q))                                
        
             join#q(true(),e,p,P,q) =  [1] P + [2]                                      
                                    >= [1] P + [1]                                      
                                    =  join(e,P,pp(p,q))                                
        
                partitions(dd(n,N)) =  [1] N + [1]                                      
                                    >= [1] N + [1]                                      
                                    =  dd(dd(n,nil()),partitions(N))                    
        
                  partitions(nil()) =  [6]                                              
                                    >= [6]                                              
                                    =  nil()                                            
        
                      sort(dd(e,E)) =  [1] E + [1]                                      
                                    >= [1] E + [1]                                      
                                    =  insert(e,sort(E))                                
        
                        sort(nil()) =  [6]                                              
                                    >= [6]                                              
                                    =  nil()                                            
        
*** Step 6.b:1.a:7: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_12) = {1},
          uargs(c_14) = {1},
          uargs(c_16) = {1},
          uargs(c_18) = {1},
          uargs(c_20) = {1},
          uargs(c_21) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#
          ,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [4] x1 + [3]                  
                   p(dd) = [1] x2 + [1]                  
                 p(edge) = [0]                           
                 p(elem) = [1] x2 + [2]                  
                   p(eq) = [0]                           
                p(false) = [0]                           
              p(forrest) = [0]                           
                p(graph) = [1] x1 + [1] x2 + [2]         
              p(inBlock) = [0]                           
               p(insert) = [1] x2 + [1]                  
             p(insert#q) = [1] x4 + [2]                  
                 p(join) = [0]                           
               p(join#q) = [1] x2 + [1] x4 + [1] x5 + [0]
              p(kruskal) = [2] x2 + [1]                  
            p(kruskal#q) = [4] x4 + [1] x5 + [1]         
                  p(leq) = [2] x1 + [4]                  
                  p(nil) = [0]                           
                   p(or) = [4] x2 + [1]                  
                 p(pair) = [4]                           
           p(partitions) = [7]                           
                   p(pp) = [0]                           
                    p(s) = [0]                           
                 p(sort) = [1] x1 + [0]                  
                  p(src) = [0]                           
                  p(trg) = [1] x1 + [1]                  
                 p(true) = [0]                           
                   p(wt) = [7] x1 + [0]                  
                 p(and#) = [1] x1 + [1] x2 + [0]         
                p(elem#) = [1]                           
                  p(eq#) = [2]                           
             p(forrest#) = [1] x1 + [2]                  
             p(inBlock#) = [0]                           
              p(insert#) = [2] x2 + [0]                  
            p(insert#q#) = [2] x4 + [2]                  
                p(join#) = [0]                           
              p(join#q#) = [0]                           
             p(kruskal#) = [0]                           
           p(kruskal#q#) = [0]                           
                 p(leq#) = [1] x1 + [1]                  
                  p(or#) = [4] x1 + [1]                  
          p(partitions#) = [0]                           
                  p(pp#) = [4] x1 + [4] x2 + [4]         
                p(sort#) = [2] x1 + [0]                  
                 p(src#) = [0]                           
                 p(trg#) = [1] x1 + [1]                  
                  p(wt#) = [1] x1 + [1]                  
                  p(c_1) = [0]                           
                  p(c_2) = [1]                           
                  p(c_3) = [0]                           
                  p(c_4) = [1]                           
                  p(c_5) = [1] x1 + [1] x2 + [4]         
                  p(c_6) = [1]                           
                  p(c_7) = [2]                           
                  p(c_8) = [4]                           
                  p(c_9) = [4]                           
                 p(c_10) = [0]                           
                 p(c_11) = [2] x1 + [1] x2 + [0]         
                 p(c_12) = [1] x1 + [0]                  
                 p(c_13) = [1]                           
                 p(c_14) = [1] x1 + [0]                  
                 p(c_15) = [1]                           
                 p(c_16) = [1] x1 + [0]                  
                 p(c_17) = [0]                           
                 p(c_18) = [2] x1 + [0]                  
                 p(c_19) = [0]                           
                 p(c_20) = [4] x1 + [0]                  
                 p(c_21) = [2] x1 + [0]                  
                 p(c_22) = [1] x1 + [1]                  
                 p(c_23) = [1]                           
                 p(c_24) = [0]                           
                 p(c_25) = [1]                           
                 p(c_26) = [0]                           
                 p(c_27) = [1]                           
                 p(c_28) = [0]                           
                 p(c_29) = [1] x1 + [0]                  
                 p(c_30) = [1]                           
                 p(c_31) = [4]                           
                 p(c_32) = [2]                           
                 p(c_33) = [4]                           
                 p(c_34) = [0]                           
                 p(c_35) = [0]                           
                 p(c_36) = [1] x1 + [4]                  
                 p(c_37) = [1]                           
                 p(c_38) = [4] x1 + [1]                  
                 p(c_39) = [1]                           
                 p(c_40) = [0]                           
                 p(c_41) = [0]                           
                 p(c_42) = [1]                           
        
        Following rules are strictly oriented:
        insert#q#(false(),e,f,E) = [2] E + [2]       
                                 > [2] E + [0]       
                                 = c_16(insert#(e,E))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [1] E + [1] N + [4]                                     
                                    >= [0]                                                     
                                    =  kruskal#(sort(E),nil(),partitions(N))                   
        
                inBlock#(e,dd(p,P)) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_12(inBlock#(e,P))                                     
        
                 insert#(e,dd(f,E)) =  [2] E + [2]                                             
                                    >= [2] E + [2]                                             
                                    =  c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))                 
        
                 join#(e,dd(p,P),q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
        
           join#q#(false(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_20(join#(e,P,q))                                      
        
            join#q#(true(),e,p,P,q) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_21(join#(e,P,pp(p,q)))                                
        
              kruskal#(dd(e,E),F,P) =  [0]                                                     
                                    >= [0]                                                     
                                    =  inBlock#(e,P)                                           
        
              kruskal#(dd(e,E),F,P) =  [0]                                                     
                                    >= [0]                                                     
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                        
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                                     
                                    >= [0]                                                     
                                    =  join#(e,P,nil())                                        
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                                     
                                    >= [0]                                                     
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))                     
        
         kruskal#q#(true(),e,E,F,P) =  [0]                                                     
                                    >= [0]                                                     
                                    =  kruskal#(E,F,P)                                         
        
                     sort#(dd(e,E)) =  [2] E + [2]                                             
                                    >= [2] E + [0]                                             
                                    =  insert#(e,sort(E))                                      
        
                     sort#(dd(e,E)) =  [2] E + [2]                                             
                                    >= [2] E + [0]                                             
                                    =  sort#(E)                                                
        
                  insert(e,dd(f,E)) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                        
        
                    insert(e,nil()) =  [1]                                                     
                                    >= [1]                                                     
                                    =  dd(e,nil())                                             
        
            insert#q(false(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(f,insert(e,E))                                       
        
             insert#q(true(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(e,dd(f,E))                                           
        
                      sort(dd(e,E)) =  [1] E + [1]                                             
                                    >= [1] E + [1]                                             
                                    =  insert(e,sort(E))                                       
        
                        sort(nil()) =  [0]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
*** Step 6.b:1.a:8: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_12) = {1},
          uargs(c_14) = {1},
          uargs(c_16) = {1},
          uargs(c_18) = {1},
          uargs(c_20) = {1},
          uargs(c_21) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,join,join#q,partitions,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
          ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                           
                  p(and) = [2] x1 + [4] x2 + [6]         
                   p(dd) = [1] x2 + [1]                  
                 p(edge) = [1] x2 + [1] x3 + [2]         
                 p(elem) = [1] x1 + [2] x2 + [0]         
                   p(eq) = [0]                           
                p(false) = [0]                           
              p(forrest) = [2] x1 + [0]                  
                p(graph) = [1] x1 + [1] x2 + [2]         
              p(inBlock) = [2] x1 + [2]                  
               p(insert) = [1] x2 + [1]                  
             p(insert#q) = [1] x4 + [2]                  
                 p(join) = [1] x2 + [1]                  
               p(join#q) = [1] x4 + [2]                  
              p(kruskal) = [4] x2 + [4]                  
            p(kruskal#q) = [4] x1 + [1] x3 + [1] x4 + [4]
                  p(leq) = [0]                           
                  p(nil) = [0]                           
                   p(or) = [6] x2 + [0]                  
                 p(pair) = [0]                           
           p(partitions) = [1] x1 + [1]                  
                   p(pp) = [1]                           
                    p(s) = [1] x1 + [1]                  
                 p(sort) = [1] x1 + [0]                  
                  p(src) = [0]                           
                  p(trg) = [1]                           
                 p(true) = [0]                           
                   p(wt) = [4] x1 + [4]                  
                 p(and#) = [1] x1 + [1] x2 + [1]         
                p(elem#) = [4] x1 + [4] x2 + [1]         
                  p(eq#) = [2] x2 + [0]                  
             p(forrest#) = [6] x1 + [0]                  
             p(inBlock#) = [0]                           
              p(insert#) = [0]                           
            p(insert#q#) = [0]                           
                p(join#) = [4] x2 + [0]                  
              p(join#q#) = [4] x4 + [1]                  
             p(kruskal#) = [5] x1 + [4] x3 + [0]         
           p(kruskal#q#) = [5] x3 + [4] x5 + [5]         
                 p(leq#) = [1] x2 + [4]                  
                  p(or#) = [1] x2 + [1]                  
          p(partitions#) = [0]                           
                  p(pp#) = [2] x1 + [1] x2 + [4]         
                p(sort#) = [7]                           
                 p(src#) = [1]                           
                 p(trg#) = [1] x1 + [2]                  
                  p(wt#) = [4] x1 + [4]                  
                  p(c_1) = [2]                           
                  p(c_2) = [0]                           
                  p(c_3) = [0]                           
                  p(c_4) = [2]                           
                  p(c_5) = [4] x2 + [4]                  
                  p(c_6) = [0]                           
                  p(c_7) = [0]                           
                  p(c_8) = [1]                           
                  p(c_9) = [0]                           
                 p(c_10) = [0]                           
                 p(c_11) = [0]                           
                 p(c_12) = [4] x1 + [0]                  
                 p(c_13) = [0]                           
                 p(c_14) = [2] x1 + [0]                  
                 p(c_15) = [1]                           
                 p(c_16) = [4] x1 + [0]                  
                 p(c_17) = [1]                           
                 p(c_18) = [1] x1 + [3]                  
                 p(c_19) = [0]                           
                 p(c_20) = [1] x1 + [0]                  
                 p(c_21) = [1] x1 + [0]                  
                 p(c_22) = [4] x1 + [1] x2 + [1]         
                 p(c_23) = [1]                           
                 p(c_24) = [2]                           
                 p(c_25) = [2]                           
                 p(c_26) = [0]                           
                 p(c_27) = [1]                           
                 p(c_28) = [0]                           
                 p(c_29) = [0]                           
                 p(c_30) = [1]                           
                 p(c_31) = [0]                           
                 p(c_32) = [1]                           
                 p(c_33) = [1]                           
                 p(c_34) = [2] x1 + [1]                  
                 p(c_35) = [0]                           
                 p(c_36) = [4] x1 + [0]                  
                 p(c_37) = [2]                           
                 p(c_38) = [1] x1 + [1] x2 + [1]         
                 p(c_39) = [1]                           
                 p(c_40) = [0]                           
                 p(c_41) = [1]                           
                 p(c_42) = [2]                           
        
        Following rules are strictly oriented:
        join#q#(false(),e,p,P,q) = [4] P + [1]             
                                 > [4] P + [0]             
                                 = c_20(join#(e,P,q))      
        
         join#q#(true(),e,p,P,q) = [4] P + [1]             
                                 > [4] P + [0]             
                                 = c_21(join#(e,P,pp(p,q)))
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [6] E + [6] N + [12]                                    
                                    >= [5] E + [4] N + [4]                                     
                                    =  kruskal#(sort(E),nil(),partitions(N))                   
        
                inBlock#(e,dd(p,P)) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_12(inBlock#(e,P))                                     
        
                 insert#(e,dd(f,E)) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))                 
        
           insert#q#(false(),e,f,E) =  [0]                                                     
                                    >= [0]                                                     
                                    =  c_16(insert#(e,E))                                      
        
                 join#(e,dd(p,P),q) =  [4] P + [4]                                             
                                    >= [4] P + [4]                                             
                                    =  c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
        
              kruskal#(dd(e,E),F,P) =  [5] E + [4] P + [5]                                     
                                    >= [0]                                                     
                                    =  inBlock#(e,P)                                           
        
              kruskal#(dd(e,E),F,P) =  [5] E + [4] P + [5]                                     
                                    >= [5] E + [4] P + [5]                                     
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                        
        
        kruskal#q#(false(),e,E,F,P) =  [5] E + [4] P + [5]                                     
                                    >= [4] P + [0]                                             
                                    =  join#(e,P,nil())                                        
        
        kruskal#q#(false(),e,E,F,P) =  [5] E + [4] P + [5]                                     
                                    >= [5] E + [4] P + [4]                                     
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))                     
        
         kruskal#q#(true(),e,E,F,P) =  [5] E + [4] P + [5]                                     
                                    >= [5] E + [4] P + [0]                                     
                                    =  kruskal#(E,F,P)                                         
        
                     sort#(dd(e,E)) =  [7]                                                     
                                    >= [0]                                                     
                                    =  insert#(e,sort(E))                                      
        
                     sort#(dd(e,E)) =  [7]                                                     
                                    >= [7]                                                     
                                    =  sort#(E)                                                
        
                  insert(e,dd(f,E)) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                        
        
                    insert(e,nil()) =  [1]                                                     
                                    >= [1]                                                     
                                    =  dd(e,nil())                                             
        
            insert#q(false(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(f,insert(e,E))                                       
        
             insert#q(true(),e,f,E) =  [1] E + [2]                                             
                                    >= [1] E + [2]                                             
                                    =  dd(e,dd(f,E))                                           
        
                  join(e,dd(p,P),q) =  [1] P + [2]                                             
                                    >= [1] P + [2]                                             
                                    =  join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)       
        
                    join(e,nil(),q) =  [1]                                                     
                                    >= [1]                                                     
                                    =  dd(q,nil())                                             
        
            join#q(false(),e,p,P,q) =  [1] P + [2]                                             
                                    >= [1] P + [2]                                             
                                    =  dd(p,join(e,P,q))                                       
        
             join#q(true(),e,p,P,q) =  [1] P + [2]                                             
                                    >= [1] P + [1]                                             
                                    =  join(e,P,pp(p,q))                                       
        
                partitions(dd(n,N)) =  [1] N + [2]                                             
                                    >= [1] N + [2]                                             
                                    =  dd(dd(n,nil()),partitions(N))                           
        
                  partitions(nil()) =  [1]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
                      sort(dd(e,E)) =  [1] E + [1]                                             
                                    >= [1] E + [1]                                             
                                    =  insert(e,sort(E))                                       
        
                        sort(nil()) =  [0]                                                     
                                    >= [0]                                                     
                                    =  nil()                                                   
        
*** Step 6.b:1.a:9: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> c_12(inBlock#(e,P))
            insert#(e,dd(f,E)) -> c_14(insert#q#(leq(wt(e),wt(f)),e,f,E))
            insert#q#(false(),e,f,E) -> c_16(insert#(e,E))
            join#(e,dd(p,P),q) -> c_18(join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q))
            join#q#(false(),e,p,P,q) -> c_20(join#(e,P,q))
            join#q#(true(),e,p,P,q) -> c_21(join#(e,P,pp(p,q)))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/1,c_13/0,c_14/1,c_15/0,c_16/1,c_17/0,c_18/1,c_19/0,c_20/1,c_21/1,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 6.b:1.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> partitions#(N)
            forrest#(graph(N,E)) -> sort#(E)
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            partitions#(dd(n,N)) -> partitions#(N)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
          forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
          forrest#(graph(N,E)) -> partitions#(N)
          forrest#(graph(N,E)) -> sort#(E)
          inBlock#(e,dd(p,P)) -> elem#(src(e),p)
          inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
          inBlock#(e,dd(p,P)) -> inBlock#(e,P)
          insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
          insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
          insert#q#(false(),e,f,E) -> insert#(e,E)
          join#(e,dd(p,P),q) -> elem#(src(e),p)
          join#(e,dd(p,P),q) -> elem#(trg(e),p)
          join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
          join#q#(false(),e,p,P,q) -> join#(e,P,q)
          join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
          join#q#(true(),e,p,P,q) -> pp#(p,q)
          kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
          kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
          kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
          kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
          leq#(s(n),s(m)) -> c_29(leq#(n,m))
          partitions#(dd(n,N)) -> partitions#(N)
          pp#(dd(n,p),q) -> c_36(pp#(p,q))
          sort#(dd(e,E)) -> insert#(e,sort(E))
          sort#(dd(e,E)) -> sort#(E)
        and a lower component
          eq#(s(n),s(m)) -> c_10(eq#(n,m))
        Further, following extension rules are added to the lower component.
          elem#(n,dd(m,p)) -> elem#(n,p)
          elem#(n,dd(m,p)) -> eq#(n,m)
          forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
          forrest#(graph(N,E)) -> partitions#(N)
          forrest#(graph(N,E)) -> sort#(E)
          inBlock#(e,dd(p,P)) -> elem#(src(e),p)
          inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
          inBlock#(e,dd(p,P)) -> inBlock#(e,P)
          insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
          insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
          insert#q#(false(),e,f,E) -> insert#(e,E)
          join#(e,dd(p,P),q) -> elem#(src(e),p)
          join#(e,dd(p,P),q) -> elem#(trg(e),p)
          join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
          join#q#(false(),e,p,P,q) -> join#(e,P,q)
          join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
          join#q#(true(),e,p,P,q) -> pp#(p,q)
          kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
          kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
          kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
          kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
          kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
          leq#(s(n),s(m)) -> leq#(n,m)
          partitions#(dd(n,N)) -> partitions#(N)
          pp#(dd(n,p),q) -> pp#(p,q)
          sort#(dd(e,E)) -> insert#(e,sort(E))
          sort#(dd(e,E)) -> sort#(E)
**** Step 6.b:1.b:1.a:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> partitions#(N)
            forrest#(graph(N,E)) -> sort#(E)
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            partitions#(dd(n,N)) -> partitions#(N)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
             -->_2 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          2:S:leq#(s(n),s(m)) -> c_29(leq#(n,m))
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
          
          3:S:pp#(dd(n,p),q) -> c_36(pp#(p,q))
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
          
          4:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          5:W:forrest#(graph(N,E)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):24
          
          6:W:forrest#(graph(N,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):26
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):25
          
          7:W:inBlock#(e,dd(p,P)) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          8:W:inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          9:W:inBlock#(e,dd(p,P)) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          10:W:insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
             -->_1 insert#q#(false(),e,f,E) -> insert#(e,E):12
          
          11:W:insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
          
          12:W:insert#q#(false(),e,f,E) -> insert#(e,E)
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          13:W:join#(e,dd(p,P),q) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          14:W:join#(e,dd(p,P),q) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          15:W:join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
             -->_1 join#q#(true(),e,p,P,q) -> pp#(p,q):18
             -->_1 join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q)):17
             -->_1 join#q#(false(),e,p,P,q) -> join#(e,P,q):16
          
          16:W:join#q#(false(),e,p,P,q) -> join#(e,P,q)
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          17:W:join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          18:W:join#q#(true(),e,p,P,q) -> pp#(p,q)
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
          
          19:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          20:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
             -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):23
             -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):22
             -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):21
          
          21:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          22:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          23:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          24:W:partitions#(dd(n,N)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):24
          
          25:W:sort#(dd(e,E)) -> insert#(e,sort(E))
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          26:W:sort#(dd(e,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):26
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):25
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          5: forrest#(graph(N,E)) -> partitions#(N)
          24: partitions#(dd(n,N)) -> partitions#(N)
**** Step 6.b:1.b:1.a:2: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> sort#(E)
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p))
             -->_2 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          2:S:leq#(s(n),s(m)) -> c_29(leq#(n,m))
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
          
          3:S:pp#(dd(n,p),q) -> c_36(pp#(p,q))
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
          
          4:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          6:W:forrest#(graph(N,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):26
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):25
          
          7:W:inBlock#(e,dd(p,P)) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          8:W:inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          9:W:inBlock#(e,dd(p,P)) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          10:W:insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
             -->_1 insert#q#(false(),e,f,E) -> insert#(e,E):12
          
          11:W:insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
             -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
          
          12:W:insert#q#(false(),e,f,E) -> insert#(e,E)
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          13:W:join#(e,dd(p,P),q) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          14:W:join#(e,dd(p,P),q) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> c_5(eq#(n,m),elem#(n,p)):1
          
          15:W:join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
             -->_1 join#q#(true(),e,p,P,q) -> pp#(p,q):18
             -->_1 join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q)):17
             -->_1 join#q#(false(),e,p,P,q) -> join#(e,P,q):16
          
          16:W:join#q#(false(),e,p,P,q) -> join#(e,P,q)
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          17:W:join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          18:W:join#q#(true(),e,p,P,q) -> pp#(p,q)
             -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
          
          19:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          20:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
             -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):23
             -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):22
             -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):21
          
          21:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          22:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          23:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          25:W:sort#(dd(e,E)) -> insert#(e,sort(E))
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          26:W:sort#(dd(e,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):26
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):25
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          elem#(n,dd(m,p)) -> c_5(elem#(n,p))
**** Step 6.b:1.b:1.a:3: RemoveHeads WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(elem#(n,p))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> sort#(E)
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/1,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:elem#(n,dd(m,p)) -> c_5(elem#(n,p))
           -->_1 elem#(n,dd(m,p)) -> c_5(elem#(n,p)):1
        
        2:S:leq#(s(n),s(m)) -> c_29(leq#(n,m))
           -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
        
        3:S:pp#(dd(n,p),q) -> c_36(pp#(p,q))
           -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
        
        4:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):19
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):18
        
        5:W:forrest#(graph(N,E)) -> sort#(E)
           -->_1 sort#(dd(e,E)) -> sort#(E):24
           -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):23
        
        6:W:inBlock#(e,dd(p,P)) -> elem#(src(e),p)
           -->_1 elem#(n,dd(m,p)) -> c_5(elem#(n,p)):1
        
        7:W:inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
           -->_1 elem#(n,dd(m,p)) -> c_5(elem#(n,p)):1
        
        8:W:inBlock#(e,dd(p,P)) -> inBlock#(e,P)
           -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):8
           -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):7
           -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):6
        
        9:W:insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
           -->_1 insert#q#(false(),e,f,E) -> insert#(e,E):11
        
        10:W:insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
           -->_1 leq#(s(n),s(m)) -> c_29(leq#(n,m)):2
        
        11:W:insert#q#(false(),e,f,E) -> insert#(e,E)
           -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):10
           -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):9
        
        12:W:join#(e,dd(p,P),q) -> elem#(src(e),p)
           -->_1 elem#(n,dd(m,p)) -> c_5(elem#(n,p)):1
        
        13:W:join#(e,dd(p,P),q) -> elem#(trg(e),p)
           -->_1 elem#(n,dd(m,p)) -> c_5(elem#(n,p)):1
        
        14:W:join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
           -->_1 join#q#(true(),e,p,P,q) -> pp#(p,q):17
           -->_1 join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q)):16
           -->_1 join#q#(false(),e,p,P,q) -> join#(e,P,q):15
        
        15:W:join#q#(false(),e,p,P,q) -> join#(e,P,q)
           -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):14
           -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):13
           -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):12
        
        16:W:join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
           -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):14
           -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):13
           -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):12
        
        17:W:join#q#(true(),e,p,P,q) -> pp#(p,q)
           -->_1 pp#(dd(n,p),q) -> c_36(pp#(p,q)):3
        
        18:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
           -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):8
           -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):7
           -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):6
        
        19:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
           -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):22
           -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):21
           -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):20
        
        20:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
           -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):14
           -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):13
           -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):12
        
        21:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):19
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):18
        
        22:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
           -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):19
           -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):18
        
        23:W:sort#(dd(e,E)) -> insert#(e,sort(E))
           -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):10
           -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):9
        
        24:W:sort#(dd(e,E)) -> sort#(E)
           -->_1 sort#(dd(e,E)) -> sort#(E):24
           -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):23
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(5,forrest#(graph(N,E)) -> sort#(E))]
**** Step 6.b:1.b:1.a:4: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(elem#(n,p))
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/1,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_5) = {1},
          uargs(c_29) = {1},
          uargs(c_36) = {1}
        
        Following symbols are considered usable:
          {wt,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#,kruskal#q#,leq#,or#
          ,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                  
                  p(and) = [2]                  
                   p(dd) = [1] x1 + [1] x2 + [0]
                 p(edge) = [1] x1 + [1] x2 + [0]
                 p(elem) = [4]                  
                   p(eq) = [1] x2 + [1]         
                p(false) = [0]                  
              p(forrest) = [1]                  
                p(graph) = [1] x1 + [1] x2 + [3]
              p(inBlock) = [0]                  
               p(insert) = [0]                  
             p(insert#q) = [0]                  
                 p(join) = [4] x1 + [1] x2 + [0]
               p(join#q) = [2]                  
              p(kruskal) = [4]                  
            p(kruskal#q) = [2] x2 + [1] x5 + [1]
                  p(leq) = [1] x1 + [2] x2 + [0]
                  p(nil) = [0]                  
                   p(or) = [5]                  
                 p(pair) = [1] x1 + [1] x2 + [2]
           p(partitions) = [3]                  
                   p(pp) = [0]                  
                    p(s) = [1] x1 + [2]         
                 p(sort) = [4]                  
                  p(src) = [0]                  
                  p(trg) = [1] x1 + [0]         
                 p(true) = [0]                  
                   p(wt) = [4] x1 + [2]         
                 p(and#) = [4] x1 + [0]         
                p(elem#) = [0]                  
                  p(eq#) = [0]                  
             p(forrest#) = [1] x1 + [0]         
             p(inBlock#) = [0]                  
              p(insert#) = [4] x1 + [2]         
            p(insert#q#) = [4] x2 + [2]         
                p(join#) = [0]                  
              p(join#q#) = [0]                  
             p(kruskal#) = [0]                  
           p(kruskal#q#) = [0]                  
                 p(leq#) = [1] x1 + [0]         
                  p(or#) = [4]                  
          p(partitions#) = [4] x1 + [1]         
                  p(pp#) = [0]                  
                p(sort#) = [4] x1 + [2]         
                 p(src#) = [0]                  
                 p(trg#) = [4] x1 + [1]         
                  p(wt#) = [1] x1 + [0]         
                  p(c_1) = [0]                  
                  p(c_2) = [1]                  
                  p(c_3) = [1]                  
                  p(c_4) = [2]                  
                  p(c_5) = [4] x1 + [0]         
                  p(c_6) = [0]                  
                  p(c_7) = [4]                  
                  p(c_8) = [1]                  
                  p(c_9) = [1]                  
                 p(c_10) = [1] x1 + [1]         
                 p(c_11) = [2] x1 + [1] x3 + [2]
                 p(c_12) = [1] x3 + [4]         
                 p(c_13) = [0]                  
                 p(c_14) = [0]                  
                 p(c_15) = [1]                  
                 p(c_16) = [2] x1 + [0]         
                 p(c_17) = [1]                  
                 p(c_18) = [4]                  
                 p(c_19) = [0]                  
                 p(c_20) = [1]                  
                 p(c_21) = [0]                  
                 p(c_22) = [1] x2 + [0]         
                 p(c_23) = [1]                  
                 p(c_24) = [1]                  
                 p(c_25) = [1]                  
                 p(c_26) = [1]                  
                 p(c_27) = [0]                  
                 p(c_28) = [0]                  
                 p(c_29) = [1] x1 + [0]         
                 p(c_30) = [1]                  
                 p(c_31) = [2]                  
                 p(c_32) = [2]                  
                 p(c_33) = [1]                  
                 p(c_34) = [0]                  
                 p(c_35) = [0]                  
                 p(c_36) = [4] x1 + [0]         
                 p(c_37) = [2]                  
                 p(c_38) = [4] x1 + [4] x2 + [1]
                 p(c_39) = [1]                  
                 p(c_40) = [0]                  
                 p(c_41) = [0]                  
                 p(c_42) = [0]                  
        
        Following rules are strictly oriented:
        leq#(s(n),s(m)) = [1] n + [2]    
                        > [1] n + [0]    
                        = c_29(leq#(n,m))
        
        
        Following rules are (at-least) weakly oriented:
                   elem#(n,dd(m,p)) =  [0]                                               
                                    >= [0]                                               
                                    =  c_5(elem#(n,p))                                   
        
               forrest#(graph(N,E)) =  [1] E + [1] N + [3]                               
                                    >= [0]                                               
                                    =  kruskal#(sort(E),nil(),partitions(N))             
        
                inBlock#(e,dd(p,P)) =  [0]                                               
                                    >= [0]                                               
                                    =  elem#(src(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [0]                                               
                                    >= [0]                                               
                                    =  elem#(trg(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [0]                                               
                                    >= [0]                                               
                                    =  inBlock#(e,P)                                     
        
                 insert#(e,dd(f,E)) =  [4] e + [2]                                       
                                    >= [4] e + [2]                                       
                                    =  insert#q#(leq(wt(e),wt(f)),e,f,E)                 
        
                 insert#(e,dd(f,E)) =  [4] e + [2]                                       
                                    >= [4] e + [2]                                       
                                    =  leq#(wt(e),wt(f))                                 
        
           insert#q#(false(),e,f,E) =  [4] e + [2]                                       
                                    >= [4] e + [2]                                       
                                    =  insert#(e,E)                                      
        
                 join#(e,dd(p,P),q) =  [0]                                               
                                    >= [0]                                               
                                    =  elem#(src(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [0]                                               
                                    >= [0]                                               
                                    =  elem#(trg(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [0]                                               
                                    >= [0]                                               
                                    =  join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
        
           join#q#(false(),e,p,P,q) =  [0]                                               
                                    >= [0]                                               
                                    =  join#(e,P,q)                                      
        
            join#q#(true(),e,p,P,q) =  [0]                                               
                                    >= [0]                                               
                                    =  join#(e,P,pp(p,q))                                
        
            join#q#(true(),e,p,P,q) =  [0]                                               
                                    >= [0]                                               
                                    =  pp#(p,q)                                          
        
              kruskal#(dd(e,E),F,P) =  [0]                                               
                                    >= [0]                                               
                                    =  inBlock#(e,P)                                     
        
              kruskal#(dd(e,E),F,P) =  [0]                                               
                                    >= [0]                                               
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                  
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                               
                                    >= [0]                                               
                                    =  join#(e,P,nil())                                  
        
        kruskal#q#(false(),e,E,F,P) =  [0]                                               
                                    >= [0]                                               
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))               
        
         kruskal#q#(true(),e,E,F,P) =  [0]                                               
                                    >= [0]                                               
                                    =  kruskal#(E,F,P)                                   
        
                     pp#(dd(n,p),q) =  [0]                                               
                                    >= [0]                                               
                                    =  c_36(pp#(p,q))                                    
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [2]                               
                                    >= [4] e + [2]                                       
                                    =  insert#(e,sort(E))                                
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [2]                               
                                    >= [4] E + [2]                                       
                                    =  sort#(E)                                          
        
                    wt(edge(n,w,m)) =  [4] n + [4] w + [2]                               
                                    >= [1] w + [0]                                       
                                    =  w                                                 
        
**** Step 6.b:1.b:1.a:5: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(elem#(n,p))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/1,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_5) = {1},
          uargs(c_29) = {1},
          uargs(c_36) = {1}
        
        Following symbols are considered usable:
          {and,inBlock,insert,insert#q,join,join#q,or,partitions,pp,sort,and#,elem#,eq#,forrest#,inBlock#,insert#
          ,insert#q#,join#,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [1]                                             
                  p(and) = [4]                                             
                   p(dd) = [1] x1 + [1] x2 + [2]                           
                 p(edge) = [1] x2 + [1] x3 + [4]                           
                 p(elem) = [4] x1 + [2] x2 + [2]                           
                   p(eq) = [4] x2 + [2]                                    
                p(false) = [4]                                             
              p(forrest) = [0]                                             
                p(graph) = [1] x1 + [1] x2 + [2]                           
              p(inBlock) = [4]                                             
               p(insert) = [1] x1 + [1] x2 + [2]                           
             p(insert#q) = [1] x2 + [1] x3 + [1] x4 + [4]                  
                 p(join) = [1] x2 + [1] x3 + [2]                           
               p(join#q) = [1] x3 + [1] x4 + [1] x5 + [4]                  
              p(kruskal) = [4] x2 + [0]                                    
            p(kruskal#q) = [2] x2 + [2] x4 + [0]                           
                  p(leq) = [1]                                             
                  p(nil) = [0]                                             
                   p(or) = [1] x1 + [0]                                    
                 p(pair) = [1] x1 + [2]                                    
           p(partitions) = [4] x1 + [0]                                    
                   p(pp) = [1] x1 + [1] x2 + [0]                           
                    p(s) = [1] x1 + [2]                                    
                 p(sort) = [1] x1 + [4]                                    
                  p(src) = [1]                                             
                  p(trg) = [1]                                             
                 p(true) = [4]                                             
                   p(wt) = [0]                                             
                 p(and#) = [1] x2 + [2]                                    
                p(elem#) = [0]                                             
                  p(eq#) = [1] x1 + [2]                                    
             p(forrest#) = [4] x1 + [6]                                    
             p(inBlock#) = [2] x1 + [0]                                    
              p(insert#) = [1] x1 + [0]                                    
            p(insert#q#) = [1] x2 + [0]                                    
                p(join#) = [1] x2 + [0]                                    
              p(join#q#) = [1] x3 + [1] x4 + [0]                           
             p(kruskal#) = [2] x1 + [1] x2 + [1] x3 + [6]                  
           p(kruskal#q#) = [2] x1 + [1] x2 + [2] x3 + [1] x4 + [1] x5 + [2]
                 p(leq#) = [0]                                             
                  p(or#) = [0]                                             
          p(partitions#) = [1] x1 + [0]                                    
                  p(pp#) = [1] x1 + [0]                                    
                p(sort#) = [4] x1 + [0]                                    
                 p(src#) = [4]                                             
                 p(trg#) = [1] x1 + [1]                                    
                  p(wt#) = [0]                                             
                  p(c_1) = [0]                                             
                  p(c_2) = [1]                                             
                  p(c_3) = [1]                                             
                  p(c_4) = [1]                                             
                  p(c_5) = [1] x1 + [0]                                    
                  p(c_6) = [0]                                             
                  p(c_7) = [4]                                             
                  p(c_8) = [2]                                             
                  p(c_9) = [0]                                             
                 p(c_10) = [1] x1 + [0]                                    
                 p(c_11) = [4] x3 + [4]                                    
                 p(c_12) = [1] x1 + [4] x2 + [1] x3 + [1]                  
                 p(c_13) = [0]                                             
                 p(c_14) = [1] x1 + [2] x2 + [1]                           
                 p(c_15) = [4]                                             
                 p(c_16) = [4] x1 + [0]                                    
                 p(c_17) = [4]                                             
                 p(c_18) = [4]                                             
                 p(c_19) = [0]                                             
                 p(c_20) = [1] x1 + [1]                                    
                 p(c_21) = [1] x1 + [1] x2 + [4]                           
                 p(c_22) = [2] x1 + [2]                                    
                 p(c_23) = [0]                                             
                 p(c_24) = [0]                                             
                 p(c_25) = [2] x1 + [0]                                    
                 p(c_26) = [1]                                             
                 p(c_27) = [1]                                             
                 p(c_28) = [0]                                             
                 p(c_29) = [4] x1 + [0]                                    
                 p(c_30) = [1]                                             
                 p(c_31) = [4]                                             
                 p(c_32) = [2]                                             
                 p(c_33) = [1]                                             
                 p(c_34) = [1] x1 + [2]                                    
                 p(c_35) = [4]                                             
                 p(c_36) = [1] x1 + [0]                                    
                 p(c_37) = [4]                                             
                 p(c_38) = [2] x1 + [4]                                    
                 p(c_39) = [0]                                             
                 p(c_40) = [0]                                             
                 p(c_41) = [1]                                             
                 p(c_42) = [0]                                             
        
        Following rules are strictly oriented:
        pp#(dd(n,p),q) = [1] n + [1] p + [2]
                       > [1] p + [0]        
                       = c_36(pp#(p,q))     
        
        
        Following rules are (at-least) weakly oriented:
                   elem#(n,dd(m,p)) =  [0]                                                
                                    >= [0]                                                
                                    =  c_5(elem#(n,p))                                    
        
               forrest#(graph(N,E)) =  [4] E + [4] N + [14]                               
                                    >= [2] E + [4] N + [14]                               
                                    =  kruskal#(sort(E),nil(),partitions(N))              
        
                inBlock#(e,dd(p,P)) =  [2] e + [0]                                        
                                    >= [0]                                                
                                    =  elem#(src(e),p)                                    
        
                inBlock#(e,dd(p,P)) =  [2] e + [0]                                        
                                    >= [0]                                                
                                    =  elem#(trg(e),p)                                    
        
                inBlock#(e,dd(p,P)) =  [2] e + [0]                                        
                                    >= [2] e + [0]                                        
                                    =  inBlock#(e,P)                                      
        
                 insert#(e,dd(f,E)) =  [1] e + [0]                                        
                                    >= [1] e + [0]                                        
                                    =  insert#q#(leq(wt(e),wt(f)),e,f,E)                  
        
                 insert#(e,dd(f,E)) =  [1] e + [0]                                        
                                    >= [0]                                                
                                    =  leq#(wt(e),wt(f))                                  
        
           insert#q#(false(),e,f,E) =  [1] e + [0]                                        
                                    >= [1] e + [0]                                        
                                    =  insert#(e,E)                                       
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                                
                                    >= [0]                                                
                                    =  elem#(src(e),p)                                    
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                                
                                    >= [0]                                                
                                    =  elem#(trg(e),p)                                    
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                                
                                    >= [1] P + [1] p + [0]                                
                                    =  join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q) 
        
           join#q#(false(),e,p,P,q) =  [1] P + [1] p + [0]                                
                                    >= [1] P + [0]                                        
                                    =  join#(e,P,q)                                       
        
            join#q#(true(),e,p,P,q) =  [1] P + [1] p + [0]                                
                                    >= [1] P + [0]                                        
                                    =  join#(e,P,pp(p,q))                                 
        
            join#q#(true(),e,p,P,q) =  [1] P + [1] p + [0]                                
                                    >= [1] p + [0]                                        
                                    =  pp#(p,q)                                           
        
              kruskal#(dd(e,E),F,P) =  [2] E + [1] F + [1] P + [2] e + [10]               
                                    >= [2] e + [0]                                        
                                    =  inBlock#(e,P)                                      
        
              kruskal#(dd(e,E),F,P) =  [2] E + [1] F + [1] P + [2] e + [10]               
                                    >= [2] E + [1] F + [1] P + [1] e + [10]               
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                   
        
        kruskal#q#(false(),e,E,F,P) =  [2] E + [1] F + [1] P + [1] e + [10]               
                                    >= [1] P + [0]                                        
                                    =  join#(e,P,nil())                                   
        
        kruskal#q#(false(),e,E,F,P) =  [2] E + [1] F + [1] P + [1] e + [10]               
                                    >= [2] E + [1] F + [1] P + [1] e + [10]               
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))                
        
         kruskal#q#(true(),e,E,F,P) =  [2] E + [1] F + [1] P + [1] e + [10]               
                                    >= [2] E + [1] F + [1] P + [6]                        
                                    =  kruskal#(E,F,P)                                    
        
                    leq#(s(n),s(m)) =  [0]                                                
                                    >= [0]                                                
                                    =  c_29(leq#(n,m))                                    
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [8]                                
                                    >= [1] e + [0]                                        
                                    =  insert#(e,sort(E))                                 
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [8]                                
                                    >= [4] E + [0]                                        
                                    =  sort#(E)                                           
        
               and(false(),false()) =  [4]                                                
                                    >= [4]                                                
                                    =  false()                                            
        
                and(false(),true()) =  [4]                                                
                                    >= [4]                                                
                                    =  false()                                            
        
                and(true(),false()) =  [4]                                                
                                    >= [4]                                                
                                    =  false()                                            
        
                 and(true(),true()) =  [4]                                                
                                    >= [4]                                                
                                    =  true()                                             
        
                 inBlock(e,dd(p,P)) =  [4]                                                
                                    >= [4]                                                
                                    =  or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
        
                   inBlock(e,nil()) =  [4]                                                
                                    >= [4]                                                
                                    =  false()                                            
        
                  insert(e,dd(f,E)) =  [1] E + [1] e + [1] f + [4]                        
                                    >= [1] E + [1] e + [1] f + [4]                        
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                   
        
                    insert(e,nil()) =  [1] e + [2]                                        
                                    >= [1] e + [2]                                        
                                    =  dd(e,nil())                                        
        
            insert#q(false(),e,f,E) =  [1] E + [1] e + [1] f + [4]                        
                                    >= [1] E + [1] e + [1] f + [4]                        
                                    =  dd(f,insert(e,E))                                  
        
             insert#q(true(),e,f,E) =  [1] E + [1] e + [1] f + [4]                        
                                    >= [1] E + [1] e + [1] f + [4]                        
                                    =  dd(e,dd(f,E))                                      
        
                  join(e,dd(p,P),q) =  [1] P + [1] p + [1] q + [4]                        
                                    >= [1] P + [1] p + [1] q + [4]                        
                                    =  join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)  
        
                    join(e,nil(),q) =  [1] q + [2]                                        
                                    >= [1] q + [2]                                        
                                    =  dd(q,nil())                                        
        
            join#q(false(),e,p,P,q) =  [1] P + [1] p + [1] q + [4]                        
                                    >= [1] P + [1] p + [1] q + [4]                        
                                    =  dd(p,join(e,P,q))                                  
        
             join#q(true(),e,p,P,q) =  [1] P + [1] p + [1] q + [4]                        
                                    >= [1] P + [1] p + [1] q + [2]                        
                                    =  join(e,P,pp(p,q))                                  
        
                or(false(),false()) =  [4]                                                
                                    >= [4]                                                
                                    =  false()                                            
        
                 or(false(),true()) =  [4]                                                
                                    >= [4]                                                
                                    =  true()                                             
        
                 or(true(),false()) =  [4]                                                
                                    >= [4]                                                
                                    =  true()                                             
        
                  or(true(),true()) =  [4]                                                
                                    >= [4]                                                
                                    =  true()                                             
        
                partitions(dd(n,N)) =  [4] N + [4] n + [8]                                
                                    >= [4] N + [1] n + [4]                                
                                    =  dd(dd(n,nil()),partitions(N))                      
        
                  partitions(nil()) =  [0]                                                
                                    >= [0]                                                
                                    =  nil()                                              
        
                      pp(dd(n,p),q) =  [1] n + [1] p + [1] q + [2]                        
                                    >= [1] n + [1] p + [1] q + [2]                        
                                    =  dd(n,pp(p,q))                                      
        
                        pp(nil(),q) =  [1] q + [0]                                        
                                    >= [1] q + [0]                                        
                                    =  q                                                  
        
                      sort(dd(e,E)) =  [1] E + [1] e + [6]                                
                                    >= [1] E + [1] e + [6]                                
                                    =  insert(e,sort(E))                                  
        
                        sort(nil()) =  [4]                                                
                                    >= [0]                                                
                                    =  nil()                                              
        
**** Step 6.b:1.b:1.a:6: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            elem#(n,dd(m,p)) -> c_5(elem#(n,p))
        - Weak DPs:
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/1,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_5) = {1},
          uargs(c_29) = {1},
          uargs(c_36) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,join,join#q,partitions,pp,sort,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
          ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [2]                           
                  p(and) = [2] x2 + [2]                  
                   p(dd) = [1] x1 + [1] x2 + [1]         
                 p(edge) = [1] x1 + [1] x2 + [1]         
                 p(elem) = [2] x1 + [3] x2 + [0]         
                   p(eq) = [4] x1 + [1] x2 + [0]         
                p(false) = [0]                           
              p(forrest) = [0]                           
                p(graph) = [1] x1 + [1] x2 + [3]         
              p(inBlock) = [1] x1 + [0]                  
               p(insert) = [2] x1 + [1] x2 + [1]         
             p(insert#q) = [2] x2 + [1] x3 + [1] x4 + [2]
                 p(join) = [1] x2 + [1] x3 + [1]         
               p(join#q) = [1] x3 + [1] x4 + [1] x5 + [2]
              p(kruskal) = [1] x2 + [4] x3 + [0]         
            p(kruskal#q) = [1]                           
                  p(leq) = [0]                           
                  p(nil) = [0]                           
                   p(or) = [4] x2 + [0]                  
                 p(pair) = [1] x2 + [1]                  
           p(partitions) = [2] x1 + [0]                  
                   p(pp) = [1] x1 + [1] x2 + [1]         
                    p(s) = [1]                           
                 p(sort) = [2] x1 + [0]                  
                  p(src) = [0]                           
                  p(trg) = [1]                           
                 p(true) = [0]                           
                   p(wt) = [0]                           
                 p(and#) = [4] x2 + [1]                  
                p(elem#) = [1] x2 + [2]                  
                  p(eq#) = [2] x2 + [0]                  
             p(forrest#) = [5] x1 + [0]                  
             p(inBlock#) = [1] x1 + [1] x2 + [1]         
              p(insert#) = [1] x2 + [4]                  
            p(insert#q#) = [1] x3 + [1] x4 + [5]         
                p(join#) = [1] x2 + [1]                  
              p(join#q#) = [1] x3 + [1] x4 + [2]         
             p(kruskal#) = [2] x1 + [1] x3 + [0]         
           p(kruskal#q#) = [2] x3 + [1] x5 + [1]         
                 p(leq#) = [0]                           
                  p(or#) = [1] x1 + [1] x2 + [1]         
          p(partitions#) = [2] x1 + [1]                  
                  p(pp#) = [1] x1 + [2]                  
                p(sort#) = [4] x1 + [0]                  
                 p(src#) = [1] x1 + [2]                  
                 p(trg#) = [1]                           
                  p(wt#) = [0]                           
                  p(c_1) = [0]                           
                  p(c_2) = [0]                           
                  p(c_3) = [4]                           
                  p(c_4) = [0]                           
                  p(c_5) = [1] x1 + [0]                  
                  p(c_6) = [1]                           
                  p(c_7) = [0]                           
                  p(c_8) = [0]                           
                  p(c_9) = [2]                           
                 p(c_10) = [1]                           
                 p(c_11) = [2] x1 + [4] x2 + [1] x3 + [0]
                 p(c_12) = [1] x1 + [1] x2 + [2] x3 + [0]
                 p(c_13) = [4]                           
                 p(c_14) = [0]                           
                 p(c_15) = [0]                           
                 p(c_16) = [0]                           
                 p(c_17) = [0]                           
                 p(c_18) = [1] x1 + [2]                  
                 p(c_19) = [2]                           
                 p(c_20) = [1]                           
                 p(c_21) = [4] x1 + [1]                  
                 p(c_22) = [2] x2 + [0]                  
                 p(c_23) = [0]                           
                 p(c_24) = [1] x1 + [2] x2 + [1]         
                 p(c_25) = [1] x1 + [1]                  
                 p(c_26) = [2]                           
                 p(c_27) = [0]                           
                 p(c_28) = [1]                           
                 p(c_29) = [4] x1 + [0]                  
                 p(c_30) = [0]                           
                 p(c_31) = [2]                           
                 p(c_32) = [0]                           
                 p(c_33) = [0]                           
                 p(c_34) = [1] x1 + [0]                  
                 p(c_35) = [0]                           
                 p(c_36) = [1] x1 + [1]                  
                 p(c_37) = [0]                           
                 p(c_38) = [1] x1 + [4] x2 + [2]         
                 p(c_39) = [0]                           
                 p(c_40) = [0]                           
                 p(c_41) = [0]                           
                 p(c_42) = [4]                           
        
        Following rules are strictly oriented:
        elem#(n,dd(m,p)) = [1] m + [1] p + [3]
                         > [1] p + [2]        
                         = c_5(elem#(n,p))    
        
        
        Following rules are (at-least) weakly oriented:
               forrest#(graph(N,E)) =  [5] E + [5] N + [15]                              
                                    >= [4] E + [2] N + [0]                               
                                    =  kruskal#(sort(E),nil(),partitions(N))             
        
                inBlock#(e,dd(p,P)) =  [1] P + [1] e + [1] p + [2]                       
                                    >= [1] p + [2]                                       
                                    =  elem#(src(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [1] P + [1] e + [1] p + [2]                       
                                    >= [1] p + [2]                                       
                                    =  elem#(trg(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [1] P + [1] e + [1] p + [2]                       
                                    >= [1] P + [1] e + [1]                               
                                    =  inBlock#(e,P)                                     
        
                 insert#(e,dd(f,E)) =  [1] E + [1] f + [5]                               
                                    >= [1] E + [1] f + [5]                               
                                    =  insert#q#(leq(wt(e),wt(f)),e,f,E)                 
        
                 insert#(e,dd(f,E)) =  [1] E + [1] f + [5]                               
                                    >= [0]                                               
                                    =  leq#(wt(e),wt(f))                                 
        
           insert#q#(false(),e,f,E) =  [1] E + [1] f + [5]                               
                                    >= [1] E + [4]                                       
                                    =  insert#(e,E)                                      
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                               
                                    >= [1] p + [2]                                       
                                    =  elem#(src(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                               
                                    >= [1] p + [2]                                       
                                    =  elem#(trg(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [1] P + [1] p + [2]                               
                                    >= [1] P + [1] p + [2]                               
                                    =  join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
        
           join#q#(false(),e,p,P,q) =  [1] P + [1] p + [2]                               
                                    >= [1] P + [1]                                       
                                    =  join#(e,P,q)                                      
        
            join#q#(true(),e,p,P,q) =  [1] P + [1] p + [2]                               
                                    >= [1] P + [1]                                       
                                    =  join#(e,P,pp(p,q))                                
        
            join#q#(true(),e,p,P,q) =  [1] P + [1] p + [2]                               
                                    >= [1] p + [2]                                       
                                    =  pp#(p,q)                                          
        
              kruskal#(dd(e,E),F,P) =  [2] E + [1] P + [2] e + [2]                       
                                    >= [1] P + [1] e + [1]                               
                                    =  inBlock#(e,P)                                     
        
              kruskal#(dd(e,E),F,P) =  [2] E + [1] P + [2] e + [2]                       
                                    >= [2] E + [1] P + [1]                               
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                  
        
        kruskal#q#(false(),e,E,F,P) =  [2] E + [1] P + [1]                               
                                    >= [1] P + [1]                                       
                                    =  join#(e,P,nil())                                  
        
        kruskal#q#(false(),e,E,F,P) =  [2] E + [1] P + [1]                               
                                    >= [2] E + [1] P + [1]                               
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))               
        
         kruskal#q#(true(),e,E,F,P) =  [2] E + [1] P + [1]                               
                                    >= [2] E + [1] P + [0]                               
                                    =  kruskal#(E,F,P)                                   
        
                    leq#(s(n),s(m)) =  [0]                                               
                                    >= [0]                                               
                                    =  c_29(leq#(n,m))                                   
        
                     pp#(dd(n,p),q) =  [1] n + [1] p + [3]                               
                                    >= [1] p + [3]                                       
                                    =  c_36(pp#(p,q))                                    
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [4]                               
                                    >= [2] E + [4]                                       
                                    =  insert#(e,sort(E))                                
        
                     sort#(dd(e,E)) =  [4] E + [4] e + [4]                               
                                    >= [4] E + [0]                                       
                                    =  sort#(E)                                          
        
                  insert(e,dd(f,E)) =  [1] E + [2] e + [1] f + [2]                       
                                    >= [1] E + [2] e + [1] f + [2]                       
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                  
        
                    insert(e,nil()) =  [2] e + [1]                                       
                                    >= [1] e + [1]                                       
                                    =  dd(e,nil())                                       
        
            insert#q(false(),e,f,E) =  [1] E + [2] e + [1] f + [2]                       
                                    >= [1] E + [2] e + [1] f + [2]                       
                                    =  dd(f,insert(e,E))                                 
        
             insert#q(true(),e,f,E) =  [1] E + [2] e + [1] f + [2]                       
                                    >= [1] E + [1] e + [1] f + [2]                       
                                    =  dd(e,dd(f,E))                                     
        
                  join(e,dd(p,P),q) =  [1] P + [1] p + [1] q + [2]                       
                                    >= [1] P + [1] p + [1] q + [2]                       
                                    =  join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q) 
        
                    join(e,nil(),q) =  [1] q + [1]                                       
                                    >= [1] q + [1]                                       
                                    =  dd(q,nil())                                       
        
            join#q(false(),e,p,P,q) =  [1] P + [1] p + [1] q + [2]                       
                                    >= [1] P + [1] p + [1] q + [2]                       
                                    =  dd(p,join(e,P,q))                                 
        
             join#q(true(),e,p,P,q) =  [1] P + [1] p + [1] q + [2]                       
                                    >= [1] P + [1] p + [1] q + [2]                       
                                    =  join(e,P,pp(p,q))                                 
        
                partitions(dd(n,N)) =  [2] N + [2] n + [2]                               
                                    >= [2] N + [1] n + [2]                               
                                    =  dd(dd(n,nil()),partitions(N))                     
        
                  partitions(nil()) =  [0]                                               
                                    >= [0]                                               
                                    =  nil()                                             
        
                      pp(dd(n,p),q) =  [1] n + [1] p + [1] q + [2]                       
                                    >= [1] n + [1] p + [1] q + [2]                       
                                    =  dd(n,pp(p,q))                                     
        
                        pp(nil(),q) =  [1] q + [1]                                       
                                    >= [1] q + [0]                                       
                                    =  q                                                 
        
                      sort(dd(e,E)) =  [2] E + [2] e + [2]                               
                                    >= [2] E + [2] e + [1]                               
                                    =  insert(e,sort(E))                                 
        
                        sort(nil()) =  [0]                                               
                                    >= [0]                                               
                                    =  nil()                                             
        
**** Step 6.b:1.b:1.a:7: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            elem#(n,dd(m,p)) -> c_5(elem#(n,p))
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            leq#(s(n),s(m)) -> c_29(leq#(n,m))
            pp#(dd(n,p),q) -> c_36(pp#(p,q))
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/1,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

**** Step 6.b:1.b:1.b:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
        - Weak DPs:
            elem#(n,dd(m,p)) -> elem#(n,p)
            elem#(n,dd(m,p)) -> eq#(n,m)
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            forrest#(graph(N,E)) -> partitions#(N)
            forrest#(graph(N,E)) -> sort#(E)
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
            insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
            insert#q#(false(),e,f,E) -> insert#(e,E)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            join#q#(true(),e,p,P,q) -> pp#(p,q)
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
            leq#(s(n),s(m)) -> leq#(n,m)
            partitions#(dd(n,N)) -> partitions#(N)
            pp#(dd(n,p),q) -> pp#(p,q)
            sort#(dd(e,E)) -> insert#(e,sort(E))
            sort#(dd(e,E)) -> sort#(E)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:eq#(s(n),s(m)) -> c_10(eq#(n,m))
             -->_1 eq#(s(n),s(m)) -> c_10(eq#(n,m)):1
          
          2:W:elem#(n,dd(m,p)) -> elem#(n,p)
             -->_1 elem#(n,dd(m,p)) -> eq#(n,m):3
             -->_1 elem#(n,dd(m,p)) -> elem#(n,p):2
          
          3:W:elem#(n,dd(m,p)) -> eq#(n,m)
             -->_1 eq#(s(n),s(m)) -> c_10(eq#(n,m)):1
          
          4:W:forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          5:W:forrest#(graph(N,E)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):25
          
          6:W:forrest#(graph(N,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):28
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):27
          
          7:W:inBlock#(e,dd(p,P)) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> eq#(n,m):3
             -->_1 elem#(n,dd(m,p)) -> elem#(n,p):2
          
          8:W:inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> eq#(n,m):3
             -->_1 elem#(n,dd(m,p)) -> elem#(n,p):2
          
          9:W:inBlock#(e,dd(p,P)) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          10:W:insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
             -->_1 insert#q#(false(),e,f,E) -> insert#(e,E):12
          
          11:W:insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
             -->_1 leq#(s(n),s(m)) -> leq#(n,m):24
          
          12:W:insert#q#(false(),e,f,E) -> insert#(e,E)
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          13:W:join#(e,dd(p,P),q) -> elem#(src(e),p)
             -->_1 elem#(n,dd(m,p)) -> eq#(n,m):3
             -->_1 elem#(n,dd(m,p)) -> elem#(n,p):2
          
          14:W:join#(e,dd(p,P),q) -> elem#(trg(e),p)
             -->_1 elem#(n,dd(m,p)) -> eq#(n,m):3
             -->_1 elem#(n,dd(m,p)) -> elem#(n,p):2
          
          15:W:join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
             -->_1 join#q#(true(),e,p,P,q) -> pp#(p,q):18
             -->_1 join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q)):17
             -->_1 join#q#(false(),e,p,P,q) -> join#(e,P,q):16
          
          16:W:join#q#(false(),e,p,P,q) -> join#(e,P,q)
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          17:W:join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          18:W:join#q#(true(),e,p,P,q) -> pp#(p,q)
             -->_1 pp#(dd(n,p),q) -> pp#(p,q):26
          
          19:W:kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
             -->_1 inBlock#(e,dd(p,P)) -> inBlock#(e,P):9
             -->_1 inBlock#(e,dd(p,P)) -> elem#(trg(e),p):8
             -->_1 inBlock#(e,dd(p,P)) -> elem#(src(e),p):7
          
          20:W:kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
             -->_1 kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P):23
             -->_1 kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil())):22
             -->_1 kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil()):21
          
          21:W:kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
             -->_1 join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q):15
             -->_1 join#(e,dd(p,P),q) -> elem#(trg(e),p):14
             -->_1 join#(e,dd(p,P),q) -> elem#(src(e),p):13
          
          22:W:kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          23:W:kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
             -->_1 kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P):20
             -->_1 kruskal#(dd(e,E),F,P) -> inBlock#(e,P):19
          
          24:W:leq#(s(n),s(m)) -> leq#(n,m)
             -->_1 leq#(s(n),s(m)) -> leq#(n,m):24
          
          25:W:partitions#(dd(n,N)) -> partitions#(N)
             -->_1 partitions#(dd(n,N)) -> partitions#(N):25
          
          26:W:pp#(dd(n,p),q) -> pp#(p,q)
             -->_1 pp#(dd(n,p),q) -> pp#(p,q):26
          
          27:W:sort#(dd(e,E)) -> insert#(e,sort(E))
             -->_1 insert#(e,dd(f,E)) -> leq#(wt(e),wt(f)):11
             -->_1 insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E):10
          
          28:W:sort#(dd(e,E)) -> sort#(E)
             -->_1 sort#(dd(e,E)) -> sort#(E):28
             -->_1 sort#(dd(e,E)) -> insert#(e,sort(E)):27
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          6: forrest#(graph(N,E)) -> sort#(E)
          28: sort#(dd(e,E)) -> sort#(E)
          27: sort#(dd(e,E)) -> insert#(e,sort(E))
          10: insert#(e,dd(f,E)) -> insert#q#(leq(wt(e),wt(f)),e,f,E)
          12: insert#q#(false(),e,f,E) -> insert#(e,E)
          11: insert#(e,dd(f,E)) -> leq#(wt(e),wt(f))
          24: leq#(s(n),s(m)) -> leq#(n,m)
          5: forrest#(graph(N,E)) -> partitions#(N)
          25: partitions#(dd(n,N)) -> partitions#(N)
          18: join#q#(true(),e,p,P,q) -> pp#(p,q)
          26: pp#(dd(n,p),q) -> pp#(p,q)
**** Step 6.b:1.b:1.b:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
        - Weak DPs:
            elem#(n,dd(m,p)) -> elem#(n,p)
            elem#(n,dd(m,p)) -> eq#(n,m)
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_10) = {1}
        
        Following symbols are considered usable:
          {insert,insert#q,sort,src,trg,and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#,join#q#,kruskal#
          ,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#}
        TcT has computed the following interpretation:
                    p(0) = [0]                                             
                  p(and) = [3]                                             
                   p(dd) = [1] x1 + [1] x2 + [0]                           
                 p(edge) = [1] x1 + [1] x3 + [4]                           
                 p(elem) = [1] x2 + [2]                                    
                   p(eq) = [1] x1 + [3] x2 + [0]                           
                p(false) = [4]                                             
              p(forrest) = [0]                                             
                p(graph) = [1] x2 + [1]                                    
              p(inBlock) = [2] x1 + [2]                                    
               p(insert) = [1] x1 + [1] x2 + [0]                           
             p(insert#q) = [1] x2 + [1] x3 + [1] x4 + [0]                  
                 p(join) = [0]                                             
               p(join#q) = [2] x1 + [6] x2 + [0]                           
              p(kruskal) = [4]                                             
            p(kruskal#q) = [1] x1 + [2] x2 + [1] x3 + [1] x4 + [2] x5 + [0]
                  p(leq) = [6] x1 + [0]                                    
                  p(nil) = [0]                                             
                   p(or) = [2] x1 + [1] x2 + [0]                           
                 p(pair) = [1] x1 + [0]                                    
           p(partitions) = [0]                                             
                   p(pp) = [0]                                             
                    p(s) = [1] x1 + [1]                                    
                 p(sort) = [1] x1 + [0]                                    
                  p(src) = [1] x1 + [0]                                    
                  p(trg) = [1] x1 + [0]                                    
                 p(true) = [0]                                             
                   p(wt) = [1]                                             
                 p(and#) = [1] x1 + [1] x2 + [1]                           
                p(elem#) = [4] x1 + [0]                                    
                  p(eq#) = [4] x1 + [0]                                    
             p(forrest#) = [6] x1 + [5]                                    
             p(inBlock#) = [4] x1 + [1]                                    
              p(insert#) = [0]                                             
            p(insert#q#) = [1] x2 + [4] x3 + [1] x4 + [1]                  
                p(join#) = [4] x1 + [0]                                    
              p(join#q#) = [4] x2 + [0]                                    
             p(kruskal#) = [6] x1 + [4] x2 + [4]                           
           p(kruskal#q#) = [5] x2 + [6] x3 + [4] x4 + [4]                  
                 p(leq#) = [4] x2 + [0]                                    
                  p(or#) = [1] x2 + [1]                                    
          p(partitions#) = [4]                                             
                  p(pp#) = [1] x2 + [0]                                    
                p(sort#) = [1]                                             
                 p(src#) = [4] x1 + [0]                                    
                 p(trg#) = [4]                                             
                  p(wt#) = [1] x1 + [4]                                    
                  p(c_1) = [4]                                             
                  p(c_2) = [1]                                             
                  p(c_3) = [2]                                             
                  p(c_4) = [0]                                             
                  p(c_5) = [0]                                             
                  p(c_6) = [1]                                             
                  p(c_7) = [0]                                             
                  p(c_8) = [1]                                             
                  p(c_9) = [0]                                             
                 p(c_10) = [1] x1 + [0]                                    
                 p(c_11) = [1] x2 + [2] x3 + [0]                           
                 p(c_12) = [4] x2 + [1] x3 + [4]                           
                 p(c_13) = [4]                                             
                 p(c_14) = [0]                                             
                 p(c_15) = [1]                                             
                 p(c_16) = [1]                                             
                 p(c_17) = [0]                                             
                 p(c_18) = [2] x1 + [1] x2 + [1] x3 + [1]                  
                 p(c_19) = [0]                                             
                 p(c_20) = [1] x1 + [1]                                    
                 p(c_21) = [0]                                             
                 p(c_22) = [0]                                             
                 p(c_23) = [0]                                             
                 p(c_24) = [2]                                             
                 p(c_25) = [1] x1 + [0]                                    
                 p(c_26) = [4]                                             
                 p(c_27) = [4]                                             
                 p(c_28) = [0]                                             
                 p(c_29) = [2] x1 + [0]                                    
                 p(c_30) = [1]                                             
                 p(c_31) = [2]                                             
                 p(c_32) = [2]                                             
                 p(c_33) = [4]                                             
                 p(c_34) = [4] x1 + [1]                                    
                 p(c_35) = [0]                                             
                 p(c_36) = [0]                                             
                 p(c_37) = [2]                                             
                 p(c_38) = [1]                                             
                 p(c_39) = [0]                                             
                 p(c_40) = [2]                                             
                 p(c_41) = [1]                                             
                 p(c_42) = [1]                                             
        
        Following rules are strictly oriented:
        eq#(s(n),s(m)) = [4] n + [4]   
                       > [4] n + [0]   
                       = c_10(eq#(n,m))
        
        
        Following rules are (at-least) weakly oriented:
                   elem#(n,dd(m,p)) =  [4] n + [0]                                       
                                    >= [4] n + [0]                                       
                                    =  elem#(n,p)                                        
        
                   elem#(n,dd(m,p)) =  [4] n + [0]                                       
                                    >= [4] n + [0]                                       
                                    =  eq#(n,m)                                          
        
               forrest#(graph(N,E)) =  [6] E + [11]                                      
                                    >= [6] E + [4]                                       
                                    =  kruskal#(sort(E),nil(),partitions(N))             
        
                inBlock#(e,dd(p,P)) =  [4] e + [1]                                       
                                    >= [4] e + [0]                                       
                                    =  elem#(src(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [4] e + [1]                                       
                                    >= [4] e + [0]                                       
                                    =  elem#(trg(e),p)                                   
        
                inBlock#(e,dd(p,P)) =  [4] e + [1]                                       
                                    >= [4] e + [1]                                       
                                    =  inBlock#(e,P)                                     
        
                 join#(e,dd(p,P),q) =  [4] e + [0]                                       
                                    >= [4] e + [0]                                       
                                    =  elem#(src(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [4] e + [0]                                       
                                    >= [4] e + [0]                                       
                                    =  elem#(trg(e),p)                                   
        
                 join#(e,dd(p,P),q) =  [4] e + [0]                                       
                                    >= [4] e + [0]                                       
                                    =  join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
        
           join#q#(false(),e,p,P,q) =  [4] e + [0]                                       
                                    >= [4] e + [0]                                       
                                    =  join#(e,P,q)                                      
        
            join#q#(true(),e,p,P,q) =  [4] e + [0]                                       
                                    >= [4] e + [0]                                       
                                    =  join#(e,P,pp(p,q))                                
        
              kruskal#(dd(e,E),F,P) =  [6] E + [4] F + [6] e + [4]                       
                                    >= [4] e + [1]                                       
                                    =  inBlock#(e,P)                                     
        
              kruskal#(dd(e,E),F,P) =  [6] E + [4] F + [6] e + [4]                       
                                    >= [6] E + [4] F + [5] e + [4]                       
                                    =  kruskal#q#(inBlock(e,P),e,E,F,P)                  
        
        kruskal#q#(false(),e,E,F,P) =  [6] E + [4] F + [5] e + [4]                       
                                    >= [4] e + [0]                                       
                                    =  join#(e,P,nil())                                  
        
        kruskal#q#(false(),e,E,F,P) =  [6] E + [4] F + [5] e + [4]                       
                                    >= [6] E + [4] F + [4] e + [4]                       
                                    =  kruskal#(E,dd(e,F),join(e,P,nil()))               
        
         kruskal#q#(true(),e,E,F,P) =  [6] E + [4] F + [5] e + [4]                       
                                    >= [6] E + [4] F + [4]                               
                                    =  kruskal#(E,F,P)                                   
        
                  insert(e,dd(f,E)) =  [1] E + [1] e + [1] f + [0]                       
                                    >= [1] E + [1] e + [1] f + [0]                       
                                    =  insert#q(leq(wt(e),wt(f)),e,f,E)                  
        
                    insert(e,nil()) =  [1] e + [0]                                       
                                    >= [1] e + [0]                                       
                                    =  dd(e,nil())                                       
        
            insert#q(false(),e,f,E) =  [1] E + [1] e + [1] f + [0]                       
                                    >= [1] E + [1] e + [1] f + [0]                       
                                    =  dd(f,insert(e,E))                                 
        
             insert#q(true(),e,f,E) =  [1] E + [1] e + [1] f + [0]                       
                                    >= [1] E + [1] e + [1] f + [0]                       
                                    =  dd(e,dd(f,E))                                     
        
                      sort(dd(e,E)) =  [1] E + [1] e + [0]                               
                                    >= [1] E + [1] e + [0]                               
                                    =  insert(e,sort(E))                                 
        
                        sort(nil()) =  [0]                                               
                                    >= [0]                                               
                                    =  nil()                                             
        
                   src(edge(n,w,m)) =  [1] m + [1] n + [4]                               
                                    >= [1] n + [0]                                       
                                    =  n                                                 
        
                   trg(edge(n,w,m)) =  [1] m + [1] n + [4]                               
                                    >= [1] m + [0]                                       
                                    =  m                                                 
        
**** Step 6.b:1.b:1.b:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            elem#(n,dd(m,p)) -> elem#(n,p)
            elem#(n,dd(m,p)) -> eq#(n,m)
            eq#(s(n),s(m)) -> c_10(eq#(n,m))
            forrest#(graph(N,E)) -> kruskal#(sort(E),nil(),partitions(N))
            inBlock#(e,dd(p,P)) -> elem#(src(e),p)
            inBlock#(e,dd(p,P)) -> elem#(trg(e),p)
            inBlock#(e,dd(p,P)) -> inBlock#(e,P)
            join#(e,dd(p,P),q) -> elem#(src(e),p)
            join#(e,dd(p,P),q) -> elem#(trg(e),p)
            join#(e,dd(p,P),q) -> join#q#(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join#q#(false(),e,p,P,q) -> join#(e,P,q)
            join#q#(true(),e,p,P,q) -> join#(e,P,pp(p,q))
            kruskal#(dd(e,E),F,P) -> inBlock#(e,P)
            kruskal#(dd(e,E),F,P) -> kruskal#q#(inBlock(e,P),e,E,F,P)
            kruskal#q#(false(),e,E,F,P) -> join#(e,P,nil())
            kruskal#q#(false(),e,E,F,P) -> kruskal#(E,dd(e,F),join(e,P,nil()))
            kruskal#q#(true(),e,E,F,P) -> kruskal#(E,F,P)
        - Weak TRS:
            and(false(),false()) -> false()
            and(false(),true()) -> false()
            and(true(),false()) -> false()
            and(true(),true()) -> true()
            elem(n,dd(m,p)) -> or(eq(n,m),elem(n,p))
            elem(n,nil()) -> false()
            eq(0(),0()) -> true()
            eq(0(),s(m)) -> false()
            eq(s(n),0()) -> false()
            eq(s(n),s(m)) -> eq(n,m)
            inBlock(e,dd(p,P)) -> or(and(elem(src(e),p),elem(trg(e),p)),inBlock(e,P))
            inBlock(e,nil()) -> false()
            insert(e,dd(f,E)) -> insert#q(leq(wt(e),wt(f)),e,f,E)
            insert(e,nil()) -> dd(e,nil())
            insert#q(false(),e,f,E) -> dd(f,insert(e,E))
            insert#q(true(),e,f,E) -> dd(e,dd(f,E))
            join(e,dd(p,P),q) -> join#q(or(elem(src(e),p),elem(trg(e),p)),e,p,P,q)
            join(e,nil(),q) -> dd(q,nil())
            join#q(false(),e,p,P,q) -> dd(p,join(e,P,q))
            join#q(true(),e,p,P,q) -> join(e,P,pp(p,q))
            leq(0(),0()) -> true()
            leq(0(),s(m)) -> true()
            leq(s(n),0()) -> false()
            leq(s(n),s(m)) -> leq(n,m)
            or(false(),false()) -> false()
            or(false(),true()) -> true()
            or(true(),false()) -> true()
            or(true(),true()) -> true()
            partitions(dd(n,N)) -> dd(dd(n,nil()),partitions(N))
            partitions(nil()) -> nil()
            pp(dd(n,p),q) -> dd(n,pp(p,q))
            pp(nil(),q) -> q
            sort(dd(e,E)) -> insert(e,sort(E))
            sort(nil()) -> nil()
            src(edge(n,w,m)) -> n
            trg(edge(n,w,m)) -> m
            wt(edge(n,w,m)) -> w
        - Signature:
            {and/2,elem/2,eq/2,forrest/1,inBlock/2,insert/2,insert#q/4,join/3,join#q/5,kruskal/3,kruskal#q/5,leq/2,or/2
            ,partitions/1,pp/2,sort/1,src/1,trg/1,wt/1,and#/2,elem#/2,eq#/2,forrest#/1,inBlock#/2,insert#/2,insert#q#/4
            ,join#/3,join#q#/5,kruskal#/3,kruskal#q#/5,leq#/2,or#/2,partitions#/1,pp#/2,sort#/1,src#/1,trg#/1
            ,wt#/1} / {0/0,dd/2,edge/3,false/0,graph/2,nil/0,pair/2,s/1,true/0,c_1/0,c_2/0,c_3/0,c_4/0,c_5/2,c_6/0,c_7/0
            ,c_8/0,c_9/0,c_10/1,c_11/3,c_12/3,c_13/0,c_14/2,c_15/0,c_16/1,c_17/0,c_18/3,c_19/0,c_20/1,c_21/2,c_22/2
            ,c_23/0,c_24/2,c_25/1,c_26/0,c_27/0,c_28/0,c_29/1,c_30/0,c_31/0,c_32/0,c_33/0,c_34/1,c_35/0,c_36/1,c_37/0
            ,c_38/2,c_39/0,c_40/0,c_41/0,c_42/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {and#,elem#,eq#,forrest#,inBlock#,insert#,insert#q#,join#
            ,join#q#,kruskal#,kruskal#q#,leq#,or#,partitions#,pp#,sort#,src#,trg#,wt#} and constructors {0,dd,edge,false
            ,graph,nil,pair,s,true}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^4))

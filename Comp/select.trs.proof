WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            revapp(Cons(x,xs),rest) -> revapp(xs,Cons(x,rest))
            revapp(Nil(),rest) -> rest
            select(Cons(x,xs)) -> selects(x,Nil(),xs)
            select(Nil()) -> Nil()
            selects(x,revprefix,Nil()) -> Cons(Cons(x,revapp(revprefix,Nil())),Nil())
            selects(x',revprefix,Cons(x,xs)) -> Cons(Cons(x',revapp(revprefix,Cons(x,xs)))
                                                    ,selects(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3} / {Cons/2,Nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp,select,selects} and constructors {Cons,Nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
          revapp#(Nil(),rest) -> c_2()
          select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
          select#(Nil()) -> c_4()
          selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
          selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            revapp#(Nil(),rest) -> c_2()
            select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
            select#(Nil()) -> c_4()
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Weak TRS:
            revapp(Cons(x,xs),rest) -> revapp(xs,Cons(x,rest))
            revapp(Nil(),rest) -> rest
            select(Cons(x,xs)) -> selects(x,Nil(),xs)
            select(Nil()) -> Nil()
            selects(x,revprefix,Nil()) -> Cons(Cons(x,revapp(revprefix,Nil())),Nil())
            selects(x',revprefix,Cons(x,xs)) -> Cons(Cons(x',revapp(revprefix,Cons(x,xs)))
                                                    ,selects(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,4}
        by application of
          Pre({2,4}) = {1,5,6}.
        Here rules are labelled as follows:
          1: revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
          2: revapp#(Nil(),rest) -> c_2()
          3: select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
          4: select#(Nil()) -> c_4()
          5: selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
          6: selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Weak DPs:
            revapp#(Nil(),rest) -> c_2()
            select#(Nil()) -> c_4()
        - Weak TRS:
            revapp(Cons(x,xs),rest) -> revapp(xs,Cons(x,rest))
            revapp(Nil(),rest) -> rest
            select(Cons(x,xs)) -> selects(x,Nil(),xs)
            select(Nil()) -> Nil()
            selects(x,revprefix,Nil()) -> Cons(Cons(x,revapp(revprefix,Nil())),Nil())
            selects(x',revprefix,Cons(x,xs)) -> Cons(Cons(x',revapp(revprefix,Cons(x,xs)))
                                                    ,selects(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
             -->_1 revapp#(Nil(),rest) -> c_2():5
             -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
          
          2:S:select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
             -->_1 selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                           ,selects#(x,Cons(x',revprefix),xs)):4
             -->_1 selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil())):3
          
          3:S:selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
             -->_1 revapp#(Nil(),rest) -> c_2():5
             -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
          
          4:S:selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                      ,selects#(x,Cons(x',revprefix),xs))
             -->_1 revapp#(Nil(),rest) -> c_2():5
             -->_2 selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                           ,selects#(x,Cons(x',revprefix),xs)):4
             -->_2 selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil())):3
             -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
          
          5:W:revapp#(Nil(),rest) -> c_2()
             
          
          6:W:select#(Nil()) -> c_4()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          6: select#(Nil()) -> c_4()
          5: revapp#(Nil(),rest) -> c_2()
* Step 4: RemoveHeads WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Weak TRS:
            revapp(Cons(x,xs),rest) -> revapp(xs,Cons(x,rest))
            revapp(Nil(),rest) -> rest
            select(Cons(x,xs)) -> selects(x,Nil(),xs)
            select(Nil()) -> Nil()
            selects(x,revprefix,Nil()) -> Cons(Cons(x,revapp(revprefix,Nil())),Nil())
            selects(x',revprefix,Cons(x,xs)) -> Cons(Cons(x',revapp(revprefix,Cons(x,xs)))
                                                    ,selects(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
           -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
        
        2:S:select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs))
           -->_1 selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                         ,selects#(x,Cons(x',revprefix),xs)):4
           -->_1 selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil())):3
        
        3:S:selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
           -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
        
        4:S:selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                    ,selects#(x,Cons(x',revprefix),xs))
           -->_2 selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                         ,selects#(x,Cons(x',revprefix),xs)):4
           -->_2 selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil())):3
           -->_1 revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest))):1
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(2,select#(Cons(x,xs)) -> c_3(selects#(x,Nil(),xs)))]
* Step 5: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Weak TRS:
            revapp(Cons(x,xs),rest) -> revapp(xs,Cons(x,rest))
            revapp(Nil(),rest) -> rest
            select(Cons(x,xs)) -> selects(x,Nil(),xs)
            select(Nil()) -> Nil()
            selects(x,revprefix,Nil()) -> Cons(Cons(x,revapp(revprefix,Nil())),Nil())
            selects(x',revprefix,Cons(x,xs)) -> Cons(Cons(x',revapp(revprefix,Cons(x,xs)))
                                                    ,selects(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
          selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
          selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
* Step 6: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        and a lower component
          revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
          selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
        Further, following extension rules are added to the lower component.
          selects#(x',revprefix,Cons(x,xs)) -> revapp#(revprefix,Cons(x,xs))
          selects#(x',revprefix,Cons(x,xs)) -> selects#(x,Cons(x',revprefix),xs)
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs)),selects#(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                      ,selects#(x,Cons(x',revprefix),xs))
             -->_2 selects#(x',revprefix,Cons(x,xs)) -> c_6(revapp#(revprefix,Cons(x,xs))
                                                           ,selects#(x,Cons(x',revprefix),xs)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          selects#(x',revprefix,Cons(x,xs)) -> c_6(selects#(x,Cons(x',revprefix),xs))
** Step 6.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            selects#(x',revprefix,Cons(x,xs)) -> c_6(selects#(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_6) = {1}
        
        Following symbols are considered usable:
          {revapp#,select#,selects#}
        TcT has computed the following interpretation:
              p(Cons) = [1] x2 + [4]                  
               p(Nil) = [0]                           
            p(revapp) = [8] x1 + [1]                  
            p(select) = [2]                           
           p(selects) = [1] x1 + [1] x2 + [1] x3 + [1]
           p(revapp#) = [8] x1 + [0]                  
           p(select#) = [0]                           
          p(selects#) = [1] x2 + [4] x3 + [0]         
               p(c_1) = [8]                           
               p(c_2) = [0]                           
               p(c_3) = [1] x1 + [0]                  
               p(c_4) = [2]                           
               p(c_5) = [1]                           
               p(c_6) = [1] x1 + [4]                  
        
        Following rules are strictly oriented:
        selects#(x',revprefix,Cons(x,xs)) = [1] revprefix + [4] xs + [16]         
                                          > [1] revprefix + [4] xs + [8]          
                                          = c_6(selects#(x,Cons(x',revprefix),xs))
        
        
        Following rules are (at-least) weakly oriented:
        
** Step 6.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            selects#(x',revprefix,Cons(x,xs)) -> c_6(selects#(x,Cons(x',revprefix),xs))
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
        - Weak DPs:
            selects#(x',revprefix,Cons(x,xs)) -> revapp#(revprefix,Cons(x,xs))
            selects#(x',revprefix,Cons(x,xs)) -> selects#(x,Cons(x',revprefix),xs)
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_5) = {1}
        
        Following symbols are considered usable:
          {revapp#,select#,selects#}
        TcT has computed the following interpretation:
              p(Cons) = [1] x1 + [1] x2 + [0]
               p(Nil) = [0]                  
            p(revapp) = [0]                  
            p(select) = [0]                  
           p(selects) = [0]                  
           p(revapp#) = [0]                  
           p(select#) = [1]                  
          p(selects#) = [5]                  
               p(c_1) = [1] x1 + [0]         
               p(c_2) = [0]                  
               p(c_3) = [1]                  
               p(c_4) = [1]                  
               p(c_5) = [8] x1 + [1]         
               p(c_6) = [1]                  
        
        Following rules are strictly oriented:
        selects#(x,revprefix,Nil()) = [5]                          
                                    > [1]                          
                                    = c_5(revapp#(revprefix,Nil()))
        
        
        Following rules are (at-least) weakly oriented:
                 revapp#(Cons(x,xs),rest) =  [0]                              
                                          >= [0]                              
                                          =  c_1(revapp#(xs,Cons(x,rest)))    
        
        selects#(x',revprefix,Cons(x,xs)) =  [5]                              
                                          >= [0]                              
                                          =  revapp#(revprefix,Cons(x,xs))    
        
        selects#(x',revprefix,Cons(x,xs)) =  [5]                              
                                          >= [5]                              
                                          =  selects#(x,Cons(x',revprefix),xs)
        
** Step 6.b:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
        - Weak DPs:
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> revapp#(revprefix,Cons(x,xs))
            selects#(x',revprefix,Cons(x,xs)) -> selects#(x,Cons(x',revprefix),xs)
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(c_1) = {1},
            uargs(c_5) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
                p(Cons) = [1] x2 + [1]         
                 p(Nil) = [1]                  
              p(revapp) = [0]                  
              p(select) = [0]                  
             p(selects) = [0]                  
             p(revapp#) = [1] x1 + [0]         
             p(select#) = [0]                  
            p(selects#) = [2] x2 + [2] x3 + [0]
                 p(c_1) = [1] x1 + [0]         
                 p(c_2) = [0]                  
                 p(c_3) = [1]                  
                 p(c_4) = [2]                  
                 p(c_5) = [1] x1 + [0]         
                 p(c_6) = [8] x2 + [1]         
          
          Following rules are strictly oriented:
          revapp#(Cons(x,xs),rest) = [1] xs + [1]                 
                                   > [1] xs + [0]                 
                                   = c_1(revapp#(xs,Cons(x,rest)))
          
          
          Following rules are (at-least) weakly oriented:
                selects#(x,revprefix,Nil()) =  [2] revprefix + [2]              
                                            >= [1] revprefix + [0]              
                                            =  c_5(revapp#(revprefix,Nil()))    
          
          selects#(x',revprefix,Cons(x,xs)) =  [2] revprefix + [2] xs + [2]     
                                            >= [1] revprefix + [0]              
                                            =  revapp#(revprefix,Cons(x,xs))    
          
          selects#(x',revprefix,Cons(x,xs)) =  [2] revprefix + [2] xs + [2]     
                                            >= [2] revprefix + [2] xs + [2]     
                                            =  selects#(x,Cons(x',revprefix),xs)
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 6.b:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            revapp#(Cons(x,xs),rest) -> c_1(revapp#(xs,Cons(x,rest)))
            selects#(x,revprefix,Nil()) -> c_5(revapp#(revprefix,Nil()))
            selects#(x',revprefix,Cons(x,xs)) -> revapp#(revprefix,Cons(x,xs))
            selects#(x',revprefix,Cons(x,xs)) -> selects#(x,Cons(x',revprefix),xs)
        - Signature:
            {revapp/2,select/1,selects/3,revapp#/2,select#/1,selects#/3} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/0,c_5/1
            ,c_6/2}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {revapp#,select#,selects#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

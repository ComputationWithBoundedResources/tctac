WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            main(x0) -> rev#1(x0)
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1} / {Cons/2,Nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2,main,rev#1} and constructors {Cons,Nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
          append#2#(Nil(),Cons(x2,Nil())) -> c_2()
          main#(x0) -> c_3(rev#1#(x0))
          rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
          rev#1#(Nil()) -> c_5()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            append#2#(Nil(),Cons(x2,Nil())) -> c_2()
            main#(x0) -> c_3(rev#1#(x0))
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
            rev#1#(Nil()) -> c_5()
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            main(x0) -> rev#1(x0)
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2,5}
        by application of
          Pre({2,5}) = {1,3,4}.
        Here rules are labelled as follows:
          1: append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
          2: append#2#(Nil(),Cons(x2,Nil())) -> c_2()
          3: main#(x0) -> c_3(rev#1#(x0))
          4: rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
          5: rev#1#(Nil()) -> c_5()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            main#(x0) -> c_3(rev#1#(x0))
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        - Weak DPs:
            append#2#(Nil(),Cons(x2,Nil())) -> c_2()
            rev#1#(Nil()) -> c_5()
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            main(x0) -> rev#1(x0)
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
             -->_1 append#2#(Nil(),Cons(x2,Nil())) -> c_2():4
             -->_1 append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil()))):1
          
          2:S:main#(x0) -> c_3(rev#1#(x0))
             -->_1 rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1)):3
             -->_1 rev#1#(Nil()) -> c_5():5
          
          3:S:rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
             -->_2 rev#1#(Nil()) -> c_5():5
             -->_1 append#2#(Nil(),Cons(x2,Nil())) -> c_2():4
             -->_2 rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1)):3
             -->_1 append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil()))):1
          
          4:W:append#2#(Nil(),Cons(x2,Nil())) -> c_2()
             
          
          5:W:rev#1#(Nil()) -> c_5()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          5: rev#1#(Nil()) -> c_5()
          4: append#2#(Nil(),Cons(x2,Nil())) -> c_2()
* Step 4: RemoveHeads WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            main#(x0) -> c_3(rev#1#(x0))
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            main(x0) -> rev#1(x0)
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
           -->_1 append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil()))):1
        
        2:S:main#(x0) -> c_3(rev#1#(x0))
           -->_1 rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1)):3
        
        3:S:rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
           -->_2 rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1)):3
           -->_1 append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil()))):1
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(2,main#(x0) -> c_3(rev#1#(x0)))]
* Step 5: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            main(x0) -> rev#1(x0)
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
          append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
          rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
          rev#1(Nil()) -> Nil()
          append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
          rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
* Step 6: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        and a lower component
          append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
        Further, following extension rules are added to the lower component.
          rev#1#(Cons(x2,x1)) -> append#2#(rev#1(x1),Cons(x2,Nil()))
          rev#1#(Cons(x2,x1)) -> rev#1#(x1)
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1))
             -->_2 rev#1#(Cons(x2,x1)) -> c_4(append#2#(rev#1(x1),Cons(x2,Nil())),rev#1#(x1)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          rev#1#(Cons(x2,x1)) -> c_4(rev#1#(x1))
** Step 6.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#1#(Cons(x2,x1)) -> c_4(rev#1#(x1))
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/1,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          rev#1#(Cons(x2,x1)) -> c_4(rev#1#(x1))
** Step 6.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            rev#1#(Cons(x2,x1)) -> c_4(rev#1#(x1))
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/1,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_4) = {1}
        
        Following symbols are considered usable:
          {append#2#,main#,rev#1#}
        TcT has computed the following interpretation:
               p(Cons) = [1] x1 + [1] x2 + [1]
                p(Nil) = [1]                  
           p(append#2) = [2]                  
               p(main) = [1] x1 + [1]         
              p(rev#1) = [2]                  
          p(append#2#) = [1] x1 + [2]         
              p(main#) = [8] x1 + [1]         
             p(rev#1#) = [4] x1 + [12]        
                p(c_1) = [0]                  
                p(c_2) = [1]                  
                p(c_3) = [1] x1 + [1]         
                p(c_4) = [1] x1 + [1]         
                p(c_5) = [0]                  
        
        Following rules are strictly oriented:
        rev#1#(Cons(x2,x1)) = [4] x1 + [4] x2 + [16]
                            > [4] x1 + [13]         
                            = c_4(rev#1#(x1))       
        
        
        Following rules are (at-least) weakly oriented:
        
** Step 6.a:4: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            rev#1#(Cons(x2,x1)) -> c_4(rev#1#(x1))
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/1,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
        - Weak DPs:
            rev#1#(Cons(x2,x1)) -> append#2#(rev#1(x1),Cons(x2,Nil()))
            rev#1#(Cons(x2,x1)) -> rev#1#(x1)
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1}
        
        Following symbols are considered usable:
          {append#2,rev#1,append#2#,main#,rev#1#}
        TcT has computed the following interpretation:
               p(Cons) = [1] x2 + [4]         
                p(Nil) = [0]                  
           p(append#2) = [1] x1 + [1] x2 + [4]
               p(main) = [1] x1 + [1]         
              p(rev#1) = [2] x1 + [0]         
          p(append#2#) = [1] x1 + [0]         
              p(main#) = [2]                  
             p(rev#1#) = [2] x1 + [2]         
                p(c_1) = [1] x1 + [3]         
                p(c_2) = [0]                  
                p(c_3) = [1] x1 + [1]         
                p(c_4) = [1] x1 + [4]         
                p(c_5) = [2]                  
        
        Following rules are strictly oriented:
        append#2#(Cons(x6,x4),Cons(x2,Nil())) = [1] x4 + [4]                     
                                              > [1] x4 + [3]                     
                                              = c_1(append#2#(x4,Cons(x2,Nil())))
        
        
        Following rules are (at-least) weakly oriented:
                         rev#1#(Cons(x2,x1)) =  [2] x1 + [10]                       
                                             >= [2] x1 + [0]                        
                                             =  append#2#(rev#1(x1),Cons(x2,Nil())) 
        
                         rev#1#(Cons(x2,x1)) =  [2] x1 + [10]                       
                                             >= [2] x1 + [2]                        
                                             =  rev#1#(x1)                          
        
        append#2(Cons(x6,x4),Cons(x2,Nil())) =  [1] x4 + [12]                       
                                             >= [1] x4 + [12]                       
                                             =  Cons(x6,append#2(x4,Cons(x2,Nil())))
        
              append#2(Nil(),Cons(x2,Nil())) =  [8]                                 
                                             >= [4]                                 
                                             =  Cons(x2,Nil())                      
        
                          rev#1(Cons(x2,x1)) =  [2] x1 + [8]                        
                                             >= [2] x1 + [8]                        
                                             =  append#2(rev#1(x1),Cons(x2,Nil()))  
        
                                rev#1(Nil()) =  [0]                                 
                                             >= [0]                                 
                                             =  Nil()                               
        
** Step 6.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            append#2#(Cons(x6,x4),Cons(x2,Nil())) -> c_1(append#2#(x4,Cons(x2,Nil())))
            rev#1#(Cons(x2,x1)) -> append#2#(rev#1(x1),Cons(x2,Nil()))
            rev#1#(Cons(x2,x1)) -> rev#1#(x1)
        - Weak TRS:
            append#2(Cons(x6,x4),Cons(x2,Nil())) -> Cons(x6,append#2(x4,Cons(x2,Nil())))
            append#2(Nil(),Cons(x2,Nil())) -> Cons(x2,Nil())
            rev#1(Cons(x2,x1)) -> append#2(rev#1(x1),Cons(x2,Nil()))
            rev#1(Nil()) -> Nil()
        - Signature:
            {append#2/2,main/1,rev#1/1,append#2#/2,main#/1,rev#1#/1} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1,c_4/2,c_5/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {append#2#,main#,rev#1#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

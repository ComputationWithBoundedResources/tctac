WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            bits(0()) -> 0()
            bits(s(0())) -> s(0())
            bits(s(s(x))) -> s(bits(s(half(x))))
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1} / {0/0,s/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits,half} and constructors {0,s}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          bits#(0()) -> c_1()
          bits#(s(0())) -> c_2()
          bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
          half#(0()) -> c_4()
          half#(s(0())) -> c_5()
          half#(s(s(x))) -> c_6(half#(x))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            bits#(0()) -> c_1()
            bits#(s(0())) -> c_2()
            bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
            half#(0()) -> c_4()
            half#(s(0())) -> c_5()
            half#(s(s(x))) -> c_6(half#(x))
        - Weak TRS:
            bits(0()) -> 0()
            bits(s(0())) -> s(0())
            bits(s(s(x))) -> s(bits(s(half(x))))
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1,2,4,5}
        by application of
          Pre({1,2,4,5}) = {3,6}.
        Here rules are labelled as follows:
          1: bits#(0()) -> c_1()
          2: bits#(s(0())) -> c_2()
          3: bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
          4: half#(0()) -> c_4()
          5: half#(s(0())) -> c_5()
          6: half#(s(s(x))) -> c_6(half#(x))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
            half#(s(s(x))) -> c_6(half#(x))
        - Weak DPs:
            bits#(0()) -> c_1()
            bits#(s(0())) -> c_2()
            half#(0()) -> c_4()
            half#(s(0())) -> c_5()
        - Weak TRS:
            bits(0()) -> 0()
            bits(s(0())) -> s(0())
            bits(s(s(x))) -> s(bits(s(half(x))))
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
             -->_2 half#(s(s(x))) -> c_6(half#(x)):2
             -->_2 half#(s(0())) -> c_5():6
             -->_2 half#(0()) -> c_4():5
             -->_1 bits#(s(0())) -> c_2():4
             -->_1 bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x)):1
          
          2:S:half#(s(s(x))) -> c_6(half#(x))
             -->_1 half#(s(0())) -> c_5():6
             -->_1 half#(0()) -> c_4():5
             -->_1 half#(s(s(x))) -> c_6(half#(x)):2
          
          3:W:bits#(0()) -> c_1()
             
          
          4:W:bits#(s(0())) -> c_2()
             
          
          5:W:half#(0()) -> c_4()
             
          
          6:W:half#(s(0())) -> c_5()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: bits#(0()) -> c_1()
          4: bits#(s(0())) -> c_2()
          5: half#(0()) -> c_4()
          6: half#(s(0())) -> c_5()
* Step 4: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
            half#(s(s(x))) -> c_6(half#(x))
        - Weak TRS:
            bits(0()) -> 0()
            bits(s(0())) -> s(0())
            bits(s(s(x))) -> s(bits(s(half(x))))
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          half(0()) -> 0()
          half(s(0())) -> 0()
          half(s(s(x))) -> s(half(x))
          bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
          half#(s(s(x))) -> c_6(half#(x))
* Step 5: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
            half#(s(s(x))) -> c_6(half#(x))
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
        and a lower component
          half#(s(s(x))) -> c_6(half#(x))
        Further, following extension rules are added to the lower component.
          bits#(s(s(x))) -> bits#(s(half(x)))
          bits#(s(s(x))) -> half#(x)
** Step 5.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x))
             -->_1 bits#(s(s(x))) -> c_3(bits#(s(half(x))),half#(x)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          bits#(s(s(x))) -> c_3(bits#(s(half(x))))
** Step 5.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))))
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/1,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_3) = {1}
        
        Following symbols are considered usable:
          {half,bits#,half#}
        TcT has computed the following interpretation:
              p(0) = [11]         
           p(bits) = [1]          
           p(half) = [1] x1 + [0] 
              p(s) = [1] x1 + [1] 
          p(bits#) = [8] x1 + [13]
          p(half#) = [2] x1 + [0] 
            p(c_1) = [1]          
            p(c_2) = [4]          
            p(c_3) = [1] x1 + [1] 
            p(c_4) = [1]          
            p(c_5) = [1]          
            p(c_6) = [8]          
        
        Following rules are strictly oriented:
        bits#(s(s(x))) = [8] x + [29]          
                       > [8] x + [22]          
                       = c_3(bits#(s(half(x))))
        
        
        Following rules are (at-least) weakly oriented:
            half(0()) =  [11]       
                      >= [11]       
                      =  0()        
        
         half(s(0())) =  [12]       
                      >= [11]       
                      =  0()        
        
        half(s(s(x))) =  [1] x + [2]
                      >= [1] x + [1]
                      =  s(half(x)) 
        
** Step 5.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            bits#(s(s(x))) -> c_3(bits#(s(half(x))))
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/1,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 5.b:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            half#(s(s(x))) -> c_6(half#(x))
        - Weak DPs:
            bits#(s(s(x))) -> bits#(s(half(x)))
            bits#(s(s(x))) -> half#(x)
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_6) = {1}
        
        Following symbols are considered usable:
          {half,bits#,half#}
        TcT has computed the following interpretation:
              p(0) = [10]                 
           p(bits) = [1] x1 + [1]         
           p(half) = [1] x1 + [2]         
              p(s) = [1] x1 + [2]         
          p(bits#) = [1] x1 + [6]         
          p(half#) = [1] x1 + [0]         
            p(c_1) = [2]                  
            p(c_2) = [0]                  
            p(c_3) = [8] x1 + [1] x2 + [0]
            p(c_4) = [8]                  
            p(c_5) = [1]                  
            p(c_6) = [1] x1 + [0]         
        
        Following rules are strictly oriented:
        half#(s(s(x))) = [1] x + [4]  
                       > [1] x + [0]  
                       = c_6(half#(x))
        
        
        Following rules are (at-least) weakly oriented:
        bits#(s(s(x))) =  [1] x + [10]     
                       >= [1] x + [10]     
                       =  bits#(s(half(x)))
        
        bits#(s(s(x))) =  [1] x + [10]     
                       >= [1] x + [0]      
                       =  half#(x)         
        
             half(0()) =  [12]             
                       >= [10]             
                       =  0()              
        
          half(s(0())) =  [14]             
                       >= [10]             
                       =  0()              
        
         half(s(s(x))) =  [1] x + [6]      
                       >= [1] x + [4]      
                       =  s(half(x))       
        
** Step 5.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            bits#(s(s(x))) -> bits#(s(half(x)))
            bits#(s(s(x))) -> half#(x)
            half#(s(s(x))) -> c_6(half#(x))
        - Weak TRS:
            half(0()) -> 0()
            half(s(0())) -> 0()
            half(s(s(x))) -> s(half(x))
        - Signature:
            {bits/1,half/1,bits#/1,half#/1} / {0/0,s/1,c_1/0,c_2/0,c_3/2,c_4/0,c_5/0,c_6/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {bits#,half#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

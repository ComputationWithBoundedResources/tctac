WORST_CASE(?,O(n^3))
* Step 1: DependencyPairs WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict TRS:
            choice(dd(u,S),K,E) -> choice(S,K,E)
            choice(dd(u,S),K,E) -> choice(S,dd(u,K),E)
            choice(nil(),K,E) -> ite(clique(K,E),K,nil())
            clique(dd(u,K),E) -> ite(complete(u,K,E),clique(K,E),ff())
            clique(nil(),E) -> tt()
            complete(u,dd(v,S),E) -> ite(find(u,v,E),complete(u,S,E),ff())
            complete(u,nil(),E) -> tt()
            find(u,v,dd(dd(u,v),E)) -> tt()
            find(u,v,dd(dd(u2,v2),E)) -> find(u,v,E)
            find(u,v,nil()) -> ff()
            ite(ff(),u,v) -> v
            ite(tt(),u,v) -> u
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3} / {dd/2,ff/0,nil/0,tt/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice,clique,complete,find,ite} and constructors {dd,ff
            ,nil,tt}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
          choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
          choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
          clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
          clique#(nil(),E) -> c_5()
          complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
          complete#(u,nil(),E) -> c_7()
          find#(u,v,dd(dd(u,v),E)) -> c_8()
          find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
          find#(u,v,nil()) -> c_10()
          ite#(ff(),u,v) -> c_11()
          ite#(tt(),u,v) -> c_12()
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
            clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
            clique#(nil(),E) -> c_5()
            complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
            complete#(u,nil(),E) -> c_7()
            find#(u,v,dd(dd(u,v),E)) -> c_8()
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
            find#(u,v,nil()) -> c_10()
            ite#(ff(),u,v) -> c_11()
            ite#(tt(),u,v) -> c_12()
        - Weak TRS:
            choice(dd(u,S),K,E) -> choice(S,K,E)
            choice(dd(u,S),K,E) -> choice(S,dd(u,K),E)
            choice(nil(),K,E) -> ite(clique(K,E),K,nil())
            clique(dd(u,K),E) -> ite(complete(u,K,E),clique(K,E),ff())
            clique(nil(),E) -> tt()
            complete(u,dd(v,S),E) -> ite(find(u,v,E),complete(u,S,E),ff())
            complete(u,nil(),E) -> tt()
            find(u,v,dd(dd(u,v),E)) -> tt()
            find(u,v,dd(dd(u2,v2),E)) -> find(u,v,E)
            find(u,v,nil()) -> ff()
            ite(ff(),u,v) -> v
            ite(tt(),u,v) -> u
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/2,c_4/3,c_5/0,c_6/3,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {5,7,8,10,11,12}
        by application of
          Pre({5,7,8,10,11,12}) = {3,4,6,9}.
        Here rules are labelled as follows:
          1: choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
          2: choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
          3: choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
          4: clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
          5: clique#(nil(),E) -> c_5()
          6: complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
          7: complete#(u,nil(),E) -> c_7()
          8: find#(u,v,dd(dd(u,v),E)) -> c_8()
          9: find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
          10: find#(u,v,nil()) -> c_10()
          11: ite#(ff(),u,v) -> c_11()
          12: ite#(tt(),u,v) -> c_12()
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
            clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
            complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Weak DPs:
            clique#(nil(),E) -> c_5()
            complete#(u,nil(),E) -> c_7()
            find#(u,v,dd(dd(u,v),E)) -> c_8()
            find#(u,v,nil()) -> c_10()
            ite#(ff(),u,v) -> c_11()
            ite#(tt(),u,v) -> c_12()
        - Weak TRS:
            choice(dd(u,S),K,E) -> choice(S,K,E)
            choice(dd(u,S),K,E) -> choice(S,dd(u,K),E)
            choice(nil(),K,E) -> ite(clique(K,E),K,nil())
            clique(dd(u,K),E) -> ite(complete(u,K,E),clique(K,E),ff())
            clique(nil(),E) -> tt()
            complete(u,dd(v,S),E) -> ite(find(u,v,E),complete(u,S,E),ff())
            complete(u,nil(),E) -> tt()
            find(u,v,dd(dd(u,v),E)) -> tt()
            find(u,v,dd(dd(u2,v2),E)) -> find(u,v,E)
            find(u,v,nil()) -> ff()
            ite(ff(),u,v) -> v
            ite(tt(),u,v) -> u
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/2,c_4/3,c_5/0,c_6/3,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
             -->_1 choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          2:S:choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
             -->_1 choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          3:S:choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
             -->_2 clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E)):4
             -->_1 ite#(tt(),u,v) -> c_12():12
             -->_1 ite#(ff(),u,v) -> c_11():11
             -->_2 clique#(nil(),E) -> c_5():7
          
          4:S:clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
             -->_2 complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff())
                                                ,find#(u,v,E)
                                                ,complete#(u,S,E)):5
             -->_1 ite#(tt(),u,v) -> c_12():12
             -->_1 ite#(ff(),u,v) -> c_11():11
             -->_2 complete#(u,nil(),E) -> c_7():8
             -->_3 clique#(nil(),E) -> c_5():7
             -->_3 clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E)):4
          
          5:S:complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
             -->_2 find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E)):6
             -->_1 ite#(tt(),u,v) -> c_12():12
             -->_1 ite#(ff(),u,v) -> c_11():11
             -->_2 find#(u,v,nil()) -> c_10():10
             -->_2 find#(u,v,dd(dd(u,v),E)) -> c_8():9
             -->_3 complete#(u,nil(),E) -> c_7():8
             -->_3 complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E)):5
          
          6:S:find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
             -->_1 find#(u,v,nil()) -> c_10():10
             -->_1 find#(u,v,dd(dd(u,v),E)) -> c_8():9
             -->_1 find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E)):6
          
          7:W:clique#(nil(),E) -> c_5()
             
          
          8:W:complete#(u,nil(),E) -> c_7()
             
          
          9:W:find#(u,v,dd(dd(u,v),E)) -> c_8()
             
          
          10:W:find#(u,v,nil()) -> c_10()
             
          
          11:W:ite#(ff(),u,v) -> c_11()
             
          
          12:W:ite#(tt(),u,v) -> c_12()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          7: clique#(nil(),E) -> c_5()
          8: complete#(u,nil(),E) -> c_7()
          11: ite#(ff(),u,v) -> c_11()
          12: ite#(tt(),u,v) -> c_12()
          9: find#(u,v,dd(dd(u,v),E)) -> c_8()
          10: find#(u,v,nil()) -> c_10()
* Step 4: SimplifyRHS WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
            clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
            complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Weak TRS:
            choice(dd(u,S),K,E) -> choice(S,K,E)
            choice(dd(u,S),K,E) -> choice(S,dd(u,K),E)
            choice(nil(),K,E) -> ite(clique(K,E),K,nil())
            clique(dd(u,K),E) -> ite(complete(u,K,E),clique(K,E),ff())
            clique(nil(),E) -> tt()
            complete(u,dd(v,S),E) -> ite(find(u,v,E),complete(u,S,E),ff())
            complete(u,nil(),E) -> tt()
            find(u,v,dd(dd(u,v),E)) -> tt()
            find(u,v,dd(dd(u2,v2),E)) -> find(u,v,E)
            find(u,v,nil()) -> ff()
            ite(ff(),u,v) -> v
            ite(tt(),u,v) -> u
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/2,c_4/3,c_5/0,c_6/3,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
             -->_1 choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          2:S:choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
             -->_1 choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          3:S:choice#(nil(),K,E) -> c_3(ite#(clique(K,E),K,nil()),clique#(K,E))
             -->_2 clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E)):4
          
          4:S:clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E))
             -->_2 complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff())
                                                ,find#(u,v,E)
                                                ,complete#(u,S,E)):5
             -->_3 clique#(dd(u,K),E) -> c_4(ite#(complete(u,K,E),clique(K,E),ff()),complete#(u,K,E),clique#(K,E)):4
          
          5:S:complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E))
             -->_2 find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E)):6
             -->_3 complete#(u,dd(v,S),E) -> c_6(ite#(find(u,v,E),complete(u,S,E),ff()),find#(u,v,E),complete#(u,S,E)):5
          
          6:S:find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
             -->_1 find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E)):6
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          choice#(nil(),K,E) -> c_3(clique#(K,E))
          clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
          complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
* Step 5: UsableRules WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
            complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Weak TRS:
            choice(dd(u,S),K,E) -> choice(S,K,E)
            choice(dd(u,S),K,E) -> choice(S,dd(u,K),E)
            choice(nil(),K,E) -> ite(clique(K,E),K,nil())
            clique(dd(u,K),E) -> ite(complete(u,K,E),clique(K,E),ff())
            clique(nil(),E) -> tt()
            complete(u,dd(v,S),E) -> ite(find(u,v,E),complete(u,S,E),ff())
            complete(u,nil(),E) -> tt()
            find(u,v,dd(dd(u,v),E)) -> tt()
            find(u,v,dd(dd(u2,v2),E)) -> find(u,v,E)
            find(u,v,nil()) -> ff()
            ite(ff(),u,v) -> v
            ite(tt(),u,v) -> u
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
          choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
          choice#(nil(),K,E) -> c_3(clique#(K,E))
          clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
          complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
          find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
* Step 6: DecomposeDG WORST_CASE(?,O(n^3))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
            complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
          choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
          choice#(nil(),K,E) -> c_3(clique#(K,E))
          clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
        and a lower component
          complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
          find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        Further, following extension rules are added to the lower component.
          choice#(dd(u,S),K,E) -> choice#(S,K,E)
          choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
          choice#(nil(),K,E) -> clique#(K,E)
          clique#(dd(u,K),E) -> clique#(K,E)
          clique#(dd(u,K),E) -> complete#(u,K,E)
** Step 6.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
             -->_1 choice#(nil(),K,E) -> c_3(clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          2:S:choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
             -->_1 choice#(nil(),K,E) -> c_3(clique#(K,E)):3
             -->_1 choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E)):2
             -->_1 choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E)):1
          
          3:S:choice#(nil(),K,E) -> c_3(clique#(K,E))
             -->_1 clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E)):4
          
          4:S:clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E))
             -->_2 clique#(dd(u,K),E) -> c_4(complete#(u,K,E),clique#(K,E)):4
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          clique#(dd(u,K),E) -> c_4(clique#(K,E))
** Step 6.a:2: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(c_1) = {1},
            uargs(c_2) = {1},
            uargs(c_3) = {1},
            uargs(c_4) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(choice) = [0]         
               p(clique) = [0]         
             p(complete) = [0]         
                   p(dd) = [1] x2 + [9]
                   p(ff) = [0]         
                 p(find) = [0]         
                  p(ite) = [1] x2 + [0]
                  p(nil) = [0]         
                   p(tt) = [0]         
              p(choice#) = [1] x2 + [0]
              p(clique#) = [1] x1 + [0]
            p(complete#) = [0]         
                p(find#) = [0]         
                 p(ite#) = [0]         
                  p(c_1) = [1] x1 + [0]
                  p(c_2) = [1] x1 + [0]
                  p(c_3) = [1] x1 + [0]
                  p(c_4) = [1] x1 + [0]
                  p(c_5) = [0]         
                  p(c_6) = [0]         
                  p(c_7) = [0]         
                  p(c_8) = [0]         
                  p(c_9) = [0]         
                 p(c_10) = [0]         
                 p(c_11) = [0]         
                 p(c_12) = [0]         
          
          Following rules are strictly oriented:
          clique#(dd(u,K),E) = [1] K + [9]      
                             > [1] K + [0]      
                             = c_4(clique#(K,E))
          
          
          Following rules are (at-least) weakly oriented:
          choice#(dd(u,S),K,E) =  [1] K + [0]              
                               >= [1] K + [0]              
                               =  c_1(choice#(S,K,E))      
          
          choice#(dd(u,S),K,E) =  [1] K + [0]              
                               >= [1] K + [9]              
                               =  c_2(choice#(S,dd(u,K),E))
          
            choice#(nil(),K,E) =  [1] K + [0]              
                               >= [1] K + [0]              
                               =  c_3(clique#(K,E))        
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 6.a:3: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
        - Weak DPs:
            clique#(dd(u,K),E) -> c_4(clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_2) = {1},
          uargs(c_3) = {1},
          uargs(c_4) = {1}
        
        Following symbols are considered usable:
          {choice#,clique#,complete#,find#,ite#}
        TcT has computed the following interpretation:
             p(choice) = [1] x1 + [1] x3 + [1]         
             p(clique) = [2] x2 + [1]                  
           p(complete) = [1] x2 + [2]                  
                 p(dd) = [1] x1 + [0]                  
                 p(ff) = [0]                           
               p(find) = [2] x1 + [2] x2 + [8] x3 + [1]
                p(ite) = [1] x1 + [2] x2 + [1] x3 + [0]
                p(nil) = [1]                           
                 p(tt) = [1]                           
            p(choice#) = [1]                           
            p(clique#) = [0]                           
          p(complete#) = [1] x1 + [2] x2 + [1]         
              p(find#) = [8] x3 + [1]                  
               p(ite#) = [1] x1 + [1] x2 + [2]         
                p(c_1) = [1] x1 + [0]                  
                p(c_2) = [1] x1 + [0]                  
                p(c_3) = [4] x1 + [0]                  
                p(c_4) = [8] x1 + [0]                  
                p(c_5) = [1]                           
                p(c_6) = [1] x2 + [2]                  
                p(c_7) = [0]                           
                p(c_8) = [1]                           
                p(c_9) = [8] x1 + [2]                  
               p(c_10) = [1]                           
               p(c_11) = [0]                           
               p(c_12) = [8]                           
        
        Following rules are strictly oriented:
        choice#(nil(),K,E) = [1]              
                           > [0]              
                           = c_3(clique#(K,E))
        
        
        Following rules are (at-least) weakly oriented:
        choice#(dd(u,S),K,E) =  [1]                      
                             >= [1]                      
                             =  c_1(choice#(S,K,E))      
        
        choice#(dd(u,S),K,E) =  [1]                      
                             >= [1]                      
                             =  c_2(choice#(S,dd(u,K),E))
        
          clique#(dd(u,K),E) =  [0]                      
                             >= [0]                      
                             =  c_4(clique#(K,E))        
        
** Step 6.a:4: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
        - Weak DPs:
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(c_1) = {1},
            uargs(c_2) = {1},
            uargs(c_3) = {1},
            uargs(c_4) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(choice) = [0]                  
               p(clique) = [0]                  
             p(complete) = [0]                  
                   p(dd) = [1] x1 + [1] x2 + [1]
                   p(ff) = [0]                  
                 p(find) = [0]                  
                  p(ite) = [2] x3 + [0]         
                  p(nil) = [4]                  
                   p(tt) = [2]                  
              p(choice#) = [4] x1 + [1] x3 + [0]
              p(clique#) = [1]                  
            p(complete#) = [8] x3 + [0]         
                p(find#) = [2] x2 + [4] x3 + [2]
                 p(ite#) = [1] x1 + [1] x3 + [1]
                  p(c_1) = [1] x1 + [5]         
                  p(c_2) = [1] x1 + [0]         
                  p(c_3) = [1] x1 + [0]         
                  p(c_4) = [1] x1 + [0]         
                  p(c_5) = [1]                  
                  p(c_6) = [8]                  
                  p(c_7) = [2]                  
                  p(c_8) = [8]                  
                  p(c_9) = [1] x1 + [0]         
                 p(c_10) = [4]                  
                 p(c_11) = [1]                  
                 p(c_12) = [1]                  
          
          Following rules are strictly oriented:
          choice#(dd(u,S),K,E) = [1] E + [4] S + [4] u + [4]
                               > [1] E + [4] S + [0]        
                               = c_2(choice#(S,dd(u,K),E))  
          
          
          Following rules are (at-least) weakly oriented:
          choice#(dd(u,S),K,E) =  [1] E + [4] S + [4] u + [4]
                               >= [1] E + [4] S + [5]        
                               =  c_1(choice#(S,K,E))        
          
            choice#(nil(),K,E) =  [1] E + [16]               
                               >= [1]                        
                               =  c_3(clique#(K,E))          
          
            clique#(dd(u,K),E) =  [1]                        
                               >= [1]                        
                               =  c_4(clique#(K,E))          
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
** Step 6.a:5: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
        - Weak DPs:
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1},
          uargs(c_2) = {1},
          uargs(c_3) = {1},
          uargs(c_4) = {1}
        
        Following symbols are considered usable:
          {choice#,clique#,complete#,find#,ite#}
        TcT has computed the following interpretation:
             p(choice) = [0]                           
             p(clique) = [1] x1 + [0]                  
           p(complete) = [1] x1 + [1] x2 + [1] x3 + [1]
                 p(dd) = [1] x2 + [8]                  
                 p(ff) = [0]                           
               p(find) = [1] x2 + [1] x3 + [0]         
                p(ite) = [4] x2 + [2] x3 + [1]         
                p(nil) = [0]                           
                 p(tt) = [2]                           
            p(choice#) = [1] x1 + [0]                  
            p(clique#) = [0]                           
          p(complete#) = [8] x1 + [1] x2 + [2] x3 + [1]
              p(find#) = [2] x1 + [0]                  
               p(ite#) = [1] x2 + [0]                  
                p(c_1) = [1] x1 + [0]                  
                p(c_2) = [1] x1 + [0]                  
                p(c_3) = [1] x1 + [0]                  
                p(c_4) = [8] x1 + [0]                  
                p(c_5) = [0]                           
                p(c_6) = [1] x1 + [1] x2 + [4]         
                p(c_7) = [0]                           
                p(c_8) = [1]                           
                p(c_9) = [1]                           
               p(c_10) = [2]                           
               p(c_11) = [2]                           
               p(c_12) = [1]                           
        
        Following rules are strictly oriented:
        choice#(dd(u,S),K,E) = [1] S + [8]        
                             > [1] S + [0]        
                             = c_1(choice#(S,K,E))
        
        
        Following rules are (at-least) weakly oriented:
        choice#(dd(u,S),K,E) =  [1] S + [8]              
                             >= [1] S + [0]              
                             =  c_2(choice#(S,dd(u,K),E))
        
          choice#(nil(),K,E) =  [0]                      
                             >= [0]                      
                             =  c_3(clique#(K,E))        
        
          clique#(dd(u,K),E) =  [0]                      
                             >= [0]                      
                             =  c_4(clique#(K,E))        
        
** Step 6.a:6: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            choice#(dd(u,S),K,E) -> c_1(choice#(S,K,E))
            choice#(dd(u,S),K,E) -> c_2(choice#(S,dd(u,K),E))
            choice#(nil(),K,E) -> c_3(clique#(K,E))
            clique#(dd(u,K),E) -> c_4(clique#(K,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/1,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: DecomposeDG WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        DecomposeDG {onSelection = all below first cut in WDG, onUpper = Nothing, onLower = Nothing}
    + Details:
        We decompose the input problem according to the dependency graph into the upper component
          choice#(dd(u,S),K,E) -> choice#(S,K,E)
          choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
          choice#(nil(),K,E) -> clique#(K,E)
          clique#(dd(u,K),E) -> clique#(K,E)
          clique#(dd(u,K),E) -> complete#(u,K,E)
          complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
        and a lower component
          find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        Further, following extension rules are added to the lower component.
          choice#(dd(u,S),K,E) -> choice#(S,K,E)
          choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
          choice#(nil(),K,E) -> clique#(K,E)
          clique#(dd(u,K),E) -> clique#(K,E)
          clique#(dd(u,K),E) -> complete#(u,K,E)
          complete#(u,dd(v,S),E) -> complete#(u,S,E)
          complete#(u,dd(v,S),E) -> find#(u,v,E)
*** Step 6.b:1.a:1: SimplifyRHS WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        SimplifyRHS
    + Details:
        Consider the dependency graph
          1:S:complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E))
             -->_2 complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E)):1
          
          2:W:choice#(dd(u,S),K,E) -> choice#(S,K,E)
             -->_1 choice#(nil(),K,E) -> clique#(K,E):4
             -->_1 choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E):3
             -->_1 choice#(dd(u,S),K,E) -> choice#(S,K,E):2
          
          3:W:choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
             -->_1 choice#(nil(),K,E) -> clique#(K,E):4
             -->_1 choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E):3
             -->_1 choice#(dd(u,S),K,E) -> choice#(S,K,E):2
          
          4:W:choice#(nil(),K,E) -> clique#(K,E)
             -->_1 clique#(dd(u,K),E) -> complete#(u,K,E):6
             -->_1 clique#(dd(u,K),E) -> clique#(K,E):5
          
          5:W:clique#(dd(u,K),E) -> clique#(K,E)
             -->_1 clique#(dd(u,K),E) -> complete#(u,K,E):6
             -->_1 clique#(dd(u,K),E) -> clique#(K,E):5
          
          6:W:clique#(dd(u,K),E) -> complete#(u,K,E)
             -->_1 complete#(u,dd(v,S),E) -> c_6(find#(u,v,E),complete#(u,S,E)):1
          
        Due to missing edges in the depndency graph, the right-hand sides of following rules could be simplified:
          complete#(u,dd(v,S),E) -> c_6(complete#(u,S,E))
*** Step 6.b:1.a:2: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            complete#(u,dd(v,S),E) -> c_6(complete#(u,S,E))
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/1,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_6) = {1}
        
        Following symbols are considered usable:
          {choice#,clique#,complete#,find#,ite#}
        TcT has computed the following interpretation:
             p(choice) = [4] x1 + [4] x2 + [1]         
             p(clique) = [1] x1 + [0]                  
           p(complete) = [1] x1 + [1] x2 + [2] x3 + [1]
                 p(dd) = [1] x2 + [2]                  
                 p(ff) = [0]                           
               p(find) = [1] x2 + [1] x3 + [1]         
                p(ite) = [4]                           
                p(nil) = [0]                           
                 p(tt) = [2]                           
            p(choice#) = [9] x1 + [8] x2 + [1] x3 + [0]
            p(clique#) = [8] x1 + [1] x2 + [0]         
          p(complete#) = [8] x2 + [1] x3 + [0]         
              p(find#) = [2] x1 + [1] x2 + [1]         
               p(ite#) = [1] x1 + [1] x3 + [1]         
                p(c_1) = [0]                           
                p(c_2) = [2] x1 + [4]                  
                p(c_3) = [1] x1 + [1]                  
                p(c_4) = [1] x1 + [1]                  
                p(c_5) = [8]                           
                p(c_6) = [1] x1 + [12]                 
                p(c_7) = [0]                           
                p(c_8) = [0]                           
                p(c_9) = [1] x1 + [1]                  
               p(c_10) = [0]                           
               p(c_11) = [0]                           
               p(c_12) = [1]                           
        
        Following rules are strictly oriented:
        complete#(u,dd(v,S),E) = [1] E + [8] S + [16] 
                               > [1] E + [8] S + [12] 
                               = c_6(complete#(u,S,E))
        
        
        Following rules are (at-least) weakly oriented:
        choice#(dd(u,S),K,E) =  [1] E + [8] K + [9] S + [18]
                             >= [1] E + [8] K + [9] S + [0] 
                             =  choice#(S,K,E)              
        
        choice#(dd(u,S),K,E) =  [1] E + [8] K + [9] S + [18]
                             >= [1] E + [8] K + [9] S + [16]
                             =  choice#(S,dd(u,K),E)        
        
          choice#(nil(),K,E) =  [1] E + [8] K + [0]         
                             >= [1] E + [8] K + [0]         
                             =  clique#(K,E)                
        
          clique#(dd(u,K),E) =  [1] E + [8] K + [16]        
                             >= [1] E + [8] K + [0]         
                             =  clique#(K,E)                
        
          clique#(dd(u,K),E) =  [1] E + [8] K + [16]        
                             >= [1] E + [8] K + [0]         
                             =  complete#(u,K,E)            
        
*** Step 6.b:1.a:3: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
            complete#(u,dd(v,S),E) -> c_6(complete#(u,S,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/1,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

*** Step 6.b:1.b:1: WeightGap WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
            complete#(u,dd(v,S),E) -> complete#(u,S,E)
            complete#(u,dd(v,S),E) -> find#(u,v,E)
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnAny}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(c_9) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(choice) = [0]         
               p(clique) = [0]         
             p(complete) = [0]         
                   p(dd) = [1] x2 + [1]
                   p(ff) = [0]         
                 p(find) = [0]         
                  p(ite) = [0]         
                  p(nil) = [0]         
                   p(tt) = [0]         
              p(choice#) = [1] x3 + [6]
              p(clique#) = [1] x2 + [6]
            p(complete#) = [1] x3 + [6]
                p(find#) = [1] x3 + [6]
                 p(ite#) = [0]         
                  p(c_1) = [0]         
                  p(c_2) = [0]         
                  p(c_3) = [0]         
                  p(c_4) = [0]         
                  p(c_5) = [0]         
                  p(c_6) = [0]         
                  p(c_7) = [0]         
                  p(c_8) = [1]         
                  p(c_9) = [1] x1 + [0]
                 p(c_10) = [0]         
                 p(c_11) = [0]         
                 p(c_12) = [0]         
          
          Following rules are strictly oriented:
          find#(u,v,dd(dd(u2,v2),E)) = [1] E + [7]      
                                     > [1] E + [6]      
                                     = c_9(find#(u,v,E))
          
          
          Following rules are (at-least) weakly oriented:
            choice#(dd(u,S),K,E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  choice#(S,K,E)      
          
            choice#(dd(u,S),K,E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  choice#(S,dd(u,K),E)
          
              choice#(nil(),K,E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  clique#(K,E)        
          
              clique#(dd(u,K),E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  clique#(K,E)        
          
              clique#(dd(u,K),E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  complete#(u,K,E)    
          
          complete#(u,dd(v,S),E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  complete#(u,S,E)    
          
          complete#(u,dd(v,S),E) =  [1] E + [6]         
                                 >= [1] E + [6]         
                                 =  find#(u,v,E)        
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
*** Step 6.b:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            choice#(dd(u,S),K,E) -> choice#(S,K,E)
            choice#(dd(u,S),K,E) -> choice#(S,dd(u,K),E)
            choice#(nil(),K,E) -> clique#(K,E)
            clique#(dd(u,K),E) -> clique#(K,E)
            clique#(dd(u,K),E) -> complete#(u,K,E)
            complete#(u,dd(v,S),E) -> complete#(u,S,E)
            complete#(u,dd(v,S),E) -> find#(u,v,E)
            find#(u,v,dd(dd(u2,v2),E)) -> c_9(find#(u,v,E))
        - Signature:
            {choice/3,clique/2,complete/3,find/3,ite/3,choice#/3,clique#/2,complete#/3,find#/3,ite#/3} / {dd/2,ff/0
            ,nil/0,tt/0,c_1/1,c_2/1,c_3/1,c_4/2,c_5/0,c_6/2,c_7/0,c_8/0,c_9/1,c_10/0,c_11/0,c_12/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {choice#,clique#,complete#,find#
            ,ite#} and constructors {dd,ff,nil,tt}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^3))

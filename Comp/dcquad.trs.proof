WORST_CASE(?,O(n^2))
* Step 1: DependencyPairs WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
            p(0(),s(x),y,z) -> q(x,add(x,z))
            p(s(x),y,z,u) -> p(x,s(y),s(s(z)),u)
            q(s(x),y) -> p(s(x),0(),s(0()),y)
        - Signature:
            {add/2,p/4,q/2} / {0/0,s/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add,p,q} and constructors {0,s}
    + Applied Processor:
        DependencyPairs {dpKind_ = WIDP}
    + Details:
        We add the following weak innermost dependency pairs:
        
        Strict DPs
          add#(0(),x) -> c_1()
          add#(s(x),y) -> c_2(add#(x,y))
          p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
          p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: UsableRules WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            add#(0(),x) -> c_1()
            add#(s(x),y) -> c_2(add#(x,y))
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Strict TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
            p(0(),s(x),y,z) -> q(x,add(x,z))
            p(s(x),y,z,u) -> p(x,s(y),s(s(z)),u)
            q(s(x),y) -> p(s(x),0(),s(0()),y)
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          add(0(),x) -> x
          add(s(x),y) -> s(add(x,y))
          add#(0(),x) -> c_1()
          add#(s(x),y) -> c_2(add#(x,y))
          p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
          p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
* Step 3: WeightGap WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            add#(0(),x) -> c_1()
            add#(s(x),y) -> c_2(add#(x,y))
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Strict TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        WeightGap {wgDimension = 1, wgDegree = 1, wgKind = Algebraic, wgUArgs = UArgs, wgOn = WgOnTrs}
    + Details:
        The weightgap principle applies using the following constant growth matrix-interpretation:
          We apply a matrix interpretation of kind constructor based matrix interpretation:
          The following argument positions are considered usable:
            uargs(s) = {1},
            uargs(q#) = {2},
            uargs(c_2) = {1},
            uargs(c_3) = {1},
            uargs(c_4) = {1},
            uargs(c_5) = {1}
          
          Following symbols are considered usable:
            all
          TcT has computed the following interpretation:
               p(0) = [1]                  
             p(add) = [6] x1 + [1] x2 + [0]
               p(p) = [0]                  
               p(q) = [0]                  
               p(s) = [1] x1 + [5]         
            p(add#) = [1] x2 + [0]         
              p(p#) = [6] x2 + [1] x4 + [0]
              p(q#) = [1] x2 + [0]         
             p(c_1) = [0]                  
             p(c_2) = [1] x1 + [0]         
             p(c_3) = [1] x1 + [0]         
             p(c_4) = [1] x1 + [0]         
             p(c_5) = [1] x1 + [0]         
          
          Following rules are strictly oriented:
          p#(0(),s(x),y,z) = [6] x + [1] z + [30]
                           > [6] x + [1] z + [0] 
                           = c_3(q#(x,add(x,z))) 
          
                add(0(),x) = [1] x + [6]         
                           > [1] x + [0]         
                           = x                   
          
               add(s(x),y) = [6] x + [1] y + [30]
                           > [6] x + [1] y + [5] 
                           = s(add(x,y))         
          
          
          Following rules are (at-least) weakly oriented:
             add#(0(),x) =  [1] x + [0]               
                         >= [0]                       
                         =  c_1()                     
          
            add#(s(x),y) =  [1] y + [0]               
                         >= [1] y + [0]               
                         =  c_2(add#(x,y))            
          
          p#(s(x),y,z,u) =  [1] u + [6] y + [0]       
                         >= [1] u + [6] y + [30]      
                         =  c_4(p#(x,s(y),s(s(z)),u)) 
          
              q#(s(x),y) =  [1] y + [0]               
                         >= [1] y + [6]               
                         =  c_5(p#(s(x),0(),s(0()),y))
          
        Further, it can be verified that all rules not oriented are covered by the weightgap condition.
* Step 4: PredecessorEstimation WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            add#(0(),x) -> c_1()
            add#(s(x),y) -> c_2(add#(x,y))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {1}
        by application of
          Pre({1}) = {2}.
        Here rules are labelled as follows:
          1: add#(0(),x) -> c_1()
          2: add#(s(x),y) -> c_2(add#(x,y))
          3: p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          4: q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
          5: p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
* Step 5: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            add#(0(),x) -> c_1()
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(0(),x) -> c_1():4
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):1
          
          2:S:p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
             -->_1 p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z))):5
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
          
          3:S:q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
          
          4:W:add#(0(),x) -> c_1()
             
          
          5:W:p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
             -->_1 q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y)):3
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          4: add#(0(),x) -> c_1()
* Step 6: Decompose WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        Decompose {onSelection = all cycle independent sub-graph, withBound = RelativeAdd}
    + Details:
        We analyse the complexity of following sub-problems (R) and (S).
        Problem (S) is obtained from the input problem by shifting strict rules from (R) into the weak component.
        
        Problem (R)
          - Strict DPs:
              add#(s(x),y) -> c_2(add#(x,y))
          - Weak DPs:
              p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
              p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
              q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
          - Weak TRS:
              add(0(),x) -> x
              add(s(x),y) -> s(add(x,y))
          - Signature:
              {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
          - Obligation:
              innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
        
        Problem (S)
          - Strict DPs:
              p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
              q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
          - Weak DPs:
              add#(s(x),y) -> c_2(add#(x,y))
              p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
          - Weak TRS:
              add(0(),x) -> x
              add(s(x),y) -> s(add(x,y))
          - Signature:
              {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
          - Obligation:
              innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
** Step 6.a:1: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):1
          
          2:W:p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
             -->_1 p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z))):5
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
          
          3:W:q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
          
          5:W:p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
             -->_1 q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y)):3
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          2: p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          3: q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
          5: p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
** Step 6.a:2: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          add#(s(x),y) -> c_2(add#(x,y))
** Step 6.a:3: PredecessorEstimationCP WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          1: add#(s(x),y) -> c_2(add#(x,y))
          
        The strictly oriented rules are moved into the weak component.
*** Step 6.a:3.a:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_2) = {1}
        
        Following symbols are considered usable:
          {add#,p#,q#}
        TcT has computed the following interpretation:
             p(0) = [0]                  
           p(add) = [0]                  
             p(p) = [0]                  
             p(q) = [0]                  
             p(s) = [1] x1 + [9]         
          p(add#) = [2] x1 + [1] x2 + [0]
            p(p#) = [1] x2 + [1] x3 + [0]
            p(q#) = [8]                  
           p(c_1) = [2]                  
           p(c_2) = [1] x1 + [12]        
           p(c_3) = [1] x1 + [8]         
           p(c_4) = [1] x1 + [0]         
           p(c_5) = [1] x1 + [1]         
        
        Following rules are strictly oriented:
        add#(s(x),y) = [2] x + [1] y + [18]
                     > [2] x + [1] y + [12]
                     = c_2(add#(x,y))      
        
        
        Following rules are (at-least) weakly oriented:
        
*** Step 6.a:3.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

*** Step 6.a:3.b:1: RemoveWeakSuffixes WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            add#(s(x),y) -> c_2(add#(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:W:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):1
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          1: add#(s(x),y) -> c_2(add#(x,y))
*** Step 6.a:3.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

** Step 6.b:1: RemoveWeakSuffixes WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            add#(s(x),y) -> c_2(add#(x,y))
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
             -->_1 p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z))):4
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):1
          
          2:S:q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):1
          
          3:W:add#(s(x),y) -> c_2(add#(x,y))
             -->_1 add#(s(x),y) -> c_2(add#(x,y)):3
          
          4:W:p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
             -->_1 q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y)):2
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: add#(s(x),y) -> c_2(add#(x,y))
** Step 6.b:2: PredecessorEstimationCP WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          2: q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
          
        The strictly oriented rules are moved into the weak component.
*** Step 6.b:2.a:1: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_3) = {1},
          uargs(c_4) = {1},
          uargs(c_5) = {1}
        
        Following symbols are considered usable:
          {add#,p#,q#}
        TcT has computed the following interpretation:
             p(0) = [0]                  
           p(add) = [4] x1 + [1] x2 + [4]
             p(p) = [1]                  
             p(q) = [2]                  
             p(s) = [1] x1 + [3]         
          p(add#) = [1] x1 + [2]         
            p(p#) = [8] x1 + [8] x2 + [0]
            p(q#) = [8] x1 + [1]         
           p(c_1) = [1]                  
           p(c_2) = [8]                  
           p(c_3) = [1] x1 + [4]         
           p(c_4) = [1] x1 + [0]         
           p(c_5) = [1] x1 + [0]         
        
        Following rules are strictly oriented:
        q#(s(x),y) = [8] x + [25]              
                   > [8] x + [24]              
                   = c_5(p#(s(x),0(),s(0()),y))
        
        
        Following rules are (at-least) weakly oriented:
        p#(0(),s(x),y,z) =  [8] x + [24]             
                         >= [8] x + [5]              
                         =  c_3(q#(x,add(x,z)))      
        
          p#(s(x),y,z,u) =  [8] x + [8] y + [24]     
                         >= [8] x + [8] y + [24]     
                         =  c_4(p#(x,s(y),s(s(z)),u))
        
*** Step 6.b:2.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

*** Step 6.b:2.b:1: PredecessorEstimationCP WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        PredecessorEstimationCP {onSelectionCP = any intersect of rules of CDG leaf and strict-rules, withComplexityPair = NaturalPI {shape = Mixed 2, restrict = Restrict, uargs = UArgs, urules = URules, selector = Nothing}}
    + Details:
        We first use the processor NaturalPI {shape = Mixed 2, restrict = Restrict, uargs = UArgs, urules = URules, selector = Nothing} to orient following rules strictly:
          1: p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          
        Consider the set of all dependency pairs
          1: p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          2: p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
          3: q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        Processor NaturalPI {shape = Mixed 2, restrict = Restrict, uargs = UArgs, urules = URules, selector = Nothing}induces the complexity certificateTIME (?,O(n^2))
        SPACE(?,?)on application of the dependency pairs
          {1}
        These cover all (indirect) predecessors of dependency pairs
          {1,2,3}
        their number of applications is equally bounded.
        The dependency pairs are shifted into the weak component.
**** Step 6.b:2.b:1.a:1: NaturalPI WORST_CASE(?,O(n^2))
    + Considered Problem:
        - Strict DPs:
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        NaturalPI {shape = Mixed 2, restrict = Restrict, uargs = UArgs, urules = URules, selector = Just first alternative for predecessorEstimation on any intersect of rules of CDG leaf and strict-rules}
    + Details:
        We apply a polynomial interpretation of kind constructor-based(mixed(2)):
        The following argument positions are considered usable:
          uargs(c_3) = {1},
          uargs(c_4) = {1},
          uargs(c_5) = {1}
        
        Following symbols are considered usable:
          {add,add#,p#,q#}
        TcT has computed the following interpretation:
             p(0) = 0                                          
           p(add) = 2 + 2*x1^2 + x2                            
             p(p) = 4*x1*x3 + 2*x2*x4 + x2^2 + x4^2            
             p(q) = 4 + 4*x1*x2 + 4*x2 + 4*x2^2                
             p(s) = 1 + x1                                     
          p(add#) = 1 + x2                                     
            p(p#) = 1 + 6*x1 + 4*x1*x2 + 2*x1^2 + 4*x2 + 2*x2^2
            p(q#) = 5 + 6*x1 + 2*x1^2                          
           p(c_1) = 0                                          
           p(c_2) = 4 + x1                                     
           p(c_3) = 1 + x1                                     
           p(c_4) = 1 + x1                                     
           p(c_5) = 3 + x1                                     
        
        Following rules are strictly oriented:
        p#(s(x),y,z,u) = 9 + 10*x + 4*x*y + 2*x^2 + 8*y + 2*y^2
                       > 8 + 10*x + 4*x*y + 2*x^2 + 8*y + 2*y^2
                       = c_4(p#(x,s(y),s(s(z)),u))             
        
        
        Following rules are (at-least) weakly oriented:
        p#(0(),s(x),y,z) =  7 + 8*x + 2*x^2           
                         >= 6 + 6*x + 2*x^2           
                         =  c_3(q#(x,add(x,z)))       
        
              q#(s(x),y) =  13 + 10*x + 2*x^2         
                         >= 12 + 10*x + 2*x^2         
                         =  c_5(p#(s(x),0(),s(0()),y))
        
              add(0(),x) =  2 + x                     
                         >= x                         
                         =  x                         
        
             add(s(x),y) =  4 + 4*x + 2*x^2 + y       
                         >= 3 + 2*x^2 + y             
                         =  s(add(x,y))               
        
**** Step 6.b:2.b:1.a:2: Assumption WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        Assumption {assumed = Certificate {spaceUB = Unknown, spaceLB = Unknown, timeUB = Poly (Just 0), timeLB = Unknown}}
    + Details:
        ()

**** Step 6.b:2.b:1.b:1: RemoveWeakSuffixes WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
            p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
            q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:W:p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
             -->_1 q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y)):3
          
          2:W:p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
             -->_1 p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z))):1
          
          3:W:q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
             -->_1 p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u)):2
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          1: p#(0(),s(x),y,z) -> c_3(q#(x,add(x,z)))
          2: p#(s(x),y,z,u) -> c_4(p#(x,s(y),s(s(z)),u))
          3: q#(s(x),y) -> c_5(p#(s(x),0(),s(0()),y))
**** Step 6.b:2.b:1.b:2: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak TRS:
            add(0(),x) -> x
            add(s(x),y) -> s(add(x,y))
        - Signature:
            {add/2,p/4,q/2,add#/2,p#/4,q#/2} / {0/0,s/1,c_1/0,c_2/1,c_3/1,c_4/1,c_5/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {add#,p#,q#} and constructors {0,s}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^2))

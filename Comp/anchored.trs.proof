WORST_CASE(?,O(n^1))
* Step 1: DependencyPairs WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict TRS:
            anchored(Cons(x,xs),y) -> anchored(xs,Cons(Cons(Nil(),Nil()),y))
            anchored(Nil(),y) -> y
            goal(x,y) -> anchored(x,y)
        - Signature:
            {anchored/2,goal/2} / {Cons/2,Nil/0}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored,goal} and constructors {Cons,Nil}
    + Applied Processor:
        DependencyPairs {dpKind_ = DT}
    + Details:
        We add the following dependency tuples:
        
        Strict DPs
          anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
          anchored#(Nil(),y) -> c_2()
          goal#(x,y) -> c_3(anchored#(x,y))
        Weak DPs
          
        
        and mark the set of starting terms.
* Step 2: PredecessorEstimation WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
            anchored#(Nil(),y) -> c_2()
            goal#(x,y) -> c_3(anchored#(x,y))
        - Weak TRS:
            anchored(Cons(x,xs),y) -> anchored(xs,Cons(Cons(Nil(),Nil()),y))
            anchored(Nil(),y) -> y
            goal(x,y) -> anchored(x,y)
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        PredecessorEstimation {onSelection = all simple predecessor estimation selector}
    + Details:
        We estimate the number of application of
          {2}
        by application of
          Pre({2}) = {1,3}.
        Here rules are labelled as follows:
          1: anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
          2: anchored#(Nil(),y) -> c_2()
          3: goal#(x,y) -> c_3(anchored#(x,y))
* Step 3: RemoveWeakSuffixes WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
            goal#(x,y) -> c_3(anchored#(x,y))
        - Weak DPs:
            anchored#(Nil(),y) -> c_2()
        - Weak TRS:
            anchored(Cons(x,xs),y) -> anchored(xs,Cons(Cons(Nil(),Nil()),y))
            anchored(Nil(),y) -> y
            goal(x,y) -> anchored(x,y)
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveWeakSuffixes
    + Details:
        Consider the dependency graph
          1:S:anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
             -->_1 anchored#(Nil(),y) -> c_2():3
             -->_1 anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y))):1
          
          2:S:goal#(x,y) -> c_3(anchored#(x,y))
             -->_1 anchored#(Nil(),y) -> c_2():3
             -->_1 anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y))):1
          
          3:W:anchored#(Nil(),y) -> c_2()
             
          
        The following weak DPs constitute a sub-graph of the DG that is closed under successors. The DPs are removed.
          3: anchored#(Nil(),y) -> c_2()
* Step 4: RemoveHeads WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
            goal#(x,y) -> c_3(anchored#(x,y))
        - Weak TRS:
            anchored(Cons(x,xs),y) -> anchored(xs,Cons(Cons(Nil(),Nil()),y))
            anchored(Nil(),y) -> y
            goal(x,y) -> anchored(x,y)
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        RemoveHeads
    + Details:
        Consider the dependency graph
        
        1:S:anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
           -->_1 anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y))):1
        
        2:S:goal#(x,y) -> c_3(anchored#(x,y))
           -->_1 anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y))):1
        
        
        Following roots of the dependency graph are removed, as the considered set of starting terms is closed under reduction with respect to these rules (modulo compound contexts).
        
        [(2,goal#(x,y) -> c_3(anchored#(x,y)))]
* Step 5: UsableRules WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
        - Weak TRS:
            anchored(Cons(x,xs),y) -> anchored(xs,Cons(Cons(Nil(),Nil()),y))
            anchored(Nil(),y) -> y
            goal(x,y) -> anchored(x,y)
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        UsableRules
    + Details:
        We replace rewrite rules by usable rules:
          anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
* Step 6: NaturalMI WORST_CASE(?,O(n^1))
    + Considered Problem:
        - Strict DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        NaturalMI {miDimension = 1, miDegree = 1, miKind = Algebraic, uargs = UArgs, urules = URules, selector = Just any strict-rules}
    + Details:
        We apply a matrix interpretation of kind constructor based matrix interpretation:
        The following argument positions are considered usable:
          uargs(c_1) = {1}
        
        Following symbols are considered usable:
          {anchored#,goal#}
        TcT has computed the following interpretation:
               p(Cons) = [1] x2 + [4]         
                p(Nil) = [2]                  
           p(anchored) = [1] x1 + [1] x2 + [2]
               p(goal) = [2] x1 + [2] x2 + [8]
          p(anchored#) = [4] x1 + [2]         
              p(goal#) = [2] x1 + [8] x2 + [2]
                p(c_1) = [1] x1 + [12]        
                p(c_2) = [1]                  
                p(c_3) = [1] x1 + [1]         
        
        Following rules are strictly oriented:
        anchored#(Cons(x,xs),y) = [4] xs + [18]                               
                                > [4] xs + [14]                               
                                = c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
        
        
        Following rules are (at-least) weakly oriented:
        
* Step 7: EmptyProcessor WORST_CASE(?,O(1))
    + Considered Problem:
        - Weak DPs:
            anchored#(Cons(x,xs),y) -> c_1(anchored#(xs,Cons(Cons(Nil(),Nil()),y)))
        - Signature:
            {anchored/2,goal/2,anchored#/2,goal#/2} / {Cons/2,Nil/0,c_1/1,c_2/0,c_3/1}
        - Obligation:
            innermost runtime complexity wrt. defined symbols {anchored#,goal#} and constructors {Cons,Nil}
    + Applied Processor:
        EmptyProcessor
    + Details:
        The problem is already closed. The intended complexity is O(1).

WORST_CASE(?,O(n^1))
